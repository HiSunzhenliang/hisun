<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 中 accumulate() 的使用</title>
    <url>/wiki/C++%E4%B8%ADaccumulate()%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><code>accumulate()</code>定义在<code>#include&lt;numeric&gt;</code>中，</p>
<a id="more"></a>

<p>作用: </p>
<ul>
<li>累加求和</li>
<li>自定义类型数据的处理</li>
</ul>
<h2 id="1-累加求和"><a href="#1-累加求和" class="headerlink" title="1.累加求和"></a>1.累加求和</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = accumulate(vec.begin() , vec.end() , <span class="number">0</span>);  </span><br><span class="line"><span class="comment">//形参：前两个形参指定要累加的元素范围，第三个形参则是累加的初值</span></span><br></pre></td></tr></table></figure>

<p>accumulate函数将它的一个内部变量设置为指定的初始值，然后在此初值上累加输入范围内所有元素的值。accumulate算法返回累加的结果，其返回类型就是其第三个实参的类型。</p>
<p>可以使用accumulate把string型的vector容器中的元素连接起来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> sum = accumulate(v.begin() , v.end() , <span class="built_in">string</span>(<span class="string">&quot; &quot;</span>));  </span><br><span class="line"><span class="comment">//这个函数调用的效果是：从空字符串开始，把vec里的每个元素连接成一个字符串。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-自定义数据类型的处理"><a href="#2-自定义数据类型的处理" class="headerlink" title="2.自定义数据类型的处理"></a>2.自定义数据类型的处理</h2><p>通用的数值类型计算函数<code>accumulate()</code>,可以用来直接计算数组或者容器中C++内置数据类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;  </span></span></span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;  </span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">va</span><span class="params">(&amp;arr[<span class="number">0</span>],&amp;arr[<span class="number">5</span>])</span></span>;  </span><br><span class="line"><span class="keyword">int</span> sum=accumulate(va.begin(),va.end(),<span class="number">0</span>);  <span class="comment">//sum = 150  </span></span><br></pre></td></tr></table></figure>


<p>但是对于自定义数据类型，我们就需要自己动手写一个回调函数来实现自定义数据的处理，然后让它作为<code>accumulate()</code>的第四个参数，<code>accumulate()</code>的原型为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">InIt</span>, <span class="keyword">class</span> _<span class="title">Ty</span>,  <span class="keyword">class</span> _<span class="title">Fn2</span>&gt;</span> </span><br><span class="line"><span class="keyword">inline</span> _Ty _Accumulate(_InIt _First, _InIt _Last, _Ty _Val, _Fn2 _Func)  </span><br><span class="line">&#123;   <span class="comment">// return sum of _Val and all in [_First, _Last), using _Func  </span></span><br><span class="line">    <span class="keyword">for</span> (; _First != _Last; ++_First)  </span><br><span class="line">        _Val = _Func(_Val, *_First);  </span><br><span class="line">    <span class="keyword">return</span> (_Val);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Grade</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    <span class="keyword">int</span> grade;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Grade subject[<span class="number">3</span>] = &#123;  </span><br><span class="line">        &#123; <span class="string">&quot;English&quot;</span>, <span class="number">80</span> &#125;,  </span><br><span class="line">        &#123; <span class="string">&quot;Biology&quot;</span>, <span class="number">70</span> &#125;,  </span><br><span class="line">        &#123; <span class="string">&quot;History&quot;</span>, <span class="number">90</span> &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(subject, subject + <span class="number">3</span>, <span class="number">0</span>, [](<span class="keyword">int</span> a, Grade b)&#123;<span class="keyword">return</span> a + b.grade; &#125;);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Language</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 学习路线</title>
    <url>/wiki/C++%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<blockquote>
<p>羊哥出了个 C/C++ 学习路线，感觉挺靠谱，也切实符合我现在的情况，准备按着这个路线来学习了。源链接 <a href="https://mp.weixin.qq.com/s/tXilzUzN7cDhnc3ztw4Vlw">这才是你需要的C语言、C++学习路线！</a> ,下文为转载。</p>
</blockquote>
<a id="more"></a>

<p>小伙伴们，大家好。</p>
<p>关于 C 语言和 C++ 的学习路线终于梳理完了。当然我也只能从我曾经近 3 年的通信公司后台开发经历和目之所及的世界，跟大家聊聊这个话题。</p>
<p>这块的东西很多很杂，不过梳理和总结之后，回过头来看，其实学习思路、学习路线应该还是比较清晰的。由于个人认知有限，不足的地方也欢迎大家评论里补充。</p>
<hr>
<h2 id="先聊几个有趣的问题"><a href="#先聊几个有趣的问题" class="headerlink" title="先聊几个有趣的问题"></a><strong>先聊几个有趣的问题</strong></h2><p>这几个问题都是私信里常被问到的，也是我当时学习过程中的一些疑惑。</p>
<p><strong>问：</strong> 为啥我学完了 C 语言或者 C++，却还是啥东西也做不出来？</p>
<blockquote>
<p><strong>答：</strong> 编程语言学完了就能做出东西那也真是天才哇！应该说语言学得就算再精通，它其实也只代表完成了“最小的”那一部分，和实际上手干活之间还是有一个非常大的<strong>鸿沟</strong>，这个鸿沟就表现为下文即将详述的 <strong>编程基础四大件</strong> + <strong>应用实践编程</strong>。</p>
</blockquote>
<p><strong>问：</strong> 为什么 C/C++ 写出来的东西都是运行于黑乎乎的命令行？这玩意真有用吗？</p>
<blockquote>
<p><strong>答：</strong> 嘿嘿，谁说黑乎乎的命令行里运行的程序就没有用！咱大名鼎鼎的 Linux 系统都以命令行跟用户交互呢，而且 Linux 里面很多强大的工具都是运行于黑乎乎的命令行！</p>
</blockquote>
<p><strong>问：</strong> 从技术学习和实际运用的角度来看，C/C++ 和 Java 到底区别在哪？</p>
<blockquote>
<p><strong>答：</strong> C/C++，它和 Java 确实不太一样。C 语言和 C++，尤其 C++，语言粒度细、机制多，性能虽然高，但语言本身的包袱也确实重，我们更愿意称它“造轮子”的语言！也正是因为 C 语言和 C++ 性能好、粒度细，所以什么都能做。而 Java 本身就是一种服务于互联网软件开发（后端开发 + 客户端开发）的语言，它有一个明显的“生态圈”的概念，所以应用领域非常清晰。我个人觉得 C 语言和 C++ 编程比 Java 还是要难一些，Java 毕竟是纯应用层的，C 语言和 C++ 则对程序员能力的要求要更高一些。</p>
</blockquote>
<hr>
<h2 id="岗位分析"><a href="#岗位分析" class="headerlink" title="岗位分析"></a><strong>岗位分析</strong></h2><p>了解一下岗位，知道以后能做什么，这个也有利于自己树立学习目标。</p>
<p>C 语言和 C++ 属于“造轮子”语言，几乎什么都能做。不过一般来说，C 语言和 C++ 主要还是做后台（服务端）开发比较多，包括：</p>
<ul>
<li>通信公司后台开发</li>
<li>互联网公司后台开发</li>
<li>游戏公司后台开发</li>
<li>……</li>
</ul>
<p>当然这个后台开发具体职责又有很多细分，比如：</p>
<ul>
<li>有做数据处理和分析的</li>
<li>有做基础协议和通信的</li>
<li>有做服务端底层应用优化的</li>
<li>甚至还有做后台系统驱动和内核的</li>
<li>……</li>
</ul>
<p>不管怎样，下面即将要介绍的这些学习路线和内容适用于以上所有情况。</p>
<hr>
<h2 id="语言本身的学习"><a href="#语言本身的学习" class="headerlink" title="语言本身的学习"></a><strong>语言本身的学习</strong></h2><p><strong>C 语言：</strong></p>
<ul>
<li>除了最最基础的语法：变量、条件、循环、字符串、数组、函数、结构体等之外</li>
<li>C 语言最最最最最重要的那就是：指针、内存管理，以后企业里开发就靠它俩吃饭，这也是检验 C 语言掌握情况的两大标准</li>
</ul>
<blockquote>
<p><strong>推荐书籍</strong>：《C Primer Plus》、《C 和指针》、《C 专家编程》</p>
</blockquote>
<p><strong>C++：</strong></p>
<ul>
<li>C++ 和 C 语言确实是不同的语言，但是 C++ 确实是对 C 语言的延伸，可以理解为在 C 语言里加入了面向对象的特性。因为只有面向对象特性的加持，代码才能更好的<strong>复用</strong>、<strong>扩展</strong>和<strong>工程化</strong>，这是大型项目的必备要素</li>
<li>除了 C 语言所有的底子之外，还需要学习 C++ 的面向对象（封装、继承与多态）特性、泛型、模板、STL 等等</li>
</ul>
<blockquote>
<p><strong>推荐书籍（有先后顺序）</strong>：《C++ Primer》、《Effective C++》、《C++ 标准程序库》、《STL 源码剖析》《深度探索 C++ 对象模型》</p>
</blockquote>
<p><strong>最后一个小建议是</strong>：语言部分的学习建议不要拖太久，一定要规划好时间，一鼓作气，高强度给它压下来，否则容易把自己拖泄气。</p>
<hr>
<h2 id="编程基础“四大件”"><a href="#编程基础“四大件”" class="headerlink" title="编程基础“四大件”"></a><strong>编程基础“四大件”</strong></h2><p>基础四大件包括：<strong>数据结构和算法</strong>、<strong>计算机网络</strong>、<strong>操作系统</strong>、<strong>设计模式</strong></p>
<p>这跟学什么编程语言、后续从事什么编程方向均无关，只要做编程开发，这四个计算机基础就无法避开。可以这么说，<strong>这基础四大件真的比编程语言重要！**</strong>！**<strong>！</strong></p>
<p><strong>1、数据结构和算法</strong></p>
<p>可以说这个直接决定了面试的成败！几种基础数据结构类型得烂熟于心，比如：字符串、链表、二叉树、堆、栈、队列、哈希等；基本的几大算法也要了如指掌，比如查找、排序、动态规划、分治等等。</p>
<p>建议 LeetCode 多刷题啊啊啊啊啊！</p>
<blockquote>
<p><strong>参考资料：</strong> 《大话数据结构》、《算法》、《剑指 offer》《LeetCode 刷题》</p>
</blockquote>
<p><strong>2、计算机网络</strong></p>
<p>此处的计算机网络指的就是 TCP/IP 协议栈，可以说它是当下互联网通信的基石，无论如何一定要对 TCP/IP 的协议栈了如指掌，主要就是学习和掌握原理，包括：<strong>ARP 协议、IP 协议、ICMP 协议、TCP 和 UDP 协议、DNS 协议、HTTP 协议、HTTPS 协议</strong>。</p>
<blockquote>
<p><strong>推荐书籍：</strong> 《TCP/IP 详解》</p>
</blockquote>
<p><strong>3、操作系统</strong></p>
<p>该部分重点包括：进程和线程的相关原理（原子性、并发、锁）、内存相关原理（内存分布、内存调度）</p>
<blockquote>
<p><strong>推荐书籍：</strong>《深入理解计算机系统》</p>
</blockquote>
<p><strong>4、设计模式</strong></p>
<p>倒不需要 23 种设计模式全部记住，常见的几个如：<strong>单例模式、工厂模式、代理模式、策略模式、模板方法模式</strong>建议熟练于心。</p>
<blockquote>
<p><strong>推荐书籍：</strong>《大话设计模式》、《设计模式之禅》</p>
</blockquote>
<hr>
<h2 id="应用实践编程"><a href="#应用实践编程" class="headerlink" title="应用实践编程"></a><strong>应用实践编程</strong></h2><p>这部分会涉及到一些工具、编程环境、和具体编程实践，应该说这一部分学完，自己应该能做点东西出来、或者说能看懂一些实际项目的代码。</p>
<p>实践这部分，我也是结合我之前在通信公司的实际工作经历和所听所见，来聊一聊。</p>
<p><strong>1、Linux 操作系统的使用</strong></p>
<p>很多人初学 C 语言、C++（包括我）都是在 Windows 环境上进行的，而实际企业级开发几乎不可能，所以 Linux 系统必须要会，我们别无选择。先谈使用。</p>
<p>包括：<strong>常见的 Linux 操作命令</strong>、<strong>基本的 Shell 编程</strong>。</p>
<blockquote>
<p><strong>推荐书籍：</strong>《鸟哥的 Linux 私房菜》</p>
</blockquote>
<p><strong>2、编译 / 调试工具</strong></p>
<p>首先是跟编译相关的：<strong>编译工具！</strong></p>
<p>我们知道很多人学 C 语言、C++ 都在类似 Visual Studio 这种集成 IDE 里进行代码编译，这个其实也用了编译器，只不过是微软自家的 MS 编译器，而且所有操作均可视化。而企业里开发很少会基于 Windows 系统，所以 Linux 平台上的编译器更为重要，最典型的当属 <code>GCC</code>，甚至有些公司有自己定制过的交叉编译工具，但没关系，只要 <code>GCC</code>熟悉，其他问题都不大。</p>
<p>其次，大家自学 C 语言、C++，都借助类似 VS 这种 IDE，点按钮即可对源文件编译。而企业里实际项目的编译动作叫 <code>make</code>，编译的实际动作和过程都是写在 <code>makefile</code>文件里，所以<strong>makefile 的书写</strong>规则建议学习！</p>
<p>最后说到<strong>调试工具</strong>，Linux 平台上的 <code>GDB</code>调试工具要熟练使用，会借助于它进行调试。</p>
<blockquote>
<p><strong>推荐资料：</strong> 这部分没有书可推荐，英文好的同学可以直接看 <code>GNU</code>官网关于 <code>GCC</code>和 <code>GDB</code>的文档，中文材料可以看：《debuging with gdb》（中文版）和陈皓先生的《跟我一起写 makefile》</p>
</blockquote>
<p><strong>3、Linux 环境编程</strong></p>
<p>还是那句话，企业里 C 语言和 C++ 几乎都是基于 Linux 平台的，这一部分我们没办法避开</p>
<p>（1）Linux 系统编程</p>
<p>众所周知，Windows 系统编程里有各种各样的 Windows API，同理 Linux 系统 API 的使用就更加重要。</p>
<p>（2）多线程编程</p>
<p>此处指的是多线程编程实践相关的东西，一般包括：线程、资源、信号、同步、互斥、锁等等一些具体的编程方法。</p>
<p>（3）网络编程</p>
<p>此处的网络编程主要指的是具体 Linux 系统上的网络编程 <code>API</code>和 <code>IO</code>函数的编程实践。</p>
<blockquote>
<p><strong>推荐书籍</strong>：这三部分综合在一起，推荐必看书籍包括《Unix 环境高级编程》、《Linux 高性能服务器编程》、《POSIX 多线程程序设计》</p>
</blockquote>
]]></content>
      <categories>
        <category>Language</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 求最大公约数和最小公倍数</title>
    <url>/wiki/C++%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="一、最大公约数与最小公倍数"><a href="#一、最大公约数与最小公倍数" class="headerlink" title="一、最大公约数与最小公倍数"></a>一、最大公约数与最小公倍数</h1><ul>
<li><p>最大公约数可以通过下面的三种方法求出来。</p>
</li>
<li><p>最小公倍数，它与最大公约数的乘机为所求数之积。<br>比如求  x,y 的最大公约数和最小公倍数<br>记住这个公式： x × y= 最小公倍数 × 最大公约数</p>
<a id="more"></a>

</li>
</ul>
<h1 id="二、求最大公约数的三种方法"><a href="#二、求最大公约数的三种方法" class="headerlink" title="二、求最大公约数的三种方法"></a>二、求最大公约数的三种方法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxNum1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        swap(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (a % b) &#123;</span><br><span class="line">        t = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相减</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxNum2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? (a = a - b) : (b = b - a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//穷举</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxNum3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = a;; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> (a * b) / maxNum1(a, b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxNum1(num1, num2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxNum2(num1, num2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxNum3(num1, num2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; minNum(num1, num2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>C++教程项目练习</title>
    <url>/wiki/C++%E7%BB%83%E4%B9%A0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>再次学习完 C++ 课程，这次完善了学校里未介绍的模板编程和 STL 使用。</p>
<p>下面是相关练习项目：</p>
<ul>
<li><a href="https://github.com/HiSunzhenliang/ContactsManageSystem">ContactsManageSystem</a></li>
<li>基于多态：<a href="https://github.com/HiSunzhenliang/StaffManageSystem">StaffManageSystem</a></li>
<li>基于STL泛化编程：<a href="https://github.com/HiSunzhenliang/ComputerRoomReservationSystem">ComputerRoomReservationSystem</a></li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>练习项目</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg 开发环境构建</title>
    <url>/wiki/FFmpeg%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装平台"><a href="#安装平台" class="headerlink" title="安装平台"></a>安装平台</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">             ............</span><br><span class="line">         .&#x27;;;;;;.       .,;,.            ----------</span><br><span class="line">      .,;;;;;;;.       &#x27;;;;;;;;.         OS: Deepin 20 x86_64</span><br><span class="line">    .;::::::::&#x27;     .,::;;,&#x27;&#x27;&#x27;&#x27;&#x27;,.       Model: 10SMCTO1WW ThinkCentre M920t-N000</span><br><span class="line">   ,&#x27;.::::::::    .;;&#x27;.          &#x27;;      Kernel: 5.4.70-amd64-desktop</span><br><span class="line">  ;&#x27;  &#x27;cccccc,   ,&#x27; :: &#x27;..        .:     Uptime: 4 days, 4 hours, 14 minutes</span><br><span class="line"> ,,    :ccccc.  ;: .c, &#x27;&#x27; :.       ,;    Packages: 2561 (dpkg), 9 (snap)</span><br><span class="line">.l.     cllll&#x27; ., .lc  :; .l&#x27;       l.   Shell: zsh 5.7.1</span><br><span class="line">.c       :lllc  ;cl:  .l&#x27; .ll.      :&#x27;   Resolution: 1920x1080</span><br><span class="line">.l        &#x27;looc. .   ,o:  &#x27;oo&#x27;      c,   DE: Deepin</span><br><span class="line">.o.         .:ool::coc&#x27;  .ooo&#x27;      o.   WM: KWin</span><br><span class="line"> ::            .....   .;dddo      ;c    Theme: deepin-dark [GTK2/3]</span><br><span class="line">  l:...            .&#x27;;lddddo.     ,o     Icons: Papirus [GTK3]</span><br><span class="line">   lxxxxxdoolllodxxxxxxxxxc      :l      Terminal: konsole</span><br><span class="line">    ,dxxxxxxxxxxxxxxxxxxl.     &#x27;o,       CPU: Intel i5-9500F (6) @ 4.400GHz</span><br><span class="line">      ,dkkkkkkkkkkkkko;.    .;o;         GPU: AMD ATI Radeon HD 8570 / R7 240/340 / R520 OEM</span><br><span class="line">        .;okkkkkdl;.    .,cl:.           Memory: 4032MiB / 7836MiB</span><br><span class="line">            .,:cccccccc:,.</span><br></pre></td></tr></table></figure>

<h2 id="安装本体"><a href="#安装本体" class="headerlink" title="安装本体"></a>安装本体</h2><p>ffmpeg-4.3.git<br>官网<a href="https://ffmpeg.org/">https://ffmpeg.org/</a></p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h3><p>Simple DirectMedia Layer 是一个跨平台的开发库，旨在通过 OpenGL 和 Direct3D 提供对音频、键盘、鼠标、操纵杆和图形硬件的低级访问。它用于视频播放软件、模拟器和流行游戏。<br>SDL官网<a href="https://www.libsdl.org/">https://www.libsdl.org/</a></p>
<h3 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h3><p>Netwide Assembler 是 x86 架构的汇编与反汇编工具。<br>如果在在 arm 等其他平台，交叉编译工具链中包含有对应的汇编器，则交叉编译 ffmpeg 时需要 <code>--disable-x86asm</code> 选项。<br>NASM 官网：<a href="https://www.nasm.us/">https://www.nasm.us/</a></p>
<h3 id="x264"><a href="#x264" class="headerlink" title="x264"></a>x264</h3><p>x264 是开源的 h264 编码器。<br>ffmpeg 工程中实现了 h264 解码器，但无 h264 编码器。因此需要安装第三方编码器 x264<br>x264 官网<a href="https://www.videolan.org/developers/x264.html">https://www.videolan.org/developers/x264.html</a></p>
<h3 id="x265"><a href="#x265" class="headerlink" title="x265"></a>x265</h3><p>x265 是开源的 h265 编码器。<br>ffmpeg 工程中实现了 h265 解码器，但无 h265 编码器。因此需要安装第三方编码器 x265<br>x265 官网：<a href="http://www.x265.org/">http://www.x265.org/</a></p>
<h3 id="libmp3lame"><a href="#libmp3lame" class="headerlink" title="libmp3lame"></a>libmp3lame</h3><p>libmp3lame 是开源的 mp3 编码器。<br>libmp3lame 官网<a href="http://lame.sourceforge.net/">http://lame.sourceforge.net/</a></p>
<h3 id="libopencore-amr"><a href="#libopencore-amr" class="headerlink" title="libopencore-amr"></a>libopencore-amr</h3><p>libopencore-amr 是开源 amr 编解码器<br>libopencore-amr 官网<a href="https://sourceforge.net/projects/opencore-amr/files/">https://sourceforge.net/projects/opencore-amr/files/</a></p>
<h2 id="编译安装过程"><a href="#编译安装过程" class="headerlink" title="编译安装过程"></a>编译安装过程</h2><p>先安装上述依赖，一般优先<code>apt install</code>。如果源里没有则下载源码编译安装。</p>
<p>ffmpeg 不是使用 automake 等工具，而是自己编写的构建脚本。</p>
<ol>
<li>configure<br>Configure 一方面用于检测 FFmpeg 的编译环境，另一方面根据用户配置的选项生成 config.mak，config.h 文件（可能还有 config.asm），提供给 Makefile 使用。FFmpeg 的 configure 脚本很复杂（一个 4000-5000 行的 Shell 脚本）。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=PATH \</span><br><span class="line">--enable-sdl \</span><br><span class="line">--enable-gpl \</span><br><span class="line">--enable-version3 \</span><br><span class="line">--enable-libmp3lame \</span><br><span class="line">--enable-debug  \</span><br><span class="line">--enable-libopencore-amrnb \</span><br><span class="line">--enable-libopencore-amrwb \</span><br><span class="line">--enable-libx265 \</span><br><span class="line">--enable-libx264</span><br></pre></td></tr></table></figure>

<p><code>--enable-gpl</code>、<code>--enable-version3</code>是 ffmpeg 中使用不同的链接动态库需要不同的开源协议支持。一般可以查询官网 wiki 或者脚本会提示需要指定开源协议版本。<br><code>./configure --help</code>查看可用选项。其中 ffmpeg 也内置 fate 测试和检查工具等。<br>2. <code>make</code><br>3. <code>make install</code></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>ffmpeg -v</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg version N-99648-g0c9cf6ea9a Copyright (c) 2000-2020 the FFmpeg developers</span><br><span class="line">  built with gcc 8 (Uos 8.3.0.3-3+rebuild)</span><br><span class="line">  configuration: --prefix=/home/sun/.local --enable-sdl --enable-gpl --enable-version3 --disable-x86asm --enable-libmp3lame --enable-debug --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libx265 --enable-libx264</span><br><span class="line">  libavutil      56. 60.100 / 56. 60.100</span><br><span class="line">  libavcodec     58.111.101 / 58.111.101</span><br><span class="line">  libavformat    58. 62.100 / 58. 62.100</span><br><span class="line">  libavdevice    58. 11.102 / 58. 11.102</span><br><span class="line">  libavfilter     7. 87.100 /  7. 87.100</span><br><span class="line">  libswscale      5.  8.100 /  5.  8.100</span><br><span class="line">  libswresample   3.  8.100 /  3.  8.100</span><br><span class="line">  libpostproc    55.  8.100 / 55.  8.100</span><br><span class="line">Missing argument for option &#x27;v&#x27;.</span><br><span class="line">Error splitting the argument list: Invalid argument</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://ffmpeg.org/documentation.html">ffmpeg document</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Video</category>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>G.711 编解码原理</title>
    <url>/wiki/G-711%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="G-711-编解码原理"><a href="#G-711-编解码原理" class="headerlink" title="G.711 编解码原理"></a>G.711 编解码原理</h1><p>G.711 是 ITU-T 定制出来的一套语音压缩标准，它代表了对数 PCM（logarithmic pulse-code modulation）抽样标准，是主流的波形声音编解码标准，主要用于电话。</p>
<p>G.711 编码采用 8kHz 采样率，有 A-law 和μ-law 两种编码方式，分别是将 13bit 和 14bit 编码为 8bit，因此 G711 固定码率是 8kHz×8bit=64kbps。两者都是对数变换，A-law 更加方便计算机处理。μ-law 提供了略微高一些的动态范围，但代价是对于弱信号的量化误差相对 A-law 高一些。</p>
<h2 id="转换公式"><a href="#转换公式" class="headerlink" title="转换公式"></a>转换公式</h2><p>下面分别介绍两种算法的转换公式。</p>
<p>A-law:</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144349406.png"></p>
<p>一般采用 A=87.6, 画出图来则是如下图，用 x 表示输入的采样值，F(x) 表示通过 A-law 变换后的采样值，y 是对 F(x) 进行量化后的采样值。</p>
<img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144420043.png" alt="image-20201130144420043" style="zoom:80%;" />

<p>由此可见在输入的 x 为高值的时候，F(x) 的变化是缓慢的，有较大范围的 x 对应的 F(x) 最终被量化为同一个 y，精度较低。相反在低声强区域，也就是 x 为低值的时候，F(x) 的变化很剧烈，有较少的不同 x 对应的 F(x) 被量化为同一个 y。意思就是说在声音比较小的区域，精度较高，便于区分，而声音比较大的区域，精度不是那么高。</p>
<p> μ-law 的公式如下，μ取值一般为 255</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144523378.png"></p>
<p>和 A-law 画在同一个坐标轴中就能发现 A-law 在低强度信号下，精度要稍微高一些。</p>
<img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144536867.png" alt="image-20201130144536867" style="zoom:80%;" />

<p>实际应用中，采用浮点数计算的方式计算，然后进行量化，计算量会比较大，实际上对于 A-law（A=87.6 时），是采用 13 折线近似的方式来计算的，而μ-law（μ=255 时）则是 15 段折线近似的方式。</p>
<p>A-law 如下表计算，第一列是采样点，共 13bit，最高位为符号位。对于前两行，折线斜率均为 1/2，跟负半段的相应区域位于同一段折线上，对于 3 到 8 行，斜率分别是 1/4 到 1/128，共 6 段折线，加上负半段对应的 6 段折线，总共 13 段折线，这就是所谓的 A-law 十三段折线法</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/74797-20180415174356930-1878134610.png"></p>
<p>解码公式：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144809068.png"></p>
<p>相应的μ-law 的计算方法如下表。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/74797-20180415181431844-1395002987.png"></p>
<p>本质上跟 A-law 的区别不大</p>
<h2 id="16bitPCM-转-alaw-代码"><a href="#16bitPCM-转-alaw-代码" class="headerlink" title="16bitPCM 转 alaw 代码"></a>16bitPCM 转 alaw 代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pcm2alaw.c</span></span><br><span class="line"><span class="comment">// https://blog.csdn.net/wzying25/article/details/79398055</span></span><br><span class="line"><span class="comment">// @sun 2020.06.23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGN_BIT (0x80)  <span class="comment">/* Sign bit for a A-law byte. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUANT_MASK (0xf) <span class="comment">/* Quantization field mask.   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSEGS (8)        <span class="comment">/* Number of A-law segments.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_SHIFT (4)    <span class="comment">/* Left shift for segment number. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_MASK (0x70)  <span class="comment">/* Segment field mask. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">short</span> seg_end[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">0xFF</span>,   <span class="number">0x1FF</span>,  <span class="number">0x3FF</span>, <span class="number">0x7FF</span>, <span class="number">0xFFF</span>,</span><br><span class="line">    <span class="number">0x1FFF</span>, <span class="number">0x3FFF</span>, <span class="number">0x7FFF</span>&#125;;  <span class="comment">//分成不均匀的8个分段，算上负数，总共是16个分段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">short</span> *table, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= *table++) <span class="keyword">return</span> (i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * 输入参数范围 ：-32768~32767</span></span><br><span class="line"><span class="comment"> * 返回8位无符号整数</span></span><br><span class="line"><span class="comment"> * linear2alaw() - Convert a 16-bit linear PCM value to 8-bit A-law</span></span><br><span class="line"><span class="comment"> * For further information see John C. Bellamy&#x27;s Digital Telephony, 1982,</span></span><br><span class="line"><span class="comment"> * John Wiley &amp; Sons, pps 98-111 and 472-476.</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">linear2alaw</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> pcm_val)</span> <span class="comment">/* 2&#x27;s complement (16-bit range) */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="keyword">int</span> seg;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> aval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里右移3位，因为采样值是16bit，而A-law是13bit，存储在高13位上，低3位被舍弃</span></span><br><span class="line">    pcm_val = pcm_val &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pcm_val &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mask = <span class="number">0xD5</span>; <span class="comment">/* sign (7th) bit = 1 二进制的11010101*/</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mask = <span class="number">0x55</span>;             <span class="comment">/* sign bit = 0  二进制的01010101*/</span></span><br><span class="line">        pcm_val = -pcm_val - <span class="number">1</span>;  <span class="comment">//负数转换为正数计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Convert the scaled magnitude to segment number. */</span></span><br><span class="line">    seg = search(pcm_val, seg_end, <span class="number">8</span>);  <span class="comment">//返回pcm_val属于哪个分段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Combine the sign, segment, and quantization bits. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg &gt;= <span class="number">8</span>) <span class="comment">/* out of range, return maximum value. */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0x7F</span> ^ mask);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        aval = seg &lt;&lt; SEG_SHIFT;</span><br><span class="line">        <span class="comment">// aval为每一段的偏移，分段量化后的数据需要加上该偏移（aval）</span></span><br><span class="line">        <span class="comment">//分段量化</span></span><br><span class="line">        <span class="comment">//量化方法： (pcm_val-分段值)，然后取有效的高4位   （0分段例外）</span></span><br><span class="line">        <span class="comment">//比如 pcm_val = 0x7000 ，那么seg=7 ，第7段的范围是0x4000~0x7FFF</span></span><br><span class="line">        <span class="comment">//，段偏移aval=7&lt;&lt;4=0x7F 0x7000-0x4000=0x3000</span></span><br><span class="line">        <span class="comment">// ，然后取有效的高4位，即右移10(seg+3)，0x3000&gt;&gt;10=0xC</span></span><br><span class="line">        <span class="comment">//上一步等效为：(0x7000&gt;&gt;10)&amp;0xF=0xC 。也就是： (pcm_val &gt;&gt; (seg + 3)) &amp;</span></span><br><span class="line">        <span class="comment">// QUANT_MASK 然后加上段偏移 0x7F(aval) ，加法等效于或运算，即 |aval</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seg &lt; <span class="number">2</span>)</span><br><span class="line">            aval |= (pcm_val &gt;&gt; <span class="number">4</span>) &amp; QUANT_MASK;  <span class="comment">// 0、1段折线的斜率一样</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            aval |= (pcm_val &gt;&gt; (seg + <span class="number">3</span>)) &amp; QUANT_MASK;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            aval ^</span><br><span class="line">            mask);  <span class="comment">//异或0x55，目的是尽量避免出现连续的0，或连续的1，提高传输过程的可靠性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pcm2alaw.h</span></span><br><span class="line"><span class="comment">// @sun 2020.06.23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">linear2alaw</span><span class="params">(<span class="keyword">int</span> pcm_val)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment"> * @Copyright (C)  2020  all right reserved</span></span><br><span class="line"><span class="comment"> * @file main.c</span></span><br><span class="line"><span class="comment"> * @ingroup wav</span></span><br><span class="line"><span class="comment"> * @author SunZhenliang</span></span><br><span class="line"><span class="comment"> * @date 2020-06</span></span><br><span class="line"><span class="comment"> * @brief pcm2alaw</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pcm2alaw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WAV_HEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ChunkID[<span class="number">4</span>];         <span class="comment">// &quot;RIFF&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkSize;  <span class="comment">// 文件长度(WAVE文件的大小, 不含前8个字节)</span></span><br><span class="line">    <span class="keyword">char</span> Format[<span class="number">4</span>];          <span class="comment">// &quot;WAVE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk1ID[<span class="number">4</span>];             <span class="comment">// &quot;fmt &quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk1Size;      <span class="comment">// 过渡字节(不定)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> AudioFormat;  <span class="comment">// 格式类别(10H为PCM格式的声音数据)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> NumChannels;  <span class="comment">// 通道数(单声道为1, 双声道为2)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SampleRate;         <span class="comment">// 采样率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ByteRate;           <span class="comment">// 波形音频数据传输速率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BlockAlign;   <span class="comment">// data数据块长度、字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BitsPerSample;  <span class="comment">// PCM 位宽</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk2ID[<span class="number">4</span>];         <span class="comment">// &quot;data&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk2Size;  <span class="comment">// data数据的长度</span></span><br><span class="line">&#125; WAV_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALAW_HEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ChunkID[<span class="number">4</span>];         <span class="comment">// &quot;RIFF&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkSize;  <span class="comment">// 文件长度(WAVE文件的大小, 不含前8个字节)</span></span><br><span class="line">    <span class="keyword">char</span> Format[<span class="number">4</span>];          <span class="comment">// &quot;WAVE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk1ID[<span class="number">4</span>];             <span class="comment">// &quot;fmt &quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk1Size;      <span class="comment">// 过渡字节(不定)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> AudioFormat;  <span class="comment">// 格式类别(10H为PCM格式的声音数据)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> NumChannels;  <span class="comment">// 通道数(单声道为1, 双声道为2)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SampleRate;         <span class="comment">// 采样率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ByteRate;           <span class="comment">// 波形音频数据传输速率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BlockAlign;   <span class="comment">// data数据块长度、字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BitsPerSample;  <span class="comment">// PCM 位宽</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk3ID[<span class="number">4</span>];         <span class="comment">// &quot;fact&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk3Size;  <span class="comment">// fact数据的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SampleLength;   <span class="comment">// data数据的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk2ID[<span class="number">4</span>];         <span class="comment">// &quot;data&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk2Size;  <span class="comment">// data数据的长度</span></span><br><span class="line">&#125; ALAW_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE *fpin = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *fout = <span class="literal">NULL</span>;</span><br><span class="line">    WAV_HEADER wav;</span><br><span class="line">    ALAW_HEADER alaw;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> pcm_val;</span><br><span class="line"></span><br><span class="line">    fpin = fopen(<span class="string">&quot;./M1F1-int16-AFsp.wav&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fread(&amp;wav, <span class="keyword">sizeof</span>(struct WAV_HEADER), <span class="number">1</span>, fpin);</span><br><span class="line">    fout = fopen(<span class="string">&quot;./8bitalaw.wav&quot;</span>, <span class="string">&quot;w+b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WAV_HEADER</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ChunkID=%c%c%c%c\n&quot;</span>, wav.ChunkID[<span class="number">0</span>], wav.ChunkID[<span class="number">1</span>], wav.ChunkID[<span class="number">2</span>],</span><br><span class="line">           wav.ChunkID[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ChunkSize=%d\n&quot;</span>, wav.ChunkSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Format=%c%c%c%c\n&quot;</span>, wav.Format[<span class="number">0</span>], wav.Format[<span class="number">1</span>], wav.Format[<span class="number">2</span>],</span><br><span class="line">           wav.Format[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SubChunk1ID=%c%c%c%c\n&quot;</span>, wav.SubChunk1ID[<span class="number">0</span>], wav.SubChunk1ID[<span class="number">1</span>],</span><br><span class="line">           wav.SubChunk1ID[<span class="number">2</span>], wav.SubChunk1ID[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SubChunk1Size=%d\n&quot;</span>, wav.SubChunk1Size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AudioFormat=%d\n&quot;</span>, wav.AudioFormat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NumChannels=%d\n&quot;</span>, wav.NumChannels);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SampleRate=%d\n&quot;</span>, wav.SampleRate);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ByteRate=%d\n&quot;</span>, wav.ByteRate);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BlockAlign=%d\n&quot;</span>, wav.BlockAlign);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BitsPerSample=%d\n&quot;</span>, wav.BitsPerSample);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SubChunk2ID=%c%c%c%c\n&quot;</span>, wav.SubChunk2ID[<span class="number">0</span>], wav.SubChunk2ID[<span class="number">1</span>],</span><br><span class="line">           wav.SubChunk2ID[<span class="number">2</span>], wav.SubChunk2ID[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SubChunk2Size=%d\n&quot;</span>, wav.SubChunk2Size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get alaw header</span></span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.ChunkID, wav.ChunkID);</span><br><span class="line">    alaw.ChunkSize = (wav.ChunkSize - <span class="number">36</span>) / <span class="number">2</span> + <span class="number">48</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.Format, wav.Format);</span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.SubChunk1ID, wav.SubChunk1ID);</span><br><span class="line">    alaw.SubChunk1Size = wav.SubChunk1Size;</span><br><span class="line">    alaw.AudioFormat = wav.AudioFormat;</span><br><span class="line">    alaw.NumChannels = wav.NumChannels;</span><br><span class="line">    alaw.SampleRate = wav.SampleRate;</span><br><span class="line">    alaw.ByteRate = wav.ByteRate;</span><br><span class="line">    alaw.BlockAlign = wav.BlockAlign;</span><br><span class="line">    alaw.BitsPerSample = wav.BitsPerSample;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.SubChunk3ID, <span class="string">&quot;fact&quot;</span>);</span><br><span class="line">    alaw.SubChunk3Size = <span class="number">4</span>;</span><br><span class="line">    alaw.SampleLength = (wav.ChunkSize - <span class="number">36</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.SubChunk2ID, wav.SubChunk2ID);</span><br><span class="line">    alaw.SubChunk2Size = (wav.ChunkSize - <span class="number">36</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write into 8bitalaw.wav</span></span><br><span class="line">    fwrite(&amp;alaw, <span class="keyword">sizeof</span>(ALAW_HEADER), <span class="number">1</span>, fout);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> == fread(&amp;pcm_val, <span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>), <span class="number">1</span>, fpin)) &#123;</span><br><span class="line">        tmp = linear2alaw(pcm_val);  <span class="comment">// 16bit in, 8bit out</span></span><br><span class="line">        fputc(tmp, fout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fpin);</span><br><span class="line">    fclose(fout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>G.71 的原理和计算也比较简单，但是其中用到的一些基本原理同样在其他编码算法中得到了应用，对其进行深入的了解有助于更好的理解其他的算法。</p>
<p>源代码中关于移位运算，掩码运算，还不是完全的理解，只能根据自己的经验进行一些猜测，之后会继续学习，希望对这方面能有更深入的认识。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/A-law_algorithm">Alaw-Wikipedia</a></li>
<li><a href="https://github.com/quatanium/foscam-ios-sdk/blob/master/g726lib/g711.c">g711.c source code</a></li>
<li><a href="https://www.jianshu.com/p/512ce6566f8a">G.711编码原理</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Audio</category>
      </categories>
      <tags>
        <tag>Audio</tag>
        <tag>G.711</tag>
        <tag>alaw</tag>
        <tag>ulaw</tag>
      </tags>
  </entry>
  <entry>
    <title>Git commit message 规范</title>
    <url>/wiki/Git-commit-message-%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="Git-commit-message-规范"><a href="#Git-commit-message-规范" class="headerlink" title="Git commit message 规范"></a>Git commit message 规范</h1><p>最近使用git,翻找以前的记录, 愈发觉得提交 git 记录时, commit message 很重要, 需要有一定规范. </p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>一般遵守 <a href="https://github.com/thoughtbot/dotfiles/blob/master/gitmessage"><strong>thoughtbot 规范</strong></a>，这里是详细说明 <a href="https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message">5 Useful Tips For A Better Commit Message</a></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># 50-character subject line</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 72-character wrapped longer description. This should answer:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># * Why was this change necessary?</span></span><br><span class="line"><span class="meta"># * How does it address the problem?</span></span><br><span class="line"><span class="meta"># * Are there any side effects?</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Include a link to the ticket, if any.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Add co-authors if you worked on this code with others:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Co-authored-by: Full Name &lt;email@example.com&gt;</span></span><br><span class="line"><span class="meta"># Co-authored-by: Full Name &lt;email@example.com&gt;</span></span><br></pre></td></tr></table></figure>

<p>Note:</p>
<p>Never use the <code>-m </code> / <code>--message=</code> flag to <code>git commit</code>.</p>
<p><code>-m</code>的表述内容太少, 不要在正式提交中使用.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message"><strong>5 Useful Tips For A Better Commit Message</strong></a></li>
<li><a href="https://github.com/thoughtbot/dotfiles/blob/master/gitmessage"><strong>thoughtbot 规范</strong></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Latency Numbers Every Programmer Should Know</title>
    <url>/wiki/LatencyNumbersEveryProgrammerShouldKnow/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Latency Comparison Numbers (~2012)</span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line">L1 <span class="keyword">cache</span> <span class="keyword">reference</span>                           <span class="number">0.5</span> ns</span><br><span class="line">Branch mispredict                            <span class="number">5</span>   ns</span><br><span class="line">L2 <span class="keyword">cache</span> <span class="keyword">reference</span>                           <span class="number">7</span>   ns                      <span class="number">14</span>x L1 <span class="keyword">cache</span></span><br><span class="line"><span class="keyword">Mutex</span> <span class="keyword">lock</span>/<span class="keyword">unlock</span>                           <span class="number">25</span>   ns</span><br><span class="line"><span class="keyword">Main</span> <span class="keyword">memory</span> <span class="keyword">reference</span>                      <span class="number">100</span>   ns                      <span class="number">20</span>x L2 <span class="keyword">cache</span>, <span class="number">200</span>x L1 <span class="keyword">cache</span></span><br><span class="line"><span class="keyword">Compress</span> <span class="number">1</span>K <span class="keyword">bytes</span> <span class="keyword">with</span> Zippy             <span class="number">3</span>,<span class="number">000</span>   ns        <span class="number">3</span> us</span><br><span class="line">Send <span class="number">1</span>K <span class="keyword">bytes</span> <span class="keyword">over</span> <span class="number">1</span> Gbps network       <span class="number">10</span>,<span class="number">000</span>   ns       <span class="number">10</span> us</span><br><span class="line"><span class="keyword">Read</span> <span class="number">4</span>K randomly <span class="keyword">from</span> SSD*             <span class="number">150</span>,<span class="number">000</span>   ns      <span class="number">150</span> us          ~<span class="number">1</span>GB/sec SSD</span><br><span class="line"><span class="keyword">Read</span> <span class="number">1</span> MB sequentially <span class="keyword">from</span> <span class="keyword">memory</span>     <span class="number">250</span>,<span class="number">000</span>   ns      <span class="number">250</span> us</span><br><span class="line"><span class="keyword">Round</span> trip <span class="keyword">within</span> same datacenter      <span class="number">500</span>,<span class="number">000</span>   ns      <span class="number">500</span> us</span><br><span class="line"><span class="keyword">Read</span> <span class="number">1</span> MB sequentially <span class="keyword">from</span> SSD*     <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span>   ns    <span class="number">1</span>,<span class="number">000</span> us    <span class="number">1</span> ms  ~<span class="number">1</span>GB/sec SSD, <span class="number">4</span>X <span class="keyword">memory</span></span><br><span class="line">Disk seek                           <span class="number">10</span>,<span class="number">000</span>,<span class="number">000</span>   ns   <span class="number">10</span>,<span class="number">000</span> us   <span class="number">10</span> ms  <span class="number">20</span>x datacenter roundtrip</span><br><span class="line"><span class="keyword">Read</span> <span class="number">1</span> MB sequentially <span class="keyword">from</span> disk    <span class="number">20</span>,<span class="number">000</span>,<span class="number">000</span>   ns   <span class="number">20</span>,<span class="number">000</span> us   <span class="number">20</span> ms  <span class="number">80</span>x <span class="keyword">memory</span>, <span class="number">20</span>X SSD</span><br><span class="line">Send packet CA-&gt;Netherlands-&gt;CA    <span class="number">150</span>,<span class="number">000</span>,<span class="number">000</span>   ns  <span class="number">150</span>,<span class="number">000</span> us  <span class="number">150</span> ms</span><br><span class="line"></span><br><span class="line">Notes</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="number">1</span> ns = <span class="number">10</span>^<span class="number">-9</span> <span class="keyword">seconds</span></span><br><span class="line"><span class="number">1</span> us = <span class="number">10</span>^<span class="number">-6</span> <span class="keyword">seconds</span> = <span class="number">1</span>,<span class="number">000</span> ns</span><br><span class="line"><span class="number">1</span> ms = <span class="number">10</span>^<span class="number">-3</span> <span class="keyword">seconds</span> = <span class="number">1</span>,<span class="number">000</span> us = <span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> ns</span><br><span class="line"></span><br><span class="line">Credit</span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="keyword">By</span> Jeff Dean:               <span class="keyword">http</span>://research.google.com/people/jeff/</span><br><span class="line">Originally <span class="keyword">by</span> Peter Norvig: <span class="keyword">http</span>://norvig.com/<span class="number">21</span>-days.html<span class="comment">#answers</span></span><br><span class="line"></span><br><span class="line">Contributions</span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"><span class="string">&#x27;Humanized&#x27;</span> comparison:  https://gist.github.com/hellerbarde/<span class="number">2843375</span></span><br><span class="line">Visual comparison chart: <span class="keyword">http</span>://i.imgur.com/k0t1e.png</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://gist.github.com/jboner/2841832">Latency Numbers Every Programmer Should Know</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>OS</category>
        <category>design</category>
        <category>time</category>
      </categories>
      <tags>
        <tag>Latency</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1248. 统计「优美子数组」</title>
    <url>/wiki/LeetCode-1248.%20%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D/</url>
    <content><![CDATA[<h1 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a>1248. 统计「优美子数组」</h1><p>给你一个整数数组 nums 和一个整数 k。</p>
<p>如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</p>
<p>请返回这个数组中「优美子数组」的数目。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = <span class="comment">[1,1,2,1,1]</span>, k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 <span class="comment">[1,1,2,1]</span> 和 <span class="comment">[1,2,1,1]</span> 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = <span class="comment">[2,4,6]</span>, k = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = <span class="comment">[2,2,2,1,2,2,1,2,2,2]</span>, k = 2</span><br><span class="line">输出：16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 50000</span><br><span class="line">1 &lt;= nums<span class="comment">[i]</span> &lt;= 10^5</span><br><span class="line">1 &lt;= k &lt;= nums.length</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="自想"><a href="#自想" class="headerlink" title="自想"></a>自想</h3><p>多指针一次遍历，计算前后偶数乘积之和</p>
<h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p><img src="https://gitee.com/SunGitee/src/raw/master/img/20200421102035.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">int</span> odd[n + <span class="number">2</span>], ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &amp; <span class="number">1</span>) odd[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        odd[<span class="number">0</span>] = <span class="number">-1</span>, odd[++cnt] = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + k &lt;= cnt; ++i) &#123;</span><br><span class="line">            ans += (odd[i] - odd[i - <span class="number">1</span>]) * (odd[i + k] - odd[i + k - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/tong-ji-you-mei-zi-shu-zu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-136. 只出现一次的数字</title>
    <url>/wiki/LeetCode-136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<a id="more"></a>

<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line"><span class="section">输入: [2,2,1]</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line"><span class="section">输入: [4,1,2,1,2]</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 异或 ⊕ 的特性</span></span><br><span class="line">        <span class="comment">// 0 异或 x  = x</span></span><br><span class="line">        <span class="comment">// x 异或 b = b</span></span><br><span class="line">        <span class="comment">// b 异或 b = 0</span></span><br><span class="line">        <span class="comment">//满足交换律结合律</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> it:nums)&#123;</span><br><span class="line">            ans^=it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>hash</tag>
        <tag>异或运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-20.Valid-Parentheses</title>
    <url>/wiki/LeetCode-20.Valid%20Parentheses/</url>
    <content><![CDATA[<h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20.Valid-Parentheses"></a>20.Valid-Parentheses</h1><p>Given a string containing just the characters <code>(</code>, <code>)</code>, <code>&#123;</code>, <code>&#125;</code>, <code>[</code> and <code>]</code>, determine if the input string is valid.</p>
<a id="more"></a>

<p>An input string is valid if:</p>
<p>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Example 1:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Input:</span> <span class="string">&quot;()&quot;</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">Example 2:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Input:</span> <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">Example 3:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Input:</span> <span class="string">&quot;(]&quot;</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Example 4:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Input:</span> <span class="string">&quot;([)]&quot;</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Example 5:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Input:</span> <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeft</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length() % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isLeft(s[<span class="number">0</span>])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stackS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeft(it)) &#123;</span><br><span class="line">                stackS.push(it);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> temp = stackS.top();</span><br><span class="line">            <span class="keyword">if</span> (it == temp + <span class="number">2</span> || it == temp + <span class="number">1</span>) &#123;<span class="comment">//ascii码</span></span><br><span class="line">                stackS.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackS.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-242.Valid-Anagram</title>
    <url>/wiki/LeetCode-242.Valid%20Anagram/</url>
    <content><![CDATA[<h1 id="LeetCode-242-Valid-Anagram"><a href="#LeetCode-242-Valid-Anagram" class="headerlink" title="LeetCode-242.Valid-Anagram"></a>LeetCode-242.Valid-Anagram</h1><p>Given two strings <code>s</code> and <code>t</code> , write a function to determine if <code>t</code> is an anagram of <code>s</code>.</p>
<!---more-->

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"><span class="attr">Input:</span> s = <span class="string">&quot;anagram&quot;</span>, t = <span class="string">&quot;nagaram&quot;</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">true</span></span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line"><span class="attr">Input:</span> s = <span class="string">&quot;rat&quot;</span>, t = <span class="string">&quot;car&quot;</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>长度不同 返回<code>false</code><br>一遍扫描 Hash 计数，s 出现字母 ++，t 出现字母 –，最后判断是否全为 0 即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            hash[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            hash[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:hash) &#123;</span><br><span class="line">            <span class="keyword">if</span>(it!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-365. 水壶问题</title>
    <url>/wiki/LeetCode-365.%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="水壶问题"><a href="#水壶问题" class="headerlink" title="水壶问题"></a>水壶问题</h1><p>有两个容量分别为 x 升 和 y 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z 升 的水？</p>
<a id="more"></a>

<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z 升 水。</p>
<p>你允许：</p>
<p>装满任意一个水壶</p>
<p>清空任意一个水壶</p>
<p>从一个水壶向另外一个水壶倒水，直到装满或者倒空</p>
<p>示例 1: (From the famous “<a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg">Die Hard</a>“ example)</p>
<p>输入：<code>x = 3, y = 5, z = 4</code></p>
<p>输出：<code>True</code></p>
<p>示例 2:</p>
<p>输入：<code>x = 2, y = 6, z = 5</code></p>
<p>输出：<code>False</code></p>
<h2 id="方法一：BFS"><a href="#方法一：BFS" class="headerlink" title="方法一：BFS"></a>方法一：BFS</h2><p>引用自评论区<a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/tu-jie-bfs-c-jie-zhu-unordered_set-queue-shi-xian-/">@前额叶没长好 的题解</a></p>
<blockquote>
<p>很多人都是一眼看出是图的搜索问题，BFS\DFS 都可以，我却一开始就陷入寻找数学规律，自己还没找到。233~</p>
</blockquote>
<p>比较经典的图的广度优先搜索问题。</p>
<p>为简单起见，以 x = 1, y = 3, z = 2 为例，来看下如何构思：</p>
<p>（学习下怎么抽象问题建模的！)</p>
<p>当 x = 1, y = 3 时，一共有八种状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span>,<span class="number">0</span>), (<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">0</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">0</span>,<span class="number">3</span>), (<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>既然时图的广度优先搜索，我们先来看下如何构图：<br><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20200321125343690.png" alt="image-20200321125343690"></p>
<p>关于图片的说明：</p>
<ul>
<li>节点表示两个水壶的状态</li>
<li>边表示操作方法：分别为倒满 A/B，倒空 A/B，A 倒入 B，B 倒入 A 六种方法。</li>
<li>这是一个有向图，因为有些状态并不能护互为转移。比如 (1,1) 和 (1,0)。</li>
</ul>
<p>简单介绍下 BFS： 该过程总是从一个或若干个起始点开始，沿着边像水波一样<strong>逐层</strong>向外遍历，直到<strong>所有的点已被访问</strong>或者<strong>到达目标状态</strong>。<br><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20200321125405770.png" alt="image-20200321125405770"></p>
<p>编程上可以使用一个队列维护需要<strong>扩散</strong>的点，以及一个 set 或者数组维护已经被访问过的点来实现：</p>
<ol>
<li>初始时，队列和 set 均为空。将起始点放入队列及 set。</li>
<li>如果队列为空则 bfs 结束。</li>
<li>弹出队首元素并访问其周围元素，设为 p。</li>
<li>如果 p 为目标状态则 bfs 结束。</li>
<li>访问 p 周围的元素，将不在 set 中的元素放入队列及 set。跳转第 2 步。</li>
</ol>
<h3 id="关于-std-unordered-set-："><a href="#关于-std-unordered-set-：" class="headerlink" title="关于 std::unordered_set ："></a>关于 std::unordered_set ：</h3><h3 id="std-unordered-set-与-std-set-的区别："><a href="#std-unordered-set-与-std-set-的区别：" class="headerlink" title="std::unordered_set 与 std::set 的区别："></a>std::unordered_set 与 std::set 的区别：</h3><ul>
<li>实现方面<ul>
<li>std::unordered_set 是基于 hash 实现的。</li>
<li>std::set 是基于红黑树实现的。</li>
</ul>
</li>
<li>遍历是否有序：<ul>
<li>std::unordered_set 从名字可知不支持有序遍历。</li>
<li>std::set 可以有序遍历。</li>
</ul>
</li>
<li>效率比较：<ul>
<li>空间方面两者都是 o(n)。</li>
<li>时间方面，增删改查操作，set 都是 o(log_2^n)<em>o</em>(<em>l<strong>o</strong>g</em>2<em>n</em>)，unordered_set 都是 o(1)。</li>
</ul>
</li>
</ul>
<h3 id="unordered-set-的用法："><a href="#unordered-set-的用法：" class="headerlink" title="unordered_set 的用法："></a>unordered_set 的用法：</h3><p>因为 unordered_set 是基于 hash 实现的，所以提供了用户自定义 hash 函数的功能。<br>目前 unordered_set 默认的 hash 函数仅支持 build-in 类型及 string 等少数类型。其他类型或用户自定义类型，需要自己编写 hash 函数，如下面代码中的 <code>struct HashPair</code>。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    pair&lt;int, int&gt; op(int type, const pair&lt;int, int&gt; &amp;state, int x, int y) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : <span class="keyword">return</span> <span class="built_in">make_pair</span>(x, state.second);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : <span class="keyword">return</span> <span class="built_in">make_pair</span>(state.first, y);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">0</span>, state.second);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : <span class="keyword">return</span> <span class="built_in">make_pair</span>(state.first, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> :&#123;</span><br><span class="line">                <span class="keyword">int</span> move = min(state.first, y-state.second);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">make_pair</span>(state.first - move, state.second + move);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span> : &#123;</span><br><span class="line">                <span class="keyword">int</span> move = min(x-state.first, state.second);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">make_pair</span>(state.first + move, state.second - move);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashPair</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;key)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">	    </span>&#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="keyword">size_t</span>(key.first)*<span class="number">100000007</span> + key.second;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, HashPair&gt; mark;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(q.empty() == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(f.first + f.second == z) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> next = op(i, f, x, y);</span><br><span class="line">                <span class="keyword">if</span>(mark.find(next) != mark.end()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mark.insert(next);</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：数学"><a href="#方法二：数学" class="headerlink" title="方法二：数学"></a>方法二：数学</h2><p>引用自官方<a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/">题解</a></p>
<p><strong>思路及算法</strong></p>
<p>预备知识：<a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&fromid=5185441">贝祖定理</a></p>
<p>我们认为，每次操作只会让桶里的水总量增加 <code>x</code>，增加 <code>y</code>，减少 <code>x</code>，或者减少 <code>y</code>。</p>
<p>你可能认为这有问题：如果往一个不满的桶里放水，或者把它排空呢？那变化量不就不是 <code>x</code> 或者 <code>y</code> 了吗？接下来我们来解释这一点：</p>
<ul>
<li>首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。因为观察所有题目中的操作，操作的结果都至少有一个桶是空的或者满的；</li>
<li>其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；</li>
<li>再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。</li>
</ul>
<p>因此，我们可以认为每次操作只会给水的总量带来 <code>x</code> 或者 <code>y</code> 的变化量。因此我们的目标可以改写成：找到一对整数 <em>a</em>,<em>b</em>，使得<br>$$<br>ax+by=z<br>$$<br>而只要满足 $z≤x+y$，且这样的 <em>a</em>, ,<em>b</em> 存在，那么我们的目标就是可以达成的。这是因为：</p>
<ul>
<li><p>若 $a≥0,b≥0$, 那么显然可以达成目标。</p>
</li>
<li><p>若 $a&lt;0$，那么可以进行以下操作：</p>
<ol>
<li>往 <code>y</code> 壶倒水；</li>
<li>把 <code>y</code> 壶的水倒入 <code>x</code> 壶；</li>
<li>如果 <code>y</code> 壶不为空，那么 <code>x</code> 壶肯定是满的，把 <code>x</code> 壶倒空，然后再把 <code>y</code> 壶的水倒入 <code>x</code> 壶。</li>
</ol>
<p>重复以上操作直至某一步时 <code>x</code> 壶进行了 a<em>a</em> 次倒空操作，<code>y</code> 壶进行了 b<em>b</em> 次倒水操作。</p>
</li>
<li><p>若 $b&lt;0$，方法同上，<code>x</code> 与 <code>y</code> 互换。</p>
</li>
</ul>
<p>而贝祖定理告诉我们，$ax+by=z$ 有解当且仅当 $z$ 是 <em>x</em>, <em>y</em> 的最大公约数的倍数。因此我们只需要找到 x,<em>y</em> 的最大公约数并判断 <em>z</em> 是否是它的倍数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x + y &lt; z) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span> z == <span class="number">0</span> || x + y == z;</span><br><span class="line">        <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log(\min(x, y)))$，取决于计算最大公约数所使用的辗转相除法。</li>
<li>空间复杂度：$O(1)$，只需要常数个变量。</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数学</tag>
        <tag>水壶</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-409. 最长回文串</title>
    <url>/wiki/LeetCode-409.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="LeetCode-409-最长回文串"><a href="#LeetCode-409-最长回文串" class="headerlink" title="LeetCode-409. 最长回文串"></a>LeetCode-409. 最长回文串</h1><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串</p>
<a id="more"></a>

<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意：<br>假设字符串的长度不会超过 1010。</p>
<p>示例 1:</p>
<p>输入：<br><code>&quot;abccccdd&quot;</code></p>
<p>输出：<br><code>7</code></p>
<p>解释：<br>我们可以构造的最长的回文串是<code>&quot;dccaccd&quot;</code>, 它的长度是 <code>7</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Hash统计出现次数，偶数直接相加，奇数加其中最大偶数部分即 奇数-1。如果加了奇数，最后总和再补中间位一位。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++) a[s[i]-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">int</span> book=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                sum+=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum+=a[i]<span class="number">-1</span>;</span><br><span class="line">                book=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(book) &#123;sum+=flag;&#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时 :4 ms, 在所有 C++ 提交中击败了86.91%的用户</span></span><br><span class="line"><span class="comment">内存消耗 :8.3 MB, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//评论区题解</span></span><br><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindrome/comments/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">         cnt[c - <span class="string">&#x27;A&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x: cnt) &#123;</span><br><span class="line">        <span class="comment">// 字符出现的次数最多用偶数次。</span></span><br><span class="line">        ans += x - (x &amp; <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果最终的长度小于原字符串的长度，说明里面某个字符出现了奇数次，那么那个字符可以放在回文串的中间，所以额外再加一。</span></span><br><span class="line">      <span class="keyword">return</span> ans &lt; s.length() ? ans + <span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ans += x - (x &amp; 1);</code>妙呀！<br>注：<code>s.toCharArray()</code>类似 c++ 中<code>std::string::c_str()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s) -<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">sum</span>([s.count(i)%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s)])-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># tql!!!</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-46.Permutation</title>
    <url>/wiki/LeetCode-46.Permutation/</url>
    <content><![CDATA[<h1 id="46-Permutation"><a href="#46-Permutation" class="headerlink" title="46.Permutation"></a>46.Permutation</h1><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
<a id="more"></a>

<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">Input: <span class="comment">[1,2,3]</span></span><br><span class="line">Output:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,3,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,1,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,3,1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[3,1,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[3,2,1]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>

<h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p><strong>STL</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (next_permutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//next_permutation直接对全数组操作，返回字典序。使用前接的先sort</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/SunGitee/src/raw/master/img/20200425110812.png"></p>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p><strong>回溯算法</strong></p>
<p>//每次遇到递归就不是很理解，可恶</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, nums.size() - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            result.emplace_back(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;<span class="comment">//又一种遍历写法</span></span><br><span class="line">            swap(nums[i], nums[begin]);</span><br><span class="line">            dfs(begin + <span class="number">1</span>, end, nums);</span><br><span class="line">            swap(nums[i], nums[begin]);<span class="comment">//撤回操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：klaxxi</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/permutations/solution/c-chao-jian-ji-by-klaxxi/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/SunGitee/src/raw/master/img/20200425113510.png"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>全排列</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-5059- 单行键盘</title>
    <url>/wiki/LeetCode-5059-%E5%8D%95%E8%A1%8C%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<h3 id="5059-单行键盘"><a href="#5059-单行键盘" class="headerlink" title="5059. 单行键盘"></a>5059. 单行键盘</h3><p>我们定制了一款特殊的力扣键盘，所有的键都排列在一行上。</p>
<p>我们可以按从左到右的顺序，用一个长度为 26 的字符串 keyboard （索引从 0 开始，到 25 结束）来表示该键盘的键位布局。</p>
<p>现在需要测试这个键盘是否能够有效工作，那么我们就需要个机械手来测试这个键盘。</p>
<p>最初的时候，机械手位于左边起第一个键（也就是索引为 0 的键）的上方。当机械手移动到某一字符所在的键位时，就会在终端上输出该字符。</p>
<p>机械手从索引 i 移动到索引 j 所需要的时间是 |i - j|。</p>
<p>当前测试需要你使用机械手输出指定的单词 word，请你编写一个函数来计算机械手输出该单词所需的时间。</p>
<a id="more"></a>

<p><strong>示例 1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：keyboard = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, word = <span class="string">&quot;cba&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">机械手从 <span class="number">0</span> 号键移动到 <span class="number">2</span> 号键来输出 <span class="string">&#x27;c&#x27;</span>，又移动到 <span class="number">1</span> 号键来输出 <span class="string">&#x27;b&#x27;</span>，接着移动到 <span class="number">0</span> 号键来输出 <span class="string">&#x27;a&#x27;</span>。</span><br><span class="line">总用时 = <span class="number">2</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">4.</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：keyboard = <span class="string">&quot;pqrstuvwxyzabcdefghijklmno&quot;</span>, word = <span class="string">&quot;leetcode&quot;</span></span><br><span class="line">输出：<span class="number">73</span></span><br></pre></td></tr></table></figure>

<p><strong>提示 ：</strong></p>
<ul>
<li><code>keyboard.length == 26</code></li>
<li><code>keyboard</code> 按某种特定顺序排列，并包含每个小写英文字母一次。</li>
<li><code>1 &lt;= word.length &lt;= 10^4</code></li>
<li><code>word[i]</code> 是一个小写英文字母</li>
</ul>
<p><strong>代码 ：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateTime</span><span class="params">(<span class="built_in">string</span> keyboard, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; keyboard.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word[i] == keyboard[j]) &#123;</span><br><span class="line">                    p2 = j;</span><br><span class="line">                    s += <span class="built_in">abs</span>(p2 - p1);</span><br><span class="line">                    p1 = p2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>签到题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-542.01Matrix</title>
    <url>/wiki/LeetCode-542.01Matrix/</url>
    <content><![CDATA[<h1 id="542-01-Matrix"><a href="#542-01-Matrix" class="headerlink" title="542. 01 Matrix"></a>542. 01 Matrix</h1><p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.</p>
<p>The distance between two adjacent cells is 1.</p>
<a id="more"></a>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"><span class="string">[[0,0,0],</span></span><br><span class="line"><span class="string"> [0,1,0],</span></span><br><span class="line"><span class="string"> [0,0,0]]</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="string">[[0,0,0],</span></span><br><span class="line"><span class="string"> [0,1,0],</span></span><br><span class="line"><span class="string"> [0,0,0]]</span></span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"><span class="string">[[0,0,0],</span></span><br><span class="line"><span class="string"> [0,1,0],</span></span><br><span class="line"><span class="string"> [1,1,1]]</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="string">[[0,0,0],</span></span><br><span class="line"><span class="string"> [0,1,0],</span></span><br><span class="line"><span class="string"> [1,2,1]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>遍历数组中 0 周围的 1，标记为 2 //1 已被使用</li>
<li>遍历数组中 2 周围的 1，标记为 3</li>
<li>以此类推直到没有 1 位置</li>
<li>数组中 A<code>[i][j]&gt;0</code>，则 <code>--</code></li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vex[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfsTraversal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count_1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        ++count_1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j] == curr) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">int</span> m = i + vex[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">int</span> n = j + vex[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (m &gt;= <span class="number">0</span> &amp;&amp; m &lt; M &amp;&amp; n &gt;= <span class="number">0</span> &amp;&amp; n &lt; N &amp;&amp;</span><br><span class="line">                                matrix[m][n] ==  <span class="number">1</span>) &#123;</span><br><span class="line">                                matrix[m][n] = mark;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count_1 == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            curr = mark;</span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        bfsTraversal(matrix);</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-55. 跳跃游戏</title>
    <url>/wiki/LeetCode-55.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<a id="more"></a>

<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line"><span class="section">输入: [2,3,1,1,4]</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line"><span class="section">输入: [3,2,1,0,4]</span></span><br><span class="line"><span class="section">输出: false</span></span><br><span class="line"><span class="section">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>倒序判断每个位置是否能跳过 0 处位置</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span> &amp;&amp; mark == <span class="number">-1</span>) mark = i;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt; mark) mark = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mark == <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-98. 验证二叉搜索树</title>
    <url>/wiki/LeetCode-98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br>示例 1:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / <span class="string">\</span></span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：输入为：[<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">6</span>]。</span><br><span class="line">     根节点的值为 <span class="number">5</span> ，但是其右子节点值为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序递归，只要上一个的val值大于即将判断的（下一个）的值，那么就return false，很精妙！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* last = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValidBST(root-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (last &amp;&amp; *last&gt;=root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            last = &amp;root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(!isValidBST(root-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//https://leetcode-cn.com/problems/validate-binary-search-tree/comments/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>二叉树</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode- 按摩师 - 动态规划</title>
    <url>/wiki/LeetCode-%E6%8C%89%E6%91%A9%E5%B8%88-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="按摩师-动态规划"><a href="#按摩师-动态规划" class="headerlink" title="按摩师 - 动态规划"></a>按摩师 - 动态规划</h3><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<a id="more"></a>

<p>注意：本题相对原题稍作改动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入： [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出： <span class="number">4</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约和 <span class="number">3</span> 号预约，总时长 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入： [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出： <span class="number">12</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约、 <span class="number">3</span> 号预约和 <span class="number">5</span> 号预约，总时长 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span>。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入： [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出： <span class="number">12</span></span><br><span class="line">解释： 选择 <span class="number">1</span> 号预约、 <span class="number">3</span> 号预约、 <span class="number">5</span> 号预约和 <span class="number">8</span> 号预约，总时长 = <span class="number">2</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">3</span> = <span class="number">12</span>。</span><br><span class="line"><span class="comment">//来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">//链接：https://leetcode-cn.com/problems/the-masseuse-lcci</span></span><br></pre></td></tr></table></figure>

<h3 id="思路题解"><a href="#思路题解" class="headerlink" title="思路题解"></a>思路题解</h3><p>引用自评论区@<a href="https://leetcode-cn.com/u/liweiwei1419/">liweiwei1419</a>的<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/">题解</a></p>
<p>这道题其实就是经典的「力扣」第 198 题：打家劫舍。题目只问最优值，并没有问最优解，因此绝大多数情况下可以考虑使用「动态规划」的方法。</p>
<p>方法一：设计二维状态变量<br>第 1 步：设计状态<br>「状态」这个词可以理解为「记录了求解问题到了哪一个阶段」。</p>
<p>由于当前这一天有按摩师有两种选择：（1）接预约；（2）不接预约。但根据题意，今天是否接预约，是受到昨天影响的。为了消除这种影响，我们在状态数组要设置这个维度。</p>
<p><code>dp[i][0]</code> 表示：区间 <code>[0，i]</code> 里接受预约请求，并且下标为<code>i</code>的这一天不接受预约的最大时长；<br><code>dp[i][1] </code>表示：区间 <code>[0，i] </code>里接受预约请求，并且下标为 <code>i </code>的这一天接受预约的最大时长。</p>
<p>说明：这个定义是有前缀性质的，即当前的状态值考虑了（或者说综合了）之前的相关的状态值，第 2 维保存了当前最优值的决策，这种通过增加维度，消除后效性的操作在「动态规划」问题里是非常常见的。</p>
<p>无后效性的理解：1、后面的决策不会影响到前面的决策； 2、之前的状态怎么来的并不重要。</p>
<p>一般的情况是，只要有约束，就可以增加一个维度消除这种约束带来的影响，再具体一点说，就是把「状态」定义得清楚、准确，「状态转移方程」就容易得到了。「力扣」的几道股票问题基本都是这个思路，而且设置状态的思想和这道题是完全一致的。</p>
<p>第 2 步：状态转移方程<br>「状态转移方程」可以理解为「不同阶段之间的联系」。</p>
<p>今天只和昨天的状态相关，依然是分类讨论：</p>
<p>今天不接受预约：或者是昨天不接受预约，或者是昨天接受了预约，取二者最大值，即：<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])；</code><br>今天接受预约：只需要从昨天不接受预约转移而来，加上今天的时常，即：<code>dp[i][1] = dp[i - 1][0] + nums[i]</code>。<br>第 3 步：考虑初始化<br>从第 2 天开始，每天的状态值只与前一天有关，因此第 1 天就只好老老实实算了。好在不难判断：<code>dp[0][0] = 0 与 dp[0][1] = nums[0]；</code></p>
<p>这里有一种技巧，可以把状态数组多设置一行，这样可以减少对第 1 天的初始化，这样的代码把第 1 天的情况考虑了进去，但编码的时候要注意状态数组下标的设置， 请见题解最后的「参考代码 3」。</p>
<p>第 4 步：考虑输出<br>由于状态值的定义是前缀性质的，因此最后一天的状态值就考虑了之前所有的天数的情况。按摩师最后一天可以接受预约，也可以不接受预约，取二者最大值。</p>
<p>第 5 步：考虑是否可以状态压缩<br>由于今天只参考昨天的值，状态可以压缩，可以使用「滚动数组」完成，状态压缩的代码丢失了一定可读性，也会给编码增加一点点难度，请见题解后的「参考代码 4」。</p>
<p>参考代码 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][0]：区间 [0, i] 里接受预约请求，并且下标为 i 的这一天不接受预约的最大时长</span></span><br><span class="line">        <span class="comment">// dp[i][1]：区间 [0, i] 里接受预约请求，并且下标为 i 的这一天接受预约的最大时长</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[len - <span class="number">1</span>][<span class="number">0</span>], dp[len - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="comment">// int[] nums = &#123;1, 2, 3, 1&#125;;</span></span><br><span class="line">        <span class="comment">// int[] nums = &#123;2, 7, 9, 3, 1&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = solution.massage(nums);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<p>时间复杂度：<code>O(N)</code>，<code>N </code>是数组的长度；<br>空间复杂度：<code>O(N)</code>，状态数组的大小为 <code>2N</code>，可以优化到常数级别，请见题解后的「参考代码 4」。<br>以上是中规中矩的写法。在这里根据问题本身的特点，状态可以不用设置那么具体，就将题目问的设计成状态，状态转移方程依然好写。</p>
<p>方法二：设计一维状态变量<br>第 1 步：定义状态<br><code>dp[i]</code>：区间 <code>[0，i] </code>里接受预约请求的最大时长。</p>
<p>第 2 步：状态转移方程<br>这个时候因为不限定下标为 i 这一天是否接受预约，因此需要分类讨论：</p>
<p>接受预约，那么昨天就一定休息，由于状态<code>dp[i - 1]</code>的定义涵盖了下标为<code>i - 1</code>这一天接收预约的情况，状态只能从下标为 <code>i - 2 </code>的状态转移而来：<code>dp[i - 2] + nums[i]；</code><br>不接受预约，那么昨天可以休息，也可以不休息，状态从下标为 <code>i - 1 </code>的状态转移而来：<code>dp[i - 1]；</code><br>二者取最大值，因此状态转移方程为 <code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code>。</p>
<p>第 3 步：思考初始化<br>看状态转移方程，下标最小到 <code>i - 2</code>，因此初始化的时候要把 <code>dp[0] </code>和<code> dp[1]</code> 算出来，从 <code>dp[2]</code> 开始计算。</p>
<p><code>dp[0]</code>：只有 1 天的时候，必须接受预约，因此 <code>dp[0] = nums[0]；</code><br><code>dp[1]</code>：头 2 天的时候，由于不能同时接受预约，因此最优值是这两天接受预约时长的最大值 <code>dp[1] = max(nums[0], nums[1])；</code><br>第 4 步：思考输出<br>由于定义的状态有前缀性质，并且对于下标为 i 的这一天也考虑了接受预约与不接受预约的情况，因此输出就是最后一天的状态值。</p>
<p>第 5 步：思考状态压缩<br>看状态转移方程。当前状态只与前两个状态相关，我们只关心最后一天的状态值，因此依然可以使用「滚动变量」的技巧，这个时候滚动起来的就是 3 个变量了。这样的代码依然是丢失了可读性，也存在一定编码错误的风险，请见题解后的「参考代码 5」。</p>
<p>参考代码 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]：区间 [0, i] 里接受预约请求的最大时长</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 今天在选与不选中，选择一个最优的</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="comment">// int[] nums = &#123;1, 2, 3, 1&#125;;</span></span><br><span class="line">        <span class="comment">// int[] nums = &#123;2, 7, 9, 3, 1&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = solution.massage(nums);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<p>时间复杂度：<code>O(N)</code>，<code>N</code> 是数组的长度；<br>空间复杂度：<code>O(N)</code>，状态数组的大小为 <code>N</code>，可以优化到 33，请见题解后的「参考代码 5」。<br>我们看到解决这个问题的复杂程度与如何定义状态是相关的，定义状态的角度没有固定的模式，但有一个方向是可以考虑的，那就是从「状态转移方程」容易得到的角度去考虑如何设计状态。</p>
<p>「状态」和「状态转移方程」得到以后，这个问题其实就得到了解决，剩下的一些细节的问题在编码的时候只要稍微留意一点就行了。</p>
<p>总结<br>「动态规划」其实不是什么特别难懂的东西（只是说思想），只是这一类问题刚接触的时候有点不太适应，并且这类问题容易被包装得很过分，而且没有明显的套路，题型多样，所以学习「动态规划」会有一些些吃力，这没有办法，见多了就好。如果是准备面试，不需要掌握特别复杂的「动态规划」问题（当然前提是你没有在简历上说你是算法竞赛高手）。</p>
<p>「动态规划」告诉了我们另一种求解问题的思路。我们学习编程，习惯了自顶向下求解问题（递归），在自顶向下求解问题的过程中，发现了重复子问题，我们再加上缓存。而「动态规划」告诉我们，其实有一类问题我们可以从一个最简单的情况开始考虑，通过逐步递推，每一步都记住当前问题的答案，得到最终问题的答案，即「动态规划」告诉了我们「自底向上」思考问题的思路。</p>
<p>也就是说「动态规划」告诉我们的新的思路是：不是直接针对问题求解，由于我们找到了这个问题最开始的样子，因此后面在求解的过程中，每一步都可以参考之前的结果（在处理最优化问题的时候，叫「最优子结构」），由于之前的结果有重复计算（「重复子问题」），因此必须记录下来。</p>
<p>这种感觉不同于「记忆化递归」，「记忆化递归」是直接面对问题求解，遇到一个问题解决了以后，就记下来，随时可能面对新问题。而「动态规划」由于我们发现了这个问题「最初」的样子，因此每一步参考的以前的结果都是知道的，就像我们去考试，所有的考题我们都见过，并且已经计算出了答案一样，我们只需要参考以前做题的答案，就能得到这一题的答案，这是「状态转移」。应用「最优子结构」是同一回事，即：综合以前计算的结果，直接得到当前的最优值。</p>
<p>「动态规划」的内涵和外延很丰富，不是几句话和几个问题能够理解清楚的，需要我们做一些经典的问题去慢慢理解它，和掌握「动态规划」问题思考的方向。</p>
<p>参考代码 3：根据方法一：状态数组多设置一行，以避免对极端用例进行讨论。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp 数组多设置一行，相应地定义就要改变，遍历的一些细节也要相应改变</span></span><br><span class="line">    <span class="comment">// dp[i][0]：区间 [0, i) 里接受预约请求，并且下标为 i 的这一天不接受预约的最大时长</span></span><br><span class="line">    <span class="comment">// dp[i][1]：区间 [0, i) 里接受预约请求，并且下标为 i 的这一天接受预约的最大时长</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：外层循环从 1 到 =len，相对 dp 数组而言，引用到 nums 数组的时候就要 -1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[len][<span class="number">0</span>], dp[len][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<p>时间复杂度：<code>O(N)</code>，<code>N</code> 是数组的长度；<br>空间复杂度：<code>O(N)</code>，状态数组的大小为 <code>2(N + 1)</code>，记为 <code>O(N)</code>。<br>参考代码 4：根据方法一，使用「滚动数组」技巧，将空间优化到常数级别</p>
<p>在编码的时候，需要注意，只要访问到 dp 数组的时候，需要对下标<code> % 2</code>，等价的写法是 <code>&amp; 1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i &amp; 1][0]：区间 [0, i] 里接受预约请求，并且下标为 i 的这一天不接受预约的最大时长</span></span><br><span class="line">    <span class="comment">// dp[i &amp; 1][1]：区间 [0, i] 里接受预约请求，并且下标为 i 的这一天接受预约的最大时长</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i &amp; <span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i &amp; <span class="number">1</span>][<span class="number">1</span>] = dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[(len - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>], dp[(len - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<p>时间复杂度：<code>O(N)</code>，<code>N</code> 是数组的长度；<br>空间复杂度：<code>O(1)</code>，状态数组的大小为 4，常数空间。<br>参考代码 5：根据方法二，使用 3 个变量滚动完成计算，将空间优化到常数级别。</p>
<p>在实现上可以在取下标的时候对 3 取模。</p>
<pre><code>public int massage(int[] nums) &#123;
    int len = nums.length;
    if (len == 0) &#123;
        return 0;
    &#125;
    if (len == 1) &#123;
        return nums[0];
    &#125;

    // dp[i % 3]：区间 [0，i] 里接受预约请求的最大时长
    int[] dp = new int[3];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);

    for (int i = 2; i &lt; len; i++) &#123;
        // 今天在选与不选中，选择一个最优的
        dp[i % 3] = Math.max(dp[(i - 1) % 3], dp[(i - 2) % 3] + nums[i]);
    &#125;
    return dp[(len - 1) % 3];
&#125;</code></pre>
<p>复杂度分析：</p>
<p>时间复杂度：O(N)O(N)，NN 是数组的长度；<br>空间复杂度：O(1)O(1)，状态数组的大小为 3，常数空间。</p>
<h3 id="个人代码"><a href="#个人代码" class="headerlink" title="个人代码"></a>个人代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>按摩师</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-64. 求 1+2+…+n</title>
    <url>/wiki/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9864.%E6%B1%821+2+%E2%80%A6+n/</url>
    <content><![CDATA[<h1 id="求-1-2-…-n"><a href="#求-1-2-…-n" class="headerlink" title="求 1+2+…+n"></a>求 1+2+…+n</h1><p>求 <code>1+2+...+n </code>，要求不能使用乘除法、<code>for、while、if、else、switch、case</code> 等关键字及条件判断语句<code>（A?B:C）</code>。</p>
<p>示例 1：</p>
<p>输入：<code>n = 3</code></p>
<p>输出：<code>6</code><br>示例 2：</p>
<p>输入：<code>n = 9</code></p>
<p>输出：<code>45</code></p>
<p>限制：</p>
<p><code>1 &lt;= n &lt;= 10000</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用递归解决循环问题，再利用<code>&amp;&amp;</code>语意前项不成立的话后项不运算，解决终止条件问题。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=n;</span><br><span class="line">        n&amp;&amp;(sum+=sumNums(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数学</tag>
        <tag>n 项和</tag>
        <tag>剑指 offer</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkdownParser</title>
    <url>/wiki/MarkdownParser/</url>
    <content><![CDATA[<p>跟着实验楼，完成一个 C++ 练习项目————Markdown 解析器。 其中涉及到编译原理、语法树、HTML 等内容，还需学习部分补充知识才可以完成。</p>
<a id="more"></a>

<p>项目思路应该是</p>
<p>| Markdown 文件 –&gt; 类似 DOM 语法树 –&gt;  Index.html</p>
<p>项目难点应该是在将 Markdown 文件解析为抽象语法树的部分。需要分为解析和插入两部分进行。</p>
<p>项目地址<a href="https://github.com/HiSunzhenliang/MarkdownParser"> MarkdownParser</a></p>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>练习项目</tag>
        <tag>Markdown</tag>
        <tag>解析器</tag>
        <tag>语法树</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn from Midori(unfinished)</title>
    <url>/wiki/Midori/</url>
    <content><![CDATA[<h1 id="About-Midori"><a href="#About-Midori" class="headerlink" title="About Midori"></a>About Midori</h1><p>Midori was a research/incubation project to explore ways of innovating throughout Microsoft’s software stack. This spanned all aspects, including the programming language, compilers, OS, its services, applications, and the overall programming models.</p>
<h1 id="A-Tale-of-Three-Safeties"><a href="#A-Tale-of-Three-Safeties" class="headerlink" title="A Tale of Three Safeties"></a>A Tale of Three Safeties</h1><ol>
<li><p>Midori was built on a foundation of three kinds of safety: type, memory, and concurrency-safety</p>
</li>
<li><p>So, anyway, how do you build an operating system, whose central purpose is to control hardware resources, buffers, services and applications running in parallel, and so on, all of which are pretty damn unsafe things, using a safe programming environment? Great question. The answer is surprisingly simple: layers.</p>
</li>
<li><p>A nice consequence of our approach was that the system was built upon itself.</p>
</li>
<li><p>Note that I didn’t say we banned concurrency altogether, just that we banned unsafe concurrency.</p>
</li>
<li><p>They key insight driving the formalism here was that no two “threads” sharing an address space were permitted to see the same object as mutable at the same time. Many could read from the same memory at once, and one could write, but multiple could not write at once.</p>
</li>
<li><p>The combination of memory, type, and concurrency safety gave us a powerful foundation to stand on. Most of all, it delivered a heightened level of developer productivity and let us move fast. The extremely costly buffer overflows, data races, deadlocks, and so on, simply did not happen. Someday all operating systems will be written this way.</p>
</li>
</ol>
<h1 id="Objects-as-Secure-Capabilities"><a href="#Objects-as-Secure-Capabilities" class="headerlink" title="Objects as Secure Capabilities"></a>Objects as Secure Capabilities</h1><ol>
<li><p>Insecure operations rejected at compile-time, how cool is that!</p>
</li>
<li><p>Midori was by no means the first to build an operating systems with object capabilities at its core.</p>
</li>
<li><p>Since objects represent capabilities, they can be as fine or coarse as you wish. You can make new ones through composition, or modify existing ones through subclassing. Dependencies are managed just like any dependencies in an object-oriented system: by encapsulating, sharing, and requesting references to objects. You can leverage all sorts of classic design patterns suddenly in the domain of security. I do have to admit the simplicity of this idea was jarring to some.</p>
</li>
<li><p>we banned mutable statics, by-construction at compile-time, in our programming language. That’s right, not only could a static field only be written to once, but the entire object graph it referred to was frozen after construction.</p>
</li>
</ol>
<h1 id="Asynchronous-Everything"><a href="#Asynchronous-Everything" class="headerlink" title="Asynchronous Everything"></a>Asynchronous Everything</h1><ol>
<li><p>First, remember, Midori was an entire OS written to use garbage collected memory. We learned some key lessons that were necessary for this to perform adequately.</p>
</li>
<li><p>The first key optimization, therefore, is that an async method that doesn’t await shouldn’t allocate anything.</p>
</li>
<li><p>The second key optimization was to ensure that async methods that awaited allocated as little as possible.</p>
</li>
<li><p>What we ended up with was a model that only allocated when the await happened, and that allocated only once for an entire such chain of calls. We called this chain an “activity.” The top-most demarcated the boundary of an activity. As a result, could cost something, but was free.asyncasyncawait.</p>
</li>
<li><p>It was pretty common to be running the Midori system at 100% CPU utilization, because it was doing useful stuff, which is pretty rare on PCs and traditional apps.</p>
</li>
</ol>
<p>and ?</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="http://joeduffyblog.com/2015/11/03/blogging-about-midori/">Joe Duffy’s Blog</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>OS</category>
        <category>design</category>
      </categories>
      <tags>
        <tag>Midori</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1001</title>
    <url>/wiki/PAT-B-1001/</url>
    <content><![CDATA[<h3 id="1001-害死人不偿命的-3n-1-猜想-（15-分"><a href="#1001-害死人不偿命的-3n-1-猜想-（15-分" class="headerlink" title="1001 害死人不偿命的(3n+1)猜想 （15 分)"></a>1001 害死人不偿命的(3n+1)猜想 （15 分)</h3><p>卡拉兹(Callatz)猜想：</p>
<p>对任何一个正整数 <em>n</em>，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3<em>n</em>+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 <em>n</em>=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3<em>n</em>+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>
<a id="more"></a>

<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 <em>n</em>，简单地数一下，需要多少步（砍几下）才能得到 <em>n</em>=1？</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em> 的值。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>n</em> 计算到 1 需要的步数。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>按条件逆循环结束得到答案</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            n = (<span class="number">3</span> * n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1002</title>
    <url>/wiki/PAT-B-1002/</url>
    <content><![CDATA[<h3 id="1002-写出这个数-（20-分"><a href="#1002-写出这个数-（20-分" class="headerlink" title="1002 写出这个数 （20 分)"></a>1002 写出这个数 （20 分)</h3><p>读入一个正整数 <em>n</em>，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>
<a id="more"></a>

<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出自然数 <em>n</em> 的值。这里保证 <em>n</em> 小于 10100。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行内输出 <em>n</em> 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1234567890987654321123456789</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yi san wu</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>字符ASCII码的使用</li>
<li>c++11的<code>to_string()</code>函数使用</li>
<li>输出格式，单独输出最后一个</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> sum;</span><br><span class="line">	<span class="built_in">string</span> str[] = &#123; <span class="string">&quot;ling&quot;</span>,<span class="string">&quot;yi&quot;</span>,<span class="string">&quot;er&quot;</span>,<span class="string">&quot;san&quot;</span>,<span class="string">&quot;si&quot;</span>,<span class="string">&quot;wu&quot;</span>,<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;qi&quot;</span>,<span class="string">&quot;ba&quot;</span>,<span class="string">&quot;jiu&quot;</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.length(); i++) &#123;</span><br><span class="line">		sum += (n[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> n2 = to_string(sum);<span class="comment">// to_string()必须使用c++11编译 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; str[n2[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>PAT</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1003</title>
    <url>/wiki/PAT-B-1003/</url>
    <content><![CDATA[<h3 id="1003-我要通过！-（20-分"><a href="#1003-我要通过！-（20-分" class="headerlink" title="1003 我要通过！ （20 分)"></a>1003 我要通过！ （20 分)</h3><p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。</p>
<a id="more"></a>

<p>得到“<strong>答案正确</strong>”的条件是：</p>
<ol>
<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>
<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li>
<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</li>
</ol>
<p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">PAT</span><br><span class="line">PAAT</span><br><span class="line">AAPATAA</span><br><span class="line">AAPAATAAAA</span><br><span class="line">xPATx</span><br><span class="line">PT</span><br><span class="line">Whatever</span><br><span class="line">APAAATAA</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>任意形如 xPATx 的字符串串都可以获得“答案正确”，其中 x 或者是空字符串串，或者是仅由字⺟母 A 组成的<br>字符串串；<br>那么正确的有这些：<br>PAT<br>APATA<br>AAPATAA<br>AAAPATAAA<br>…不不说了了，就是中间⼀一个A左右加上等量量的A（不不加也⾏行行）都是正确的。<br>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串串，或者是仅由字⺟母 A<br>组成的字符串串。<br>拿上⾯面的那⼏几个正确的举例例⼦子，那么正确的有这些：</p>
<p>PAT —— 对于 aPbTc 来说ac是空，b是A。所以 PAAT 是正确的。同理理PAAAAAT中间加多少个A都是正确哒<br>～<br>APATA —— 对于aPbTc来说，abc都是A。所以 APAATAA 是正确的。再类推⼀一下，那么 APAAATAAA 是正<br>确的。<br>AAPATAA —— 对于aPbTc来说，a和c是AA，b是A。所以AAPAATAAAA是正确的，再类推⼀一下，<br>AAPAAATAAAAAA 是正确的～～<br>所以说规律律就是，可以在P和T中间加A并且在T后⾯面加A，要求必须是，中间加上⼀一个A，末尾就得加上<br>⼏几倍的(P前⾯面A的那个字符串串)。换句句话说就是，中间的A的个数如果是3，那么末尾的A的个数就得是开<br>头A的个数的3倍。很巧，当中间A为⼀一个的时候，末尾和开头A的个数必须相等正好是第⼆二条的要求～<br>所以⼀一句句话总结字符串串的要求：只能有⼀一个P⼀一个T，中间末尾和开头可以随便便插⼊入A。但是必须满⾜足<br>开头的A的个数 * 中间的A的个数 = 结尾的A的个数，⽽而且P和T中间不不能没有A～</p>
<p>——liuluo</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); j++) &#123;</span><br><span class="line">            m[s[j]]++;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;P&#x27;</span>) p = j;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;T&#x27;</span>) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m[<span class="string">&#x27;P&#x27;</span>] == <span class="number">1</span> &amp;&amp; m[<span class="string">&#x27;A&#x27;</span>] != <span class="number">0</span> &amp;&amp; m[<span class="string">&#x27;T&#x27;</span>] == <span class="number">1</span> &amp;&amp; m.size() == <span class="number">3</span> &amp;&amp; t-p != <span class="number">1</span> &amp;&amp; p * (t-p<span class="number">-1</span>) == s.length()-t<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>PAT</tag>
        <tag>字符</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1004</title>
    <url>/wiki/PAT-B-1004/</url>
    <content><![CDATA[<h3 id="1004-成绩排名-（20-分"><a href="#1004-成绩排名-（20-分" class="headerlink" title="1004 成绩排名 （20 分)"></a>1004 成绩排名 （20 分)</h3><p>读入 <em>n</em>（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>
<a id="more"></a>

<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，格式为</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">第<span class="number"> 1 </span>行：正整数 n</span><br><span class="line">第<span class="number"> 2 </span>行：第<span class="number"> 1 </span>个学生的姓名 学号 成绩</span><br><span class="line">第<span class="number"> 3 </span>行：第<span class="number"> 2 </span>个学生的姓名 学号 成绩</span><br><span class="line">  ... ... ...</span><br><span class="line">第 n+1 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure>

<p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Joe Math990112 89</span><br><span class="line">Mike CS991301 100</span><br><span class="line">Mary EE990830 95</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mike CS991301</span><br><span class="line">Joe Math990112</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>使用自定义结构体保证同一个学生的数据的连续性</li>
<li>使用<code>map</code>储存数据，自动排序</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">student</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">string</span> num;</span><br><span class="line">	<span class="keyword">int</span> gre;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	student stu[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; stu[i].name &gt;&gt; stu[i].num &gt;&gt; stu[i].gre;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, student&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		m[stu[i].gre] = stu[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (m.rbegin()-&gt;second).name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (m.rbegin()-&gt;second).num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (m.begin()-&gt;second).name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (m.begin()-&gt;second).num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>PAT</tag>
        <tag>查找</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1005</title>
    <url>/wiki/PAT-B-1005/</url>
    <content><![CDATA[<h3 id="1005-继续-3n-1-猜想-（25-分"><a href="#1005-继续-3n-1-猜想-（25-分" class="headerlink" title="1005 继续(3n+1)猜想 （25 分)"></a>1005 继续(3n+1)猜想 （25 分)</h3><p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p>
<p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 <em>n</em>=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 <em>n</em>=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 <em>n</em> 为“关键数”，如果 <em>n</em> 不能被数列中的其他数字所覆盖。</p>
<p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>
<a id="more"></a>

<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em>(1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 5 6 7 8 11</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 6</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>使用<code>set</code>先自动排序，探查到满足要求后<code>s.erase()</code>直接删除，剩下就是所求数字</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tell</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">			n = (<span class="number">3</span> * n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			s.erase(n);</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			n = n / <span class="number">2</span>;</span><br><span class="line">			s.erase(n);</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		s.insert(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end(); it++) &#123;</span><br><span class="line">		tell(*it, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> size = s.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s.rbegin(); it != s.rend(); it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">		<span class="keyword">if</span> (size - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>PAT</tag>
        <tag>排序</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1025</title>
    <url>/wiki/PAT-B-1025/</url>
    <content><![CDATA[<h3 id="1025-反转链表（25分）"><a href="#1025-反转链表（25分）" class="headerlink" title="1025 反转链表（25分）"></a>1025 反转链表（25分）</h3><p>给定一个常数K以及一个单链表L，请编写程序将L中每K个结点反转。例如：给定L为 1→2→3→4→5→6，K为 3，则输出应该为 3→2→1→6→5→4；如果K为 4，则输出应该为 4→3→2→1→5→6，即最后不到K个元素不反转</p>
<a id="more"></a>

<p><strong>输入格式</strong></p>
<p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em> (≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>下来有 <em>N</em> 行，每行格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure>

<p>其中<code>Address</code>是节点地址，<code>Data</code>是该节点保存的数据，<code>Next</code> 是下一结点的地址。</p>
<p><strong>输出格式</strong></p>
<p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>设置录入的vector足够大，直接把vector的index与节点的address匹配，这在节点数很少的情况下可用;</li>
<li>从给定头结点指针开始，顺序找到整个链，要注意有些节点可能是废节点，所以排序后找出来的链长度可能小于初始录入的节点数目，利用链表特性可以过滤掉废节点;</li>
<li>将排序后的节点每K个为单位录入到要输出的最后结果的vector中，注意剩余不足K个节点顺序添加到后边；</li>
<li>修改除最后一个节点之外的所有节点的next指针，并输出每个节点信息；</li>
<li>输出最后一个节点信息，注意next为 - 1</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PLAN 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> data1[<span class="number">100005</span>], next1[<span class="number">100005</span>], <span class="built_in">list</span>[<span class="number">100005</span>];<span class="comment">//vs 默认栈堆太小，定义全局</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first, k, n, temp;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; first &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="comment">//int data1[100005], next1[100005], list[100005];</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; data1[temp] &gt;&gt; next1[temp];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//不一定所有的输入的结点都是有用的，加个计数器</span></span><br><span class="line">	<span class="keyword">while</span> (first != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">list</span>[sum++] = first;</span><br><span class="line">		first = next1[first];<span class="comment">//过滤废节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (sum - sum % k); i += k)</span><br><span class="line">		reverse(begin(<span class="built_in">list</span>) + i, begin(<span class="built_in">list</span>) + i + k);</span><br><span class="line">	<span class="comment">//reverse(begin(list), begin(list) + k);</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, <span class="built_in">list</span>[i], data1[<span class="built_in">list</span>[i]], <span class="built_in">list</span>[i + <span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>, <span class="built_in">list</span>[sum - <span class="number">1</span>], data1[<span class="built_in">list</span>[sum - <span class="number">1</span>]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PLAN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodata1</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> address;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;a[N], *b[N];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, n, k, head, address, next, data;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;head, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;address, &amp;data, &amp;next);</span><br><span class="line">		a[address].address = address;</span><br><span class="line">		a[address].data = data;</span><br><span class="line">		a[address].next = next;</span><br><span class="line">	&#125;</span><br><span class="line">	j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = head; i != <span class="number">-1</span>; i = a[i].next)<span class="comment">//获得a的指针,过滤掉废节点</span></span><br><span class="line">		b[j++] = &amp;a[i];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= j - k; i += k) <span class="comment">//翻转，&lt;= 假设有k = j = 4,也应该翻转一次。</span></span><br><span class="line">		reverse(b + i, b + i + k);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != j - <span class="number">1</span>)<span class="comment">//由于要输出下一个元素的位置，到最后一个的时候有点特殊，所以对于b[i+1]-&gt;address，要判断一下输出。</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, b[i]-&gt;address, b[i]-&gt;data, b[i + <span class="number">1</span>]-&gt;address);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>, b[i]-&gt;address, b[i]-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>PAT</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1032</title>
    <url>/wiki/PAT-B-1032/</url>
    <content><![CDATA[<h3 id="1032-挖掘机技术哪家强-（20-分"><a href="#1032-挖掘机技术哪家强-（20-分" class="headerlink" title="1032 挖掘机技术哪家强 （20 分)"></a>1032 挖掘机技术哪家强 （20 分)</h3><p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p>
<a id="more"></a>

<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行给出不超过 105 的正整数 <em>N</em>，即参赛人数。随后 <em>N</em> 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 65</span><br><span class="line">2 80</span><br><span class="line">1 100</span><br><span class="line">2 70</span><br><span class="line">3 40</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 150</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>时间复杂度需要注意，直接输入时就进行求和，用<code>school</code>作为数组关键字</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> a[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> school = <span class="number">0</span>, score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; school &gt;&gt; score;</span><br><span class="line">        a[school] += score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">1</span>], maxi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max) &#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">            maxi = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>水题</tag>
        <tag>PAT</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1033</title>
    <url>/wiki/PAT-B-1033/</url>
    <content><![CDATA[<h3 id="1033-旧键盘打字-（20-分"><a href="#1033-旧键盘打字-（20-分" class="headerlink" title="1033 旧键盘打字 （20 分)"></a>1033 旧键盘打字 （20 分)</h3><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？</p>
<a id="more"></a>

<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [<code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>]、数字 <code>0</code>-<code>9</code>、以及下划线 <code>_</code>（代表空格）、<code>,</code>、<code>.</code>、<code>-</code>、<code>+</code>（代表上档键）。题目保证第 2 行输入的文字串非空。</p>
<p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7+IE.</span><br><span class="line">7_This_is_a_test.</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_hs_s_a_tst</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>plan1：查找<code>+</code>转换s1全部为小写，s2大写字母全部替换为<code>*</code></p>
</li>
<li><p>对应查找坏键后替换<code>*</code>再输出答案</p>
</li>
<li><p>plan2：坏掉的键保存在字符串串bad中，应该输⼊入的⽂文字保存在should中，遍历整个应该输⼊入的字符串串，因为坏键以⼤大写给出，所以如果在bad⾥里里⾯面找到了了should[i]的⼤大写，表示这个字符对应的键坏了了，则跳过这个字符不不输出，continue跳过～如果should[i]是⼤大写并且在bad中找到了了’+’，表示上档键坏了了，⼤大写⽆无法输出，所以这个字符也不不能输出，continue跳过～如果都没跳过，则要输出should[i]</p>
<p>——liuluo</p>
</li>
<li><p>有可能没有坏键，第一行为空，不能使用<code>cin</code>输入，使用<code>getline(cin,s)</code></p>
</li>
<li><p><code>s.find(char a)</code>返回<code>a</code>在<code>s</code>出现的位置坐标，第一个为0，判断时使用<code>string::npos</code>或者<code>-1</code></p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//plan1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; s1 &gt;&gt; s2;</span></span><br><span class="line">    getline(<span class="built_in">cin</span>, s1);  <span class="comment">//为了防止第一行是空的，不能用cin &gt;&gt; ,用getline(cin, ...)</span></span><br><span class="line">    getline(<span class="built_in">cin</span>, s2);</span><br><span class="line">    <span class="keyword">if</span> (s1.find(<span class="string">&#x27;+&#x27;</span>) != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        transform(s1.begin(), s1.end(), s1.begin(), ::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(s2[i])) &#123;</span><br><span class="line">                s2[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2[j] == s1[i] || s2[j] == <span class="built_in">tolower</span>(s1[i]) ||</span><br><span class="line">                s2[j] == <span class="built_in">toupper</span>(s1[i])) &#123;</span><br><span class="line">                s2[j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s2[i] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s2[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//plan2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> bad, should;</span><br><span class="line">  getline(<span class="built_in">cin</span>, bad);  <span class="comment">//为了防止第一行是空的，不能用cin &gt;&gt; ,用getline(cin, ...)</span></span><br><span class="line">  getline(<span class="built_in">cin</span>, should);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, length = should.length(); i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bad.find(<span class="built_in">toupper</span>(should[i])) != <span class="built_in">string</span>::npos) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isupper</span>(should[i]) &amp;&amp; bad.find(<span class="string">&#x27;+&#x27;</span>) != <span class="built_in">string</span>::npos) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; should[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>PAT</tag>
        <tag>查找</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>code review 行话</title>
    <url>/wiki/code-review%E8%A1%8C%E8%AF%9D/</url>
    <content><![CDATA[<blockquote>
<p>最近在和大佬交流时，发现很多缩写不太懂，这里记录一下</p>
</blockquote>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">LGTM  —  Looks good <span class="keyword">to</span> <span class="keyword">me</span>，表示认可这次 PR，同意 merge 合并代码到远程仓库</span><br><span class="line">ASAP -— <span class="keyword">as</span> soon <span class="keyword">as</span> possible! 尽快</span><br><span class="line">ACK  —  acknowledgement, i.e. agreed/accepted change</span><br><span class="line">NACK/NAK — negative acknowledgement, i.e. disagree <span class="keyword">with</span> change <span class="keyword">and</span>/<span class="keyword">or</span> concept</span><br><span class="line">RFC  —  request <span class="keyword">for</span> comments, i.e. I think this <span class="keyword">is</span> a good idea, lets discuss</span><br><span class="line">WIP：Work <span class="keyword">In</span> Progress 「进展中」，常见词汇，这里做为 Best Practice 单独提出来，主要针对改动较多的 PR，可以先提交部分，标题或 Tag 加上 WIP，表示尚未完成，这样别人可以先 review 已提交的部分</span><br><span class="line">AFAIK/AFAICT  —  <span class="keyword">as</span> far <span class="keyword">as</span> I know / can tell</span><br><span class="line">IIRC  —  <span class="keyword">if</span> I recall correctly</span><br><span class="line">IANAL  — “ I am <span class="keyword">not</span> a lawyer ”, but I smell licensing issues</span><br><span class="line">IMO  — （<span class="keyword">In</span> my opinion），在我看来</span><br><span class="line">TL;DR  —  Too <span class="built_in">Long</span>; Didn<span class="comment">&#x27;t Read 「太长懒得看」，README 文档常见。</span></span><br><span class="line">PR  —  Pull request「合并请求」</span><br><span class="line">CR  —  Code Review 「代码审查」</span><br><span class="line">PTAL  —  Please <span class="keyword">Take</span> A Look. 你来瞅瞅？用来提示别人来看一下</span><br><span class="line">TBR  —  <span class="keyword">To</span> Be Reviewed. 提示维护者进行 review</span><br><span class="line">TBD  —  <span class="keyword">To</span> Be Done(<span class="keyword">or</span> Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思。</span><br><span class="line">TBH  —  <span class="keyword">To</span> be honest 「老实说」</span><br><span class="line">atm  —  at the moment 「现阶段」，</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/238a1e1f4037">code review 行话</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>code review</tag>
      </tags>
  </entry>
  <entry>
    <title>do...while(0)特殊用法</title>
    <url>/wiki/do-while-0-%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>最近在FFmpeg和sox源码中发现有<code>#define do...while(0)</code>的用法，不太能理解就查了下。发现在Linux内核中也有这些用法。</p>
<p>总结大概有以下几点：</p>
<ol>
<li>空语句编译时会产生警告<code>#define FOO do&#123; &#125; while(0)</code></li>
<li>创建一个局部空间，可以在其中定义局部变量</li>
<li>在宏定义中使用复杂语法，单只产生单条语句而不是语句块<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> exch(x,y) &#123; int tmp; tmp=x; x=y; y=tmp; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用上面的宏</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">　　exch(x,y);          <span class="comment">// Branch 1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">　　do_something();     <span class="comment">// Branch 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但展开是这样</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; y) &#123;                <span class="comment">// 单分支if</span></span><br><span class="line">　　<span class="keyword">int</span> tmp;</span><br><span class="line">　　tmp = x;</span><br><span class="line">　　x = y;</span><br><span class="line">　　y = tmp;</span><br><span class="line">&#125;</span><br><span class="line">　;                           <span class="comment">// 空语句</span></span><br><span class="line"><span class="keyword">else</span>                        <span class="comment">// 错误!!! &quot;parse error before else&quot;</span></span><br><span class="line">　　do_something();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用do while</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">　　<span class="keyword">do</span> &#123;</span><br><span class="line">　　<span class="keyword">int</span> tmp;</span><br><span class="line">　　tmp = x;</span><br><span class="line">　　x = y;</span><br><span class="line">　　y = tmp;</span><br><span class="line">　　&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">　　do_something();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>具体参考以下内核说明文档<a href="https://kernelnewbies.org/FAQ/DoWhile0">https://kernelnewbies.org/FAQ/DoWhile0</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://kernelnewbies.org/FAQ/DoWhile0">https://kernelnewbies.org/FAQ/DoWhile0</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Language</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>openmp 的的一点多线程应用</title>
    <url>/wiki/openmp%E7%9A%84%E7%9A%84%E4%B8%80%E7%82%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><code>#pragma omp parallel for</code> 的使用</p>
<p>openmp 一般随 gcc 一起，编译时使用 <code>-fopenmp</code>打开。会多一个<code>_OPENMP</code>宏定义生效，然后就可以用了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for <span class="comment">// newline is for-loop</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.ibm.com/support/knowledgecenter/SSGH2K_13.1.2/com.ibm.xlc1312.aix.doc/compiler_ref/tuoptppp.html">tuoptppp</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/SSGH2K_13.1.2/com.ibm.xlc1312.aix.doc/compiler_ref/prag_omp_parallel.html">prag_omp_parallel</a></li>
<li><a href="https://www.openmp.org/specifications/">https://www.openmp.org/specifications/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Multi-threads</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>多线程</tag>
        <tag>openmp</tag>
      </tags>
  </entry>
  <entry>
    <title>pkg-config的一点用法</title>
    <url>/wiki/pkg-config%E7%9A%84%E4%B8%80%E7%82%B9%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h1><p>用于获取已安装库的基本信息</p>
<p><code>pkg-config</code>查看全部参数和意义</p>
<h2 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">program: program.c</span></span><br><span class="line">        cc program.c ‘pkg-config --cflags --libs gnomeui‘</span><br></pre></td></tr></table></figure>

<p>就是[–cflags] [–libs]，用来指出程序依赖的头文件和库文件路径</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>pkg-config</code>读取库名对应的<code>.pc</code>文件</p>
<p>默认情况下，会去<code>prefix/lib/pkgconfig/</code>路径下查找，具体到Linux系统，就是<code>/usr/lib/pkgconfig/</code>目录，若找不到，则会去<code>PKG_CONFIG_PATH</code>环境变量指定的路径下查找。因此，如果我们安装的库文件不在系统环境变量中，需要将其添加到<code>PKG_CONFIG_PATH</code>中，具体来说，执行如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/home/mylibs/lib/pkgconfig:$PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<p><code>sox.pc</code>内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prefix=/usr/local</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line"></span><br><span class="line">Name: SoX</span><br><span class="line">Description: Audio file format and effects library</span><br><span class="line">Version: 14.4.3git</span><br><span class="line">URL: http://sox.sourceforge.net</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lsox</span><br><span class="line">Libs.private: -lm </span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br></pre></td></tr></table></figure>

<p>最后两个参数可以简化Makefile的书写</p>
<h2 id="编写-pc"><a href="#编写-pc" class="headerlink" title="编写.pc"></a>编写<code>.pc</code></h2><h3 id="例子1-动态库的pc文件"><a href="#例子1-动态库的pc文件" class="headerlink" title="例子1 动态库的pc文件"></a>例子1 动态库的pc文件</h3><p>假设我写了libfoo.so，我的库将会被安装到/usr/local/lib/，头文件会放到/usr/local/include/foo。那么，pc文件可以这么写。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prefix=/usr/local</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line"></span><br><span class="line">Name: foo</span><br><span class="line">Description: The foo library</span><br><span class="line">Version: 1.0.0</span><br><span class="line">Cflags: -I$&#123;includedir&#125;/foo</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lfoo</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>pkg-config</tag>
        <tag>tools</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Python getopt简单使用</title>
    <url>/wiki/python-getopt%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Python-getopt的简单使用"><a href="#Python-getopt的简单使用" class="headerlink" title="Python getopt的简单使用"></a>Python getopt的简单使用</h1><p>一般 <code>getopt</code>使用在解析参数列表上。</p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>一般情况下，选项有“短选项”和“长选项”两种</p>
<p>短选项格式：一个减号一个字母；长选项格式：俩减号多个字母</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">Options</span>:</span><br><span class="line">        -h, --help  Help info</span><br><span class="line">        -f          <span class="meta">INPUT</span> Mardown <span class="meta">file</span></span><br><span class="line">        -s          css for pages</span><br><span class="line">        -d          <span class="meta">OUTPUT</span> HTML <span class="meta">file</span> path</span><br><span class="line">        -F          <span class="meta">OUTPUT</span> HTML <span class="meta">file</span> name</span><br></pre></td></tr></table></figure>

<p> <code>getopt.getopt</code> 方法有仨参数：要处理的对象列表、短选项组、长选项组</p>
<ul>
<li>短选项组为字符串，若选项有参数，后面加冒号</li>
<li>长选项组为列表，若选项有参数，后面加等号</li>
</ul>
<p>该方法返回值为二元元组，元组中每个元素都是列表, 一个是选项解析结果，另一个是其余参数</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArgsParse</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    命令行参数解析类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数说明</span></span><br><span class="line">    options_explain = <span class="string">&#x27;&#x27;&#x27;Options:</span></span><br><span class="line"><span class="string">        -h, --help  Help info</span></span><br><span class="line"><span class="string">        -f          INPUT Mardown file</span></span><br><span class="line"><span class="string">        -s          css for pages</span></span><br><span class="line"><span class="string">        -d          OUTPUT HTML file path</span></span><br><span class="line"><span class="string">        -F          OUTPUT HTML file name</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        选项有“短选项”和“长选项”两种</span></span><br><span class="line"><span class="string">        短选项格式：一个减号一个字母；长选项格式：俩减号多个字母</span></span><br><span class="line"><span class="string">        getopt.getopt 方法有仨参数：要处理的对象列表、短选项组、长选项组</span></span><br><span class="line"><span class="string">        短选项组为字符串，若选项有参数，后面加冒号</span></span><br><span class="line"><span class="string">        长选项组为列表，若选项有参数，后面加等号</span></span><br><span class="line"><span class="string">        该方法返回值为二元元组，元组中每个元素都是列表</span></span><br><span class="line"><span class="string">        一个是选项解析结果，另一个是其余参数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        options, _ = getopt.getopt(sys.argv[<span class="number">1</span>:], <span class="string">&#x27;hf:s:d:F:&#x27;</span>, [<span class="string">&#x27;help&#x27;</span>])</span><br><span class="line">        self.options_dict = (<span class="built_in">dict</span>(options))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;-h&#x27;</span> <span class="keyword">in</span> self.options_dict <span class="keyword">or</span> <span class="string">&#x27;--help&#x27;</span> <span class="keyword">in</span> self.options_dict:</span><br><span class="line">            print(self.options_explain)</span><br><span class="line">            sys.exit()</span><br><span class="line">        self.args_parse()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">args_parse</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        参数处理函数，从解析后的选项字典中读取各个文件名</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.markdown_file = self.options_dict.get(<span class="string">&#x27;-f&#x27;</span>)</span><br><span class="line">        self.css_file = self.options_dict.get(<span class="string">&#x27;-s&#x27;</span>)</span><br><span class="line">        self.html_file_dir = self.options_dict.get(<span class="string">&#x27;-d&#x27;</span>)</span><br><span class="line">        self.html_file = self.options_dict.get(<span class="string">&#x27;-F&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>getopt</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 命令</title>
    <url>/wiki/shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="shell-常用命令"><a href="#shell-常用命令" class="headerlink" title="shell 常用命令"></a>shell 常用命令</h1><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpmbuild -ba *.spec  #编译打包rpm</span><br><span class="line">rpm -ivh *.rpm   #安装rpm包</span><br><span class="line">rpm -qpR *.rpm   #列出包依赖的库</span><br><span class="line">rpm -ql  *.rpm   #列出安装的内容</span><br><span class="line">rpm -qpl *.rpm   #列出未安装的包里内容</span><br><span class="line">rpm -qa | grep   #查找安装的相关包</span><br></pre></td></tr></table></figure>

<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp [-P port] file usr@x.x.x.x:~/dir  #local to remote</span><br><span class="line">scp [-P port] usr@x.x.x.x:~/dir/file  ./dir  #remote to local</span><br></pre></td></tr></table></figure>

<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -d or -P symbolic-link dir/   #复制软连接而不是文件本身</span><br></pre></td></tr></table></figure>

<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh [-p port] usr@x.x.x.x  #ssh登录远端</span><br></pre></td></tr></table></figure>

<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adduser &lt;username&gt;  #添加新用户</span><br><span class="line">usermod -aG sudo/wheel &lt;username&gt;  #用户添加到sudo组</span><br></pre></td></tr></table></figure>

<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsb_release -a #查看系统版本信息的命令</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">uname -a</span><br><span class="line">hostnamectl</span><br><span class="line">uptime</span><br><span class="line">cat /proc/version #查看系统版本信息的命令</span><br><span class="line">cat /proc/sys/fs/inotify/max_user_watches #最大文件监控数</span><br><span class="line"><span class="meta">#</span><span class="bash"> The <span class="built_in">limit</span> can be increased to its maximum by editing /etc/sysctl.conf (except on Arch Linux, <span class="built_in">read</span> below) and adding this line to the end of the file:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fs.inotify.max_user_watches=524288</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The new value can <span class="keyword">then</span> be loaded <span class="keyword">in</span> by running sudo sysctl -p.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> While 524,288 is the maximum number of files that can be watched, <span class="keyword">if</span> you<span class="string">&#x27;re in an environment that is particularly memory constrained, you may wish to lower the number. Each file watch takes up 1080 bytes, so assuming that all 524,288 watches are consumed, that results in an upper bound of around 540 MiB.</span></span></span><br><span class="line"></span><br><span class="line">ls /proc[pid]  #查看进程信息</span><br><span class="line">watch -n 1 &quot;nstat | grep Tcp&quot; #查看机器网络变化信息, 排错可用</span><br><span class="line">df -lhT  #查看文件系统类型</span><br><span class="line"></span><br><span class="line">du -h --max-depth=1  #查看当前目录文件夹大小</span><br><span class="line">who  </span><br><span class="line">who -Hu #查看谁可以访问</span><br><span class="line">grep sh$ /etc/passwd  #查看谁有shell访问权限</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否物理机</span></span><br><span class="line">dmidecode -s system-manufacturer        </span><br><span class="line">dmidecode -s system-product-name        </span><br><span class="line">lshw -c system | grep product | head -1        </span><br><span class="line">cat /sys/class/dmi/id/product_name        </span><br><span class="line">cat /sys/class/dmi/id/sys_vendor        </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看硬件信息</span></span><br><span class="line">lscpu or cat /proc/cpuinfo</span><br><span class="line">lsmem or cat /proc/meminfo</span><br><span class="line">ifconfig -a</span><br><span class="line">ethtool &lt;devname&gt;</span><br><span class="line">lshw</span><br><span class="line">lspci</span><br><span class="line">dmidecode</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看进程和服务</span></span><br><span class="line">pstree -pa 1</span><br><span class="line">ps -ef</span><br><span class="line">ps auxf</span><br><span class="line">systemctl</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 网路</span></span><br><span class="line">netstat -tulpn</span><br><span class="line">netstat -anp</span><br><span class="line">lsof -i</span><br><span class="line">ss</span><br><span class="line">iptables -L -n</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内核</span></span><br><span class="line">[https://www.oreilly.com/library/view/red-hat-enterprise/9781785283550/ch10s05.html](https://www.oreilly.com/library/view/red-hat-enterprise/9781785283550/ch10s05.html)</span><br><span class="line">uname -r</span><br><span class="line">cat /proc/cmdline</span><br><span class="line">lsmod</span><br><span class="line">modinfo &lt;module&gt;</span><br><span class="line">sysctl -a</span><br><span class="line">cat /boot/grub2/grub.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志</span></span><br><span class="line">dmesg</span><br><span class="line">tail -f /var/log/messages</span><br><span class="line">journalctl</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 追踪</span></span><br><span class="line">strace</span><br></pre></td></tr></table></figure>

<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git archive --prefix=output/ -o &quot;../output.tar.gz&quot; develop  #git库打包</span><br><span class="line">git reflog # 查看本地记录</span><br></pre></td></tr></table></figure>

<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum reinstall packagename  #可以在/var/cache/yum目录下找到包</span><br><span class="line">yum provides *.so.version  #查询哪个包提供这个库</span><br></pre></td></tr></table></figure>

<h2 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg-config --variable pc_path pkg-config #查看pc路径</span><br></pre></td></tr></table></figure>

<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make V=1 #展示出具体编译命令</span><br></pre></td></tr></table></figure>

<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> get all filename <span class="keyword">in</span> specified path</span></span><br><span class="line"></span><br><span class="line">path=$1</span><br><span class="line">files=$(ls $path)</span><br><span class="line">for file in $files</span><br><span class="line">do</span><br><span class="line">  mv $file &#x27;bad-&#x27;$file</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">in ext4</span><br><span class="line">1：找到文件或目录的索引节点号</span><br><span class="line"></span><br><span class="line">ls -i filename</span><br><span class="line"></span><br><span class="line">2：找到文件所在的分区或VG</span><br><span class="line"></span><br><span class="line">  df -T</span><br><span class="line"></span><br><span class="line">3：使用debugfs找到文件的创建时间（crtime）</span><br><span class="line"></span><br><span class="line">debugfs -R &#x27;stat &lt;xxx&gt;&#x27; /dev/xxxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>sip协议学习</title>
    <url>/wiki/sip%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="sip协议学习"><a href="#sip协议学习" class="headerlink" title="sip协议学习"></a>sip协议学习</h1><p>最近项目接触到几个通讯协议, 这里来学习一下.</p>
<h2 id="sip简介"><a href="#sip简介" class="headerlink" title="sip简介"></a>sip简介</h2><p>SIP（Session Initiation Protocol，会话初始协议）, 一种多媒体通讯协议, 支持并应用于语言、视频等多媒体业务。<br>SIP is an application-layer control protocol that can establish,<br>modify, and terminate multimedia sessions (conferences) such as<br>Internet telephony calls.</p>
<p>SIP协议总的来说就是一堆协议拼起来使用。实现媒体通信、控制等业务功能。</p>
<p>注意，SIP消息和具体的媒体流并不是在一个层面运作的。例如，一个VoIP电话是先通过SIP信令完成交互后再开始具体媒体流的传输的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://tools.ietf.org/html/rfc3428">Session Initiation Protocol (SIP) Extension for Instant Messaging</a></li>
<li><a href="https://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a></li>
<li><a href="https://www.cnblogs.com/xiaxveliang/p/12434170.html">SIP 协议详解</a></li>
<li><a href="https://www.cnblogs.com/gnuhpc/archive/2012/01/16/2323637.html">【SIP协议】学习初学笔记</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Protocols</category>
      </categories>
      <tags>
        <tag>Protocol</tag>
        <tag>SIP</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>wav 文件格式详解</title>
    <url>/wiki/wav%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="wav-文件格式详解"><a href="#wav-文件格式详解" class="headerlink" title="wav 文件格式详解"></a>wav 文件格式详解</h1><p>WAVE 文件规范来自微软。文件格式使用 RIFF 块，每个块由块标识符、块长度和块数据组成。</p>
<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>编码包括了两方面内容，一是按一定格式存储数据，二是采用一定的算法压缩数据。WAV 格式对音频流的编码没有硬性规定，支持非压缩的 PCM(Puls Code Modulation) 脉冲编码调制格式，还支持压缩型的微软自适应分脉冲编码调制 Microsoft ADPCM(Adaptive Differential Puls Code Modulation)、国际电报联盟 (International Telegraph Union) 制定的语音压缩标准 ITUG.711 a-law、ITU G.711-law、IMA ADPCM、ITU G.723 ADPCM (Yamaha)、GSM 6.10、ITU G.721 ADPCM 编码和其它压缩算法。MP3 编码同样也可以运用在 WAV 中，只要安装相应的 Decode, 就可以播放 WAV 中的 MP3 音乐。</p>
<h3 id="PCM-格式"><a href="#PCM-格式" class="headerlink" title="PCM 格式"></a>PCM 格式</h3><p>PCM 编码是直接存储声波采样被量化后所产生的非压缩数据，故被视为单纯的无损耗编码格式，其优点是可获得高质量的音频信号。<br>基于 PCM 编码的 WAV 格式是最基本的 WAV 格式，被声卡直接支持，能直接存储采样的声音数据，所存储的数据能直接通过声卡播放，还原的波形曲线与原始声音波形十分接近，播放的声音质量是一流的，在 Windows 平台下被支持得最好，常常被用作在其它编码的文件之间转换的中间文件。PCM 的缺点是文件体积过大，不适合长时间记录。正因为如此，又出现了多种在 PCM 编码的基础上经改进发展起来的编码格式，如：DPCM,ADPCM 编码等。</p>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>WAV 文件采用的是 RIFF 格式结构，WAV 文件有一个主 RIFF 块，它包括一个 Wave 标识符，后跟一个子块。数据以低位字节顺序存储。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129203223281.png"></p>
<p>fmt 块指定数据的格式。采样数据的格式块有 3 种，这些不同于基本 fmt 块。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129203423952.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129203658167.png"></p>
<p>非 PCM 格式必须 fact 块。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129203929926.png"></p>
<p>data 块包含采样数据。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204019646.png"></p>
<p>example：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204057463.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204127190.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204556302.png"></p>
<p>如果采样数据是 PCM 格式，则通常可以省略 fact 块。</p>
<p>整体来说如下图概括</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204302173.png"></p>
<p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WAV_HEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ChunkID[<span class="number">4</span>];                 <span class="comment">// &quot;RIFF&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkSize;          <span class="comment">// 文件长度(WAVE文件的大小, 不含前8个字节)</span></span><br><span class="line">    <span class="keyword">char</span> Format[<span class="number">4</span>];                  <span class="comment">// &quot;WAVE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk1ID[<span class="number">4</span>];             <span class="comment">// &quot;fmt &quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk1Size;      <span class="comment">// 过渡字节(不定)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> AudioFormat;  <span class="comment">// 格式类别(10H为PCM格式的声音数据)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> NumChannels;  <span class="comment">// 通道数(单声道为1, 双声道为2)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SampleRate;         <span class="comment">// 采样率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ByteRate;           <span class="comment">// 波形音频数据传输速率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BlockAlign;   <span class="comment">// data数据块长度、字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BitsPerSample;<span class="comment">// PCM 位宽</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk2ID[<span class="number">4</span>];             <span class="comment">// &quot;data&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk2Size;      <span class="comment">// data数据的长度</span></span><br><span class="line">    &#125; WAV_HEADER;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">Audio File Format Specifications</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Audio</category>
      </categories>
      <tags>
        <tag>Audio</tag>
        <tag>wav</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome Alliswell‘s Wiki Site</title>
    <url>/wiki/welcome/</url>
    <content><![CDATA[<p>这里是 Alliswell 的个人Wiki站点，主要是为了记录个人的一些想法，为自己折腾过的东西留下些痕迹。</p>
<p>我认为掌握知识是一个<strong>积累</strong>的过程，由<strong>碎片化的吸收组建结构化的知识体系</strong>。我希望这个过程是高效的，优雅的，在尝试OneNote、Evernote等方式后，我总结了自己掌握知识的流程：</p>
<ol>
<li>通过网页、手机App等媒体渠道获得知识来源。</li>
<li>通过手写、手机note记录等收藏记录初步信息。</li>
<li>在记录到一定量时，用专门时间进行总结归纳，加上自己的理解，完善形成文章发表在博客上。</li>
</ol>
<p>之前也尝试过功能强大的<strong>Next</strong>、简洁的<strong>3-hexo</strong>、<strong>tree</strong>等主题，都不如人意。有些部署配置麻烦，有些界面太丑，有些不能分级等等。再尝试了<strong>Wikiteen</strong>后满足了我的个人WIki要求, 即：</p>
<ul>
<li>界面简洁美观</li>
<li>多级目录，可手动展开收缩</li>
<li>全文搜索</li>
<li>部署简单，方便备份</li>
</ul>
<p>之前多多少少的尝试搭建过一些博客，但是由于不能满足自己需要贴代码等需求而作罢, 希望这个博客和我能坚持下去。</p>
]]></content>
  </entry>
  <entry>
    <title>zsh快捷键</title>
    <url>/wiki/zsh%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<ul>
<li>⌃ + a：移动到行首</li>
<li>⌃ + e：移动到行尾</li>
<li>⌃ + f：向前移动</li>
<li>⌃ + b：向后移动</li>
<li>⌃ + p：上一条命令</li>
<li>⌃ + n：下一条命令</li>
<li>⌃ + r：搜索历史命令</li>
<li>⌃ + y：召回最近用命令删除的文字</li>
<li>⌃ + h：删除光标之前的字符</li>
<li>⌃ + d：删除光标所指的字符</li>
<li>⌃ + w：删除光标之前的单词</li>
<li>⌃ + k：删除从光标到行尾的内容</li>
<li>⌃ + t：交换光标和之前的字符</li>
</ul>
]]></content>
      <categories>
        <category>zsh</category>
      </categories>
      <tags>
        <tag>zsh</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>三种存储类型</title>
    <url>/wiki/%E4%B8%89%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Storage-Research"><a href="#Storage-Research" class="headerlink" title="Storage Research"></a>Storage Research</h1><h2 id="块存储"><a href="#块存储" class="headerlink" title="块存储"></a>块存储</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>最底层的数据组织方式，所有数据按照固定的大小分块写入，每一块赋予一个用于寻址的编号。</p>
<h3 id="应用方式："><a href="#应用方式：" class="headerlink" title="应用方式："></a>应用方式：</h3><ol>
<li>为了方便管理，硬盘这样的块设备通常可以划分为多个逻辑块设备，也就是我们熟悉的硬盘分区（Partition）。</li>
<li>单个介质的容量、性能有限，可以通过某些技术手段把多个物理块设备组合成一个逻辑块设备，例如各种级别的RAID，JBOD，某些操作系统的卷管理系统（Volume Manager）如Windows的动态磁盘、Linux的LVM等。</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>这种方式的好处当然是因为通过了Raid与LVM等手段，对数据提供了保护；</li>
<li>可以将多块廉价的硬盘组合起来，称为一个大容量的逻辑盘对外提供服务，提高了容量；</li>
<li>写入数据时，由于是多块磁盘组合出来的逻辑盘，所以几块硬盘可以并行写入的，提升了读写效率；</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>主机之间数据无法共享，在服务器不做集群的情况下，块存储裸盘映射给主机，在格式化使用后，对于主机来说相当于本地盘，那么主机A的本地盘根本不能给主机B去使用，无法共享数据</li>
<li>无目录系统</li>
</ol>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>用“文件”这个概念对这些数据进行组织，所有用于同一用途的数据，按照不同应用程序要求的结构方式组成不同类型的文件（通常用不同的后缀来指代不同的类型），然后我们给每一个文件起一个方便理解记忆的名字。而当文件很多的时候，我们按照某种划分方式给这些文件分组，每一组文件放在同一个目录（或者叫文件夹）里面，当然我们也需要给这些目录起一个容易理解和记忆的名字。而且目录下面除了文件还可以有下一级目录（称之为子目录或者子文件夹），所有的文件、目录形成一个树状结构</p>
<h3 id="应用方式：-1"><a href="#应用方式：-1" class="headerlink" title="应用方式："></a>应用方式：</h3><p>把存储介质上的数据组织成目录-子目录-文件这种形式的数据结构，用于从这个结构中寻找、添加、修改、删除文件的程序，以及用于维护这个结构的程序，组成的系统有一个专用的名字：<strong>文件系统（File System）</strong></p>
<p>文件系统有很多，常见的有Windows的FAT/FAT32/NTFS，Linux的EXT2/EXT3/EXT4/XFS/BtrFS等。而在网络存储中，底层数据并非存储在本地的存储介质，而是另外一台服务器上，不同的客户端都可以用类似文件系统的方式访问这台服务器上的文件，这样的系统叫<strong>网络文件系统（Network File System）</strong>，常见的网络文件系统有Windows网络的CIFS（也叫SMB）、类Unix系统网络的NFS等。而文件存储除了网络文件系统外，FTP、HTTP其实也算是文件存储的某种特殊实现，都是可以通过某个url来访问一个文件。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>有目录检索，用户友好。</li>
<li>方便共享。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>读写速度较慢，因为需要遍历树状目录结构。</li>
</ol>
<h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>对象存储一般体现形式是一个ID，数据和元数据打包在一起作为一个整体对象存在一个超大池子里。对于对象访问，只需要报出它的ID，就能立即找到它，但访问的时候对象是作为一个整体访问的。</p>
<h3 id="应用方式：-2"><a href="#应用方式：-2" class="headerlink" title="应用方式："></a>应用方式：</h3><ul>
<li>大多数对象存储的实现本质上是键值对存储系统</li>
<li>采用扁平化的管理方式(根据键，找到值)<strong>无层次结构</strong></li>
<li>值可以是任何东西，可以是小文件(小二进制片段)，可以是大文件</li>
</ul>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>对象存储将元数据独立了出来，控制节点叫元数据服务器（服务器+对象存储管理软件），里面主要负责存储对象的属性（主要是对象的数据被打散存放到了那几台分布式服务器中的信息），而其他负责存储数据的分布式服务器叫做OSD，主要负责存储文件的数据部分。当用户访问对象，会先访问元数据服务器，元数据服务器只负责反馈对象存储在哪些OSD，假设反馈文件A存储在B、C、D三台OSD，那么用户就会再次直接访问3台OSD服务器去读取数据。</p>
<p>这时候由于是3台OSD同时对外传输数据，所以传输的速度就加快了。当OSD服务器数量越多，这种读写速度的提升就越大，通过此种方式，实现了<strong>读写快</strong>的目的。</p>
<p>另一方面，对象存储软件是有专门的文件系统的，所以OSD对外又相当于<strong>文件服务器</strong>，那么就不存在文件共享方面的困难了，也解决了文件共享方面的问题。</p>
<p>所以对象存储的出现，很好地结合了块存储与文件存储的优点。</p>
<p>对象存储的无层次结构特点，对象存储有以下优点：</p>
<ul>
<li>效率更高。不受复杂目录系统对性能的影响。</li>
<li>可扩展性更强。分布式架构，更便于进行水平扩展，从而容纳进任意大规模的数据。</li>
<li>可用性更强。数据一般都会有多个位于不同机器的复制，确保数据不丢失。</li>
</ul>
<h2 id="三种存储类型的联系"><a href="#三种存储类型的联系" class="headerlink" title="三种存储类型的联系"></a>三种存储类型的联系</h2><p>块存储、文件存储、对象存储的关系：</p>
<ol>
<li>它们就是不同的接口。块存储就是最接近存储介质的接口，也就是包装最薄的，或者说没有包装。文件和对象存储都是对块存储的包装。可以简单认为对象存储就是不分层次的文件存储。</li>
</ol>
<p>分布式存储的应用场景相对于其存储接口，现在流行分为三种:</p>
<ol>
<li>对象存储: 也就是通常意义的键值存储，其接口就是简单的GET、PUT、DEL和其他扩展，如七牛、又拍、Swift、S3</li>
<li>块存储: 这种接口通常以QEMU Driver或者Kernel Module的方式存在，这种接口需要实现Linux的Block Device的接口或者QEMU提供的Block Driver接口，如Sheepdog，AWS的EBS，青云的云硬盘和阿里云的盘古系统，还有Ceph的RBD（RBD是Ceph面向块存储的接口）</li>
<li>文件存储: 通常意义是支持POSIX接口，它跟传统的文件系统如Ext4是一个类型的，但区别在于分布式存储提供了并行化的能力，如Ceph的CephFS(CephFS是Ceph面向文件存储的接口)，但是有时候又会把GFS，HDFS这种非POSIX接口的类文件存储接口归入此类。</li>
</ol>
<p>元数据管理的差别: </p>
<ol>
<li>块存储，服务端不维护元数据，服务端只保留blockid到block的映射关系。</li>
<li>对象存储，保存简单的元数据，为了管理和隔离，加入了volumn bucket等概念。最根本的存储方面，实际上是以key value形式组织的。其中key之间没有关联，value是block序列组成的对象。</li>
<li>文件存储的元数据相对对象存储元数据更加复杂，元数据以目录树(inode tree)的形式管理，每个inode tree的文件节点对应一个value是block序列组成的文件。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/21536660">https://www.zhihu.com/question/21536660</a></li>
<li><a href="https://www.cnblogs.com/hukey/p/8323853.html">https://www.cnblogs.com/hukey/p/8323853.html</a></li>
<li><a href="https://www.redhat.com/zh/topics/data-storage/file-block-object-storage">https://www.redhat.com/zh/topics/data-storage/file-block-object-storage</a></li>
<li><a href="https://help.aliyun.com/document_detail/63136.html">https://help.aliyun.com/document_detail/63136.html</a></li>
<li><a href="https://help.aliyun.com/document_detail/140812.html?spm=a2c4g.11186623.6.543.460845d7sDlUAA">https://help.aliyun.com/document_detail/140812.html?spm=a2c4g.11186623.6.543.460845d7sDlUAA</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>存储</tag>
        <tag>块存储</tag>
        <tag>对象存储</tag>
        <tag>文件存储</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树相关</title>
    <url>/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉搜索树的相关操作"><a href="#二叉搜索树的相关操作" class="headerlink" title="二叉搜索树的相关操作"></a>二叉搜索树的相关操作</h1><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">//有相同节点则数量加一</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//养成写clean code的习惯</span></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(data);  <span class="comment">//判空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == root-&gt;data) root-&gt;count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data);</span><br><span class="line">    <span class="keyword">if</span> (data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 升序输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *root)</span> </span>&#123;  <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="function">Node *<span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">NULL</span> || root-&gt;data == data</span><br><span class="line">               ? root</span><br><span class="line">               : search(data &lt; root-&gt;data ? root-&gt;left : root-&gt;right, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">Node *_minNode(Node *node);</span><br><span class="line"><span class="function">Node *<span class="title">deleteNode</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data &lt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; root-&gt;data) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// data==root-&gt;data. delete the current node</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *minNode = _minNode(root-&gt;right);</span><br><span class="line">        root-&gt;data = minNode-&gt;data;  <span class="comment">//拷贝过去。再删除右子树重复节点</span></span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, minNode-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搜索最小节点</span></span><br><span class="line">Node *_minNode(Node *node) &#123;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;  <span class="comment">//利用平衡二叉树特性</span></span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL:Cannot find.&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *root = <span class="keyword">new</span> Node(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         50</span></span><br><span class="line"><span class="comment">        /  \</span></span><br><span class="line"><span class="comment">       30   70</span></span><br><span class="line"><span class="comment">      /  \  / \</span></span><br><span class="line"><span class="comment">    20   40 60 80</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    insert(root, <span class="number">30</span>);</span><br><span class="line">    insert(root, <span class="number">20</span>);</span><br><span class="line">    insert(root, <span class="number">40</span>);</span><br><span class="line">    insert(root, <span class="number">70</span>);</span><br><span class="line">    insert(root, <span class="number">60</span>);</span><br><span class="line">    insert(root, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inorder traversal: &quot;</span>;</span><br><span class="line">    inorder(root);  <span class="comment">//升序输出</span></span><br><span class="line"></span><br><span class="line">    printNode(search(root, <span class="number">20</span>));</span><br><span class="line">    printNode(search(root, <span class="number">100</span>));</span><br><span class="line">    printNode(search(root, <span class="number">-20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    root = deleteNode(root, <span class="number">20</span>);</span><br><span class="line">    inorder(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    root = deleteNode(root, <span class="number">100</span>);</span><br><span class="line">    inorder(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    root = deleteNode(root, <span class="number">50</span>);</span><br><span class="line">    inorder(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出</span></span><br><span class="line">Inorder traversal: <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="literal">NULL</span>:Cannot find.</span><br><span class="line"><span class="literal">NULL</span>:Cannot find.</span><br><span class="line"><span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span></span><br><span class="line"><span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span></span><br><span class="line"><span class="number">30</span> <span class="number">40</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>BST</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树的三种遍历及实例"><a href="#二叉树的三种遍历及实例" class="headerlink" title="二叉树的三种遍历及实例"></a>二叉树的三种遍历及实例</h1><p>二叉树是每个节点最多有两个子树的有序树。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree），是一个连通的无环图，并且每一个顶点的度不大于 3。二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分。二叉树的第<code>i</code>层至多有<code>2^ (i -1)</code>个结点；深度为<code>k</code>的二叉树至多有<code>2^(k) -1</code>个结点；对任何一棵二叉树 T，如果其终端结点数（即叶子结点数）为<code>n0</code>，度为 2 的结点数为<code>n2</code>，则<code>n0 = n2 + 1</code>。</p>
<a id="more"></a>

<p>二叉树的<strong>链式存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BiNode *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Node *Tree;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序序列创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateTree</span><span class="params">(Tree &amp;T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="comment">//先序序列输入节点值，#为空</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//建立根</span></span><br><span class="line">        T = <span class="keyword">new</span> Node;</span><br><span class="line">        T-&gt;data = data;</span><br><span class="line">        <span class="comment">//建立左子树</span></span><br><span class="line">        CreateTree(T-&gt;lchild);</span><br><span class="line">        <span class="comment">//建立右子树</span></span><br><span class="line">        CreateTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：必须为先序输入，如：<code>ABE##F##CG###</code></p>
<img src="https://gitee.com/SunGitee/src/raw/master/img/image-20200317172628925.png" alt="image-20200317172628925" style="zoom:50%;" />

<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先根遍历，根 -&gt;左 -&gt;右</p>
<p>若二叉树为空则结束返回，否则：</p>
<p> （1）访问根结点</p>
<p> （2）前序遍历左子树</p>
<p> （3）前序遍历右子树</p>
<p>遍历左右子树时仍然采用前序遍历方法</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中根遍历，左 -&gt;根 -&gt;右。</p>
<p>若二叉树为空则结束返回，否则：</p>
<p>（1）中序遍历左子树</p>
<p>（2）访问根结点</p>
<p>（3）中序遍历右子树。</p>
<p>遍历左右子树时仍然采用中序遍历方法</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后根遍历，左 -&gt;右 -&gt;根。</p>
<p>若二叉树为空则结束返回，否则：</p>
<p>（1）后序遍历左子树。</p>
<p>（2）后序遍历右子树。</p>
<p>（3）访问根结点。</p>
<p>遍历左右子树时仍然采用后序遍历方法。</p>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>按照从上至下，从左至右的顺序遍历二叉树。</p>
<hr>
<img src="https://gitee.com/SunGitee/src/raw/master/img/image-20200317173247719.png" alt="image-20200317173247719" style="zoom:50%;" />

<p>如上图所示二叉树</p>
<p>前序遍历，也叫先根遍历，遍历的顺序是，根，左子树，右子树</p>
<p>遍历结果：A,B,E,F,C,G</p>
<p>中序遍历，也叫中根遍历，顺序是 左子树，根，右子树</p>
<p>遍历结果：E,B,F,A,G,C</p>
<p>后序遍历，也叫后根遍历，遍历顺序，左子树，右子树，根</p>
<p>遍历结果：E,F,B,G,C,A</p>
<hr>
<h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    Node *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Node *Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序序列创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateTree</span><span class="params">(Tree &amp;T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="comment">//先序序列输入节点值，#为空</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//建立根</span></span><br><span class="line">        T = <span class="keyword">new</span> Node;</span><br><span class="line">        T-&gt;data = data;</span><br><span class="line">        <span class="comment">//建立左子树</span></span><br><span class="line">        CreateTree(T-&gt;lchild);</span><br><span class="line">        <span class="comment">//建立右子树</span></span><br><span class="line">        CreateTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNode</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************递归************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printNode(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        printNode(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        printNode(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">************************非递归************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">访问T-&gt;data后，将T入栈，遍历左子树；遍历完左子树</span></span><br><span class="line"><span class="comment">返回时，栈顶元素应为T，出栈，再先序遍历T的右子树。其实每次都是</span></span><br><span class="line"><span class="comment">走树的左分支(left)，直到左子树为空，然后开始从递归的最深处返回，</span></span><br><span class="line"><span class="comment">然后开始恢复递归现场，访问右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder2</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">// p为遍历指针</span></span><br><span class="line">    Tree p = T;</span><br><span class="line">    <span class="comment">//栈不空时或者p不空时循环</span></span><br><span class="line">    <span class="keyword">while</span> (p || !<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(p);</span><br><span class="line">            printNode(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先将T入栈，遍历左子树；遍历完左子树返回时，栈顶元素应为T，</span></span><br><span class="line"><span class="comment">出栈，访问T-&gt;data，再中序遍历T的右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; <span class="built_in">stack</span>;</span><br><span class="line">    Tree p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = <span class="built_in">stack</span>.top();</span><br><span class="line">            printNode(p);</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路一：需要判断根结点的左右子树是否均遍历过。</span></span><br><span class="line"><span class="comment">思路二：根据 &quot;根-右-左&quot; 的顺序压入另一个栈(打印用)，压完之后，</span></span><br><span class="line"><span class="comment">打印这个栈的顺序就是相反的&quot;左-右-根&quot; 刚好就是后序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//思路二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder2</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree&gt; output;</span><br><span class="line">    <span class="comment">// p为遍历指针</span></span><br><span class="line">    Tree p = T;</span><br><span class="line">    <span class="comment">//栈不空时或者p不空时循环</span></span><br><span class="line">    <span class="keyword">while</span> (p || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            output.push(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (output.size()) &#123;</span><br><span class="line">        printNode(output.top());</span><br><span class="line">        output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按从顶向下，从左至右的顺序来逐层访问每个节点，层次遍历的过程中需要用队列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(Tree T)</span> </span>&#123;</span><br><span class="line">    Tree p = T;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Tree&gt; Tqueue;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Tqueue.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Tqueue.empty()) &#123;</span><br><span class="line">        p = Tqueue.front();</span><br><span class="line">        printNode(p);</span><br><span class="line">        Tqueue.pop();</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Tqueue.push(p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Tqueue.push(p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输入ABE##F##CG###</span></span><br><span class="line">    Tree root;</span><br><span class="line">    CreateTree(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历-递归:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PreOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;先序遍历-非递归:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PreOrder2(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历-递归:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    InOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中序遍历-非递归:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    InOrder2(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历-递归:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PostOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;后序遍历-非递归:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PostOrder2(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;层序遍历:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    LevelOrder(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ABE##F##CG###</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">先序遍历-递归:</span></span><br><span class="line"><span class="comment">A B E F C G</span></span><br><span class="line"><span class="comment">先序遍历-非递归:</span></span><br><span class="line"><span class="comment">A B E F C G</span></span><br><span class="line"><span class="comment">中序遍历-递归:</span></span><br><span class="line"><span class="comment">E B F A G C</span></span><br><span class="line"><span class="comment">中序遍历-非递归:</span></span><br><span class="line"><span class="comment">E B F A G C</span></span><br><span class="line"><span class="comment">后序遍历-递归:</span></span><br><span class="line"><span class="comment">E F B G C A</span></span><br><span class="line"><span class="comment">后序遍历-非递归:</span></span><br><span class="line"><span class="comment">E F B G C A</span></span><br><span class="line"><span class="comment">层序遍历:</span></span><br><span class="line"><span class="comment">A B C E F G</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>二叉树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>使用openmp进行多线程编程</title>
    <url>/wiki/%E4%BD%BF%E7%94%A8openmp%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>转载:<a href="https://blog.csdn.net/acaiwlj/article/details/49818965">https://blog.csdn.net/acaiwlj/article/details/49818965</a></p>
<blockquote>
<p>声明：本文是基于Joel Yliluoma写的Guid into OpenMP:Easy multithreading programming for C++而写的，基本是按照自己的理解，用自己语言组织的。其中大部分例子依然用原来文章的例子，本文仅作为学习笔记之用。</p>
</blockquote>
<p>前言<br>多线程在实际的编程中的重要性不言而喻。对于C++而言，当我们需要使用多线程时，可以使用boost::thread库或者自从C++ 11开始支持的std::thread，也可以使用操作系统相关的线程API，如在Linux上，可以使用pthread库。除此之外，还可以使用omp来使用多线程。它的好处是跨平台，使用简单。<br>在Linux平台上，如果需要使用omp，只需在编译时使用”-fopenmp”指令。在Windows的visual studio开发环境中，开启omp支持的步骤为“项目属性 -&gt; C/C++ -&gt; 所有选项 -&gt; openmp支持 -&gt; 是(/openmp)”。<br>本文我们就介绍omp在C++中的使用方法。<br>c++ openmp入门简介<br>openmp是由一系列#paragma指令组成，这些指令控制如何多线程的执行程序。另外，即使编译器不支持omp，程序也也能够正常运行，只是程序不会多线程并行运行。以下为使用omp的简单的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vecInt</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecInt.size(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    vecInt[i] = i*i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Multi-threads</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>openmp</tag>
      </tags>
  </entry>
  <entry>
    <title>华为技术面记录</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>刚刚完华为二面，要记录一下。</p>
</blockquote>
<a id="more"></a>

<p>首先就是和 Hr 约的 8 点，不知道是沟通没到位还是怎么样，到 9 点多才接到面试官电话。不过面试官姐姐还是很不错，蛮专业的。// 怀疑是刚下班就来面试。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-介绍下自己，谈谈最这个岗位的匹配度。"><a href="#1-介绍下自己，谈谈最这个岗位的匹配度。" class="headerlink" title="1. 介绍下自己，谈谈最这个岗位的匹配度。"></a>1. 介绍下自己，谈谈最这个岗位的匹配度。</h4><p>第一次面试太紧张了，完全忽视了说明如何匹配岗位。</p>
<h4 id="2-说一下“高内聚、低耦合”的理解。"><a href="#2-说一下“高内聚、低耦合”的理解。" class="headerlink" title="2. 说一下“高内聚、低耦合”的理解。"></a>2. 说一下“高内聚、低耦合”的理解。</h4><p>// 一来就是经常见到但是就是没法准确描述的词，难受呀。</p>
<p>首先搞清楚模块是什么</p>
<p>模块就是从系统层次去分成不同的部分，每个部分就是一个模块！ 分而治之， 将大型系统的复杂问题，分成不同的小模块，去处理问题！</p>
<p><strong>耦合</strong>：主要是讲模块与模块之间的联系，</p>
<p><strong>内聚</strong>：主要指的是模块内部【东西聚合在一起形成了一个模块】例如方法，变量，对象，或者是功能模块</p>
<p>什么是耦合</p>
<p>模块与模块之间有写操作是有关联的， 如果改动一个木块其他的木块都有可能受到影响，模块与模块之间的关系越是紧密，独立性就越不好！</p>
<p>例如：如果模块 1 直接操作了木块 2 红的数据，这种操作模块与模块之间就为强耦合，甚至可以认为这种情况之下基本算没有分模块！如果 1 只是通过数据与 2 模块交互，这种我们称之为弱耦合！微服务独立的模块，方便去维护，或者写单元测试等等。.. 如果木块之间的依赖非常严重，将会非常不易于维护。</p>
<p><img src="https://img-blog.csdnimg.cn/20190624182415701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbGxhaW55MTM1Nzk=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>内聚</p>
<p>模块内部的代码， 相互之间的联系越强，内聚就越高， 模块的独立性就越好。 一个模块应该尽量的独立，去完成独立的功能！如果有代码非得引入到独立的模块，建议拆分成多模块！低内聚的代码，不好维护，代码也不够健壮</p>
<p><img src="https://img-blog.csdnimg.cn/20190624182502202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpbGxhaW55MTM1Nzk=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>如下这些接口设计原则，就是参考低耦合高内聚</p>
<p>设计模式一般参照六大设计原则，许多的设计模式，包括一些框架，都是参考高内聚低耦合这个点的。</p>
<p>单一职责原则：一个类只负责一个功能的职责</p>
<p>开闭原则：扩展开放，修改关闭。</p>
<p>里氏代换原则：使用父类的地方都能使用子类对象</p>
<p>依赖倒转原则：针对接口编程，</p>
<p>接口隔离原则：针对不同部分用专门接口，不用总接口，需要哪些接口就用哪些接口</p>
<p>迪米特法则： 软件实体类，尽量不与其他实体类发生关系相互作用，对外都统一的暴露接口就行了</p>
<h4 id="3-说一下知道的设计模式"><a href="#3-说一下知道的设计模式" class="headerlink" title="3. 说一下知道的设计模式"></a>3. 说一下知道的设计模式</h4><p>常见的设计模式如下：</p>
<p><strong>1、单例模式</strong>：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<p><strong>在单例模式的实现中，如果不采取任何措施，在多线程下是不安全的</strong>，可能会同时创建多个实例。因此，为了保证单例模式在多线程下的线程安全，一般采用下面几种方式实现单例模式：</p>
<ol>
<li><p>饿汉式：基于 class loader 机制避免多线程的同步问题，不过，instance 在类装载时就实例化，可能会产生垃圾对象。</p>
</li>
<li><p>懒汉式：通过双重锁机制实现线程安全。</p>
</li>
</ol>
<p>使用锁机制，防止多次访问，可以这样，第一次判断为空不加锁，若为空，再进行加锁判断是否为空，若为空则生成对象。</p>
<p>更加详细请看</p>
<p><a href="https://blog.csdn.net/q5707802/article/details/79251148">https://blog.csdn.net/q5707802/article/details/79251148</a></p>
<p>优点：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p>
<p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p>实现：</p>
<p>单例模式要求类能够有返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常使用 getInstance 这个名称）。</p>
<p><strong>如何保证单例模式只有唯一实例</strong></p>
<p>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p>
<p>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p>
<p><strong>2、工厂模式</strong>：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。</p>
<p>优点</p>
<p>解耦，代码复用，更改功能容易。</p>
<p><strong>3、观察者模式</strong>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>4、装饰器模式</strong>：对已经存在的某些类进行装饰，以此来扩展一些功能，从而动态的为一个对象增加新的功能。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>缺点：多层装饰比较复杂。</p>
<p>使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<h4 id="4-说一下设计模式几大原则"><a href="#4-说一下设计模式几大原则" class="headerlink" title="4. 说一下设计模式几大原则"></a>4. 说一下设计模式几大原则</h4><p><strong>1、单一职责原则</strong></p>
<p>一个类只负责一个功能的职责</p>
<p>单一职责有 2 个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。</p>
<p><strong>2、接口隔离原则</strong></p>
<p>针对不同部分用专门接口，不用总接口，需要哪些接口就用哪些接口</p>
<p>表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额外方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。</p>
<p>该原则观点如下：<br>        1）一个类对另外一个类的依赖性应当是建立在最小的接口上</p>
<p>2）客户端程序不应该依赖它不需要的接口方法。</p>
<p><strong>3、开放 - 封闭原则</strong></p>
<p>扩展开放，修改关闭</p>
<p>open 模块的行为必须是开放的、支持扩展的，而不是僵化的。</p>
<p>closed 在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。</p>
<p>核心思想就是对抽象编程，而不对具体编程。</p>
<p><strong>4、替换原则</strong></p>
<p>使用父类的地方都能使用子类对象</p>
<p>子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。</p>
<p>主要针对继承的设计原则</p>
<p>1）父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中生命的方法，而不应当给出多余的，方法定义或实现。</p>
<p>2）在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期间绑定。</p>
<p><strong>5、依赖倒置原则</strong></p>
<p>针对接口编程，</p>
<p>上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。</p>
<p>抽象不能依赖于具体，具体应该要依赖于抽象。</p>
<p><strong>6、迪米特法则</strong></p>
<p> 软件实体类，尽量不与其他实体类发生关系相互作用，对外都统一的暴露接口就行了</p>
<p>// 可能也是看出来我对软件工程方面不是很熟悉，开始问其他方面</p>
<h4 id="5-你对算法数据结构了解多一点是吧，那你说下链表相关的吧，和数组对比"><a href="#5-你对算法数据结构了解多一点是吧，那你说下链表相关的吧，和数组对比" class="headerlink" title="5. 你对算法数据结构了解多一点是吧，那你说下链表相关的吧，和数组对比"></a>5. 你对算法数据结构了解多一点是吧，那你说下链表相关的吧，和数组对比</h4><h4 id="6-再说下队列相关吧"><a href="#6-再说下队列相关吧" class="headerlink" title="6. 再说下队列相关吧"></a>6. 再说下队列相关吧</h4><h4 id="7-说一下线程和进程"><a href="#7-说一下线程和进程" class="headerlink" title="7. 说一下线程和进程"></a>7. 说一下线程和进程</h4><h4 id="8-说一下如果要两个进程要操作同一段内存，应该怎么处理"><a href="#8-说一下如果要两个进程要操作同一段内存，应该怎么处理" class="headerlink" title="8. 说一下如果要两个进程要操作同一段内存，应该怎么处理"></a>8. 说一下如果要两个进程要操作同一段内存，应该怎么处理</h4><p>自己答的：使用 1）开关中断，2）使用 <del>型号量</del> 信号量机制</p>
<h4 id="9-对操作系统还熟悉吧，说一下什么情况下造成死锁"><a href="#9-对操作系统还熟悉吧，说一下什么情况下造成死锁" class="headerlink" title="9. 对操作系统还熟悉吧，说一下什么情况下造成死锁"></a>9. 对操作系统还熟悉吧，说一下什么情况下造成死锁</h4><p>互斥、不可剥夺、请求和保持、循环等待</p>
<p>// 感觉虽然的确是在回答，就是不是很准确。</p>
<h4 id="10-调制解调了解吗，通信工程相关内容"><a href="#10-调制解调了解吗，通信工程相关内容" class="headerlink" title="10. 调制解调了解吗，通信工程相关内容"></a>10. 调制解调了解吗，通信工程相关内容</h4><p>不了解。</p>
<h4 id="11-Linux-系统会使用吗？"><a href="#11-Linux-系统会使用吗？" class="headerlink" title="11. Linux 系统会使用吗？"></a>11. Linux 系统会使用吗？</h4><p>使用过一段时间，会基本操作</p>
<h4 id="12-除了-C-C-还掌握例如-Python-之类的语言吗？"><a href="#12-除了-C-C-还掌握例如-Python-之类的语言吗？" class="headerlink" title="12. 除了 C/C++ 还掌握例如 Python 之类的语言吗？"></a>12. 除了 C/C++ 还掌握例如 Python 之类的语言吗？</h4><p>暂时不太会，一直有计划去学习。</p>
<h4 id="13-代码量大概有多少"><a href="#13-代码量大概有多少" class="headerlink" title="13. 代码量大概有多少"></a>13. 代码量大概有多少</h4><p>没有算过，大概有几万吧。大学期间帮导师写过一些小项目的。</p>
<h4 id="14-你简历上写的路面材料试验是什么"><a href="#14-你简历上写的路面材料试验是什么" class="headerlink" title="14. 你简历上写的路面材料试验是什么"></a>14. 你简历上写的路面材料试验是什么</h4><p>研究的新型路面材料，用的沥青等等。</p>
<hr>
<h4 id="15-你还有什么问我的"><a href="#15-你还有什么问我的" class="headerlink" title="15. 你还有什么问我的"></a>15. 你还有什么问我的</h4><p>下面就是开始和面试官姐姐聊聊天了，问了下对华为公司文化的理解、能否接受等。</p>
<p>然后介绍了一下岗位主要内容，这里才解释给我说刚才为什么问那些问题，现在成都这边做的 5G 设备相关，几个方面——软件、硬件、业务方面。软件就是要求对设计模式等的要求，大公司有标准的规范，因此比较看重。另外，也是需要经常和硬件打交道，主要是芯片。所以需要对底层有一定了解，开关中断什么的。然后就是业务，就是看对语法、基础数据结构的掌握。</p>
<p>然后还说了下，我这是第一次工作面试。想问问简历和这次面试的建议和提升的地方。面试官姐姐也给写建议。</p>
<p>总的感觉，这次问的问题应该都是比较基础的问题，也没有手撕代码，但是表现一般，刚开始蛮紧张的，然后后面算法、数据结构、操作系统方面的答的还可以，但是通讯和软件工程的一些没有学过的内容就很懵逼。也不知道能不能过，什么时候通知。希望能过。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>面试</tag>
        <tag>技术面</tag>
        <tag>二面</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试 01</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%9501/</url>
    <content><![CDATA[<h1 id="勾股定理"><a href="#勾股定理" class="headerlink" title="勾股定理"></a>勾股定理</h1><p>如果三个正整数 (a,b,c) 满足 a^2+b^2=c^2 的关系，则称 (a,b,c) 为勾股数，为了探索规律，定义如果 (a,b,c) 之间两两互质，则为勾股数元祖（例如 (3,4,5) 是，(6,8,10) 则不是）。</p>
<p>请求出给定范围 [N,M] 内，所有勾股数元祖。</p>
<a id="more"></a>

<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>N 属于 [1,200]<br>M 属于 (N,M];</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><ol>
<li>(a,b,c) 请保证 a&lt;b&lt;c, 输出格式：a b c;</li>
<li>多组勾股数元祖按照 a 升序，b 升序，最后 c 升序的方式排序输出；</li>
<li>给定范围内找不到勾股数元祖，输出”NA”。</li>
</ol>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol>
<li>[N,M] 范围表示 a,b,c 均在范围内。</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">12</span> <span class="number">13</span></span><br><span class="line"><span class="number">8</span> <span class="number">15</span> <span class="number">17</span></span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>缺少测试样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2最大公因数为1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">maxNum2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">            a = a - b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">            b = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3最大公因数为1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">maxNum3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxNum2(a, b) &amp;&amp; maxNum2(a, c) &amp;&amp; maxNum2(b, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a * a + b * b == c * c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= m<span class="number">-2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxNum2(i, j)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxNum3(i, j, k) &amp;&amp; judge(i, j, k)) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
        <tag>勾股定理</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试 02</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%9502/</url>
    <content><![CDATA[<p>将任意年月第几周的周几转化为公历日期</p>
<p><code>2020 02 2 5  --&gt;  2020 02 07</code></p>
<p>有异常处理例如：</p>
<ul>
<li>第 8 周周一，非法</li>
<li>某些周没有周一，或者没有周六，非法</li>
</ul>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgeLeapYear</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">100</span> != <span class="number">0</span>) || i % <span class="number">400</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgeW</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (day % <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            d1 = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            d1 = <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            d1 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            d1 = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            d1 = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            d1 = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            d1 = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;y, &amp;m, &amp;w, &amp;d);</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">1</span> || m &gt; <span class="number">12</span> || w &lt; <span class="number">1</span> || w &gt; <span class="number">5</span> || d &lt; <span class="number">1</span> || d &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2000</span>; i &lt;= y - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (judgeLeapYear(i)) &#123;</span><br><span class="line">            day += <span class="number">366</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            day += <span class="number">365</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> day2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; judgeLeapYear(y)) &#123;</span><br><span class="line">            day2 += <span class="number">29</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            day2 += <span class="number">28</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">3</span> || i == <span class="number">5</span> || i == <span class="number">7</span> || i == <span class="number">8</span> || i == <span class="number">10</span> ||</span><br><span class="line">                   i == <span class="number">12</span>) &#123;</span><br><span class="line">            day2 += <span class="number">31</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            day2 += <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d1 = judgeW(day + day2);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; d1 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; d1) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        d2 = d;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        d2 = <span class="number">7</span> - d1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            d2 += <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        d2 += d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %02d %02d&quot;</span>, y, m, d2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试 03</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%9503/</url>
    <content><![CDATA[<p>给定两行不为空字符串，第一行包含空格或者 Tab, 第二行不包含。</p>
<p>查找第二行在第一行出现的次数（匹配时忽略空白）</p>
<a id="more"></a>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Abb ba</span></span><br><span class="line"><span class="attribute">bb</span></span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>2</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delSpace</span><span class="params">(<span class="built_in">string</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">&#x27; &#x27;</span> || a[i] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">            a.erase(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    getline(<span class="built_in">cin</span>, b);</span><br><span class="line">    delSpace(a);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size();) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = a.find(b, i);</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">-1</span>) &#123;</span><br><span class="line">            i = t + <span class="number">1</span>;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试 04</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%9504/</url>
    <content><![CDATA[<h3 id="事件推送"><a href="#事件推送" class="headerlink" title="事件推送"></a>事件推送</h3><p>数轴 x 有序序列 A,B, 不空。给定距离 R, 求满足下列条件的数对：</p>
<ul>
<li>Ai&lt;=Bj</li>
<li>Ai,Bj 距离小于等于 R, 如果找不到 R 范围内 Bj, 则列出最近一个 Bj, 仍找不到则放弃 Ai</li>
</ul>
<a id="more"></a>

<p>可不特意考虑排序输出。不是考察点。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">A</span>=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;,B=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;,R=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)(<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = s.find(<span class="string">&#x27;&#123;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">1</span>; s[i] != <span class="string">&#x27;&#125;&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            a.push_back(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">5</span>; s[i] != <span class="string">&#x27;&#125;&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            b.push_back(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = s.find(<span class="string">&#x27;R&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    R = s[i + <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> b_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = <span class="built_in">abs</span>(a[i] - b[j]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= b[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis &lt;= R) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>, a[i], b[j]);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dis &lt; min) &#123;</span><br><span class="line">                    min = dis;</span><br><span class="line">                    b_ = b[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>, a[i], b_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
        <tag>字符串</tag>
        <tag>事件推送</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试 05</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%9505/</url>
    <content><![CDATA[<h3 id="URL-拼接"><a href="#URL-拼接" class="headerlink" title="URL 拼接"></a>URL 拼接</h3><p>给定 URL 前缀和后缀，前缀结尾或者后缀开头没有<code>&#39;/&#39;</code>，则需要自动补齐，都有的话需要自动去重。</p>
<a id="more"></a>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">/a</span>,<span class="string">/b</span></span><br><span class="line"></span><br><span class="line"><span class="string">/a/</span>,<span class="string">/b</span></span><br><span class="line"></span><br><span class="line"><span class="string">/a</span>,b</span><br><span class="line"></span><br><span class="line">,</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/a/</span>b     <span class="regexp">//</span>前三个</span><br><span class="line"><span class="regexp">/        /</span><span class="regexp">/最后一个</span></span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="keyword">int</span> pos = s.find(<span class="string">&#x27;,&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s[pos - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        a = s.substr(<span class="number">0</span>, pos - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = s.substr(<span class="number">0</span>, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s[pos + <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        b = s.substr(pos + <span class="number">2</span>, s.size() - pos - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = s.substr(pos + <span class="number">1</span>, s.size() - pos - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
        <tag>字符串</tag>
        <tag>URL 拼接</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试 06</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%9506/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是 5 瓶，方法如下：先用 9 个空瓶子换 3 瓶汽水，喝掉 3 瓶满的，喝完以后 4 个空瓶子，用 3 个再换一瓶，喝掉这瓶满的，这时候剩 2 个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用 3 个空瓶子换一瓶满的还给老板。如果小张手上有 n 个空汽水瓶，最多可以换多少瓶汽水喝？</p>
<a id="more"></a>

<h5 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a><strong>输入描述：</strong></h5><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">输入文件最多包含<span class="number">10</span>组测试数据，每个数据占一行，仅包含一个正整数<span class="built_in">n</span>（<span class="number">1</span>&lt;=<span class="built_in">n</span>&lt;=<span class="number">100</span>），表示小张手上的空汽水瓶数。<span class="built_in">n</span>=<span class="number">0</span>表示输入结束，你的程序不应当处理这一行。</span><br></pre></td></tr></table></figure>

<h5 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a><strong>输出描述：</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。</span><br></pre></td></tr></table></figure>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">81</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">40</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我的，样例能过，有结果。</span></span><br><span class="line"><span class="comment">//很奇怪，牛客超出内存限制,没过？这也没多少呀。</span></span><br><span class="line"><span class="comment">//这就是差距呀，自己闷头一顿敲，大神直接num/2搞定。可恶~</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        num1 = a / <span class="number">3</span>;</span><br><span class="line">        num2 = a % <span class="number">3</span>;</span><br><span class="line">        count += num1;</span><br><span class="line">        a = num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : v) &#123;</span><br><span class="line">        judge(it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//评论区</span></span><br><span class="line"><span class="comment">//通过数学分析，最后获得的饮料数是总空瓶数整除2 。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m)&amp;&amp;m!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归。还是不太习惯使用递归呀，本来都意识到了，但心里还是不太愿意去使</span></span><br><span class="line"><span class="comment">//标准的最中规中矩的答案</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cot</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num / <span class="number">3</span> + cot(num / <span class="number">3</span> + num % <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; cot(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
        <tag>智力题</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试 07</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%9507/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N 个 1 到 1000 之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作（同一个测试用例里可能会有多组数据，希望大家能正确处理）。</p>
<a id="more"></a>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Input</span> <span class="variable">Param</span></span><br><span class="line"><span class="variable">n</span>               输入随机数的个数</span><br><span class="line"><span class="variable">inputArray</span>      <span class="variable">n</span>个随机整数组成的数组</span><br><span class="line"></span><br><span class="line"><span class="built_in">Return</span> <span class="built_in">Value</span></span><br><span class="line"><span class="variable">OutputArray</span>    输出处理后的随机整数</span><br><span class="line"></span><br><span class="line">注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//也没多想直接用了set,自己写的话也不复杂，简单题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="comment">// cin &gt;&gt; n;</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">            s.insert(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : s) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试 08</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%9508/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）</p>
<a id="more"></a>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h5 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a><strong>输入描述：</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个十六进制的数值字符串。</span><br></pre></td></tr></table></figure>

<h5 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a><strong>输出描述：</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出该数值的十进制字符串。</span><br></pre></td></tr></table></figure>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0xA</span></span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单题，c++自带特性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; hex &gt;&gt; t) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dec &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
      </tags>
  </entry>
  <entry>
    <title>华为正式机试</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E6%AD%A3%E5%BC%8F%E6%9C%BA%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>刚刚完成华为正式机试，趁着热乎，记录一下。</p>
</blockquote>
<hr>
<a id="more"></a>

<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>按着 HR 发的链接，登录牛客进行机试。</li>
<li>准备摄像头，要求全程录像。这里必须吐槽下，换了 N 个浏览器才终于通过牛客的摄像头测试。</li>
<li>接受浏览器权限录屏，全程录屏，静止打开除考试页面和本地 IDE 的其他无关页面。</li>
<li>扫描手机二维码。打开小程序，不允许切开，不允许黑屏。</li>
<li>正式开始答题。</li>
</ol>
<h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><p>两道编程题。总分 400 分，120 分合格。考试时间 90min。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>之前练习的原题——华为机试 04。可惜之前也是只有截图，无法测试全部样例。考试时也没有全部通过。</p>
<p><code>通过case 60%</code></p>
<p>数轴 x 有序序列 A,B, 不空。给定距离 R, 求满足下列条件的数对：</p>
<ol>
<li><p>Ai&lt;=Bj</p>
</li>
<li><p>Ai,Bj 距离小于等于 R, 如果找不到 R 范围内 Bj, 则列出最近一个 Bj, 仍找不到则放弃 Ai</p>
</li>
</ol>
<p>可不特意考虑排序输出。不是考察点。</p>
<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = s.find(<span class="string">&#x27;&#123;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">1</span>; s[i] != <span class="string">&#x27;&#125;&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            a.push_back(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = s.find(<span class="string">&#x27;&#123;&#x27;</span>, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (j += <span class="number">1</span>; s[j] != <span class="string">&#x27;&#125;&#x27;</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[j])) &#123;</span><br><span class="line">            b.push_back(s[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = s.find(<span class="string">&#x27;R&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    R = s[k + <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> _b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = <span class="built_in">abs</span>(a[i] - b[j]);</span><br><span class="line">            <span class="keyword">int</span> mindis = <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; b[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis &lt;= R) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>, a[i], b[j]);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dis &lt; mindis) &#123;</span><br><span class="line">                        mindis = dis;</span><br><span class="line">                        _b = b[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>, a[i], _b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>全量字符集和占用字符集，计算剩余字符集。</p>
<p><code>通过case 100%</code></p>
<p><strong>格式：</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span>:<span class="number">3</span>,<span class="attribute">B</span>:<span class="number">5</span>,<span class="attribute">b</span>:<span class="number">2</span>,<span class="attribute">c</span>:<span class="number">2</span><span class="variable">@a</span>:<span class="number">1</span>,<span class="attribute">B</span>:<span class="number">2</span></span><br><span class="line"><span class="attribute">a</span>:<span class="number">2</span>,<span class="attribute">B</span>:<span class="number">3</span>,<span class="attribute">b</span>:<span class="number">2</span>,<span class="attribute">c</span>:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>按照分隔符分割存储存储计算即可。就是输出格式的时候耽误了一些时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zf</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;@&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos_of_at = s.find(<span class="string">&#x27;@&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos_of_at == s.length()) &#123;</span><br><span class="line">        <span class="built_in">string</span> s1 = s.substr(<span class="number">0</span>, s.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;zf&gt; A;</span><br><span class="line">    <span class="built_in">vector</span>&lt;zf&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos_of_at; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tpos = s.find(<span class="string">&#x27;,&#x27;</span>, i);</span><br><span class="line">            zf t;</span><br><span class="line">            t.a = s[i - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">string</span> ts = s.substr(i + <span class="number">1</span>, tpos - i - <span class="number">1</span>);</span><br><span class="line">            t.b = stoi(ts);</span><br><span class="line">            A.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos_of_at + <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tpos = s.find(<span class="string">&#x27;,&#x27;</span>, i);</span><br><span class="line">            zf t;</span><br><span class="line">            t.a = s[i - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">string</span> ts = s.substr(i + <span class="number">1</span>, tpos - i - <span class="number">1</span>);</span><br><span class="line">            t.b = stoi(ts);</span><br><span class="line">            B.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i].a == B[j].a) &#123;</span><br><span class="line">                A[i].b -= B[j].b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;zf&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i].b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            c.push_back(A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != c.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c[i].a &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; c[i].b &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c[i].a &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; c[i].b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>华为</tag>
        <tag>机试</tag>
      </tags>
  </entry>
  <entry>
    <title>华为试题部分题目记录</title>
    <url>/wiki/%E5%8D%8E%E4%B8%BA%E8%AF%95%E9%A2%98%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p> 涉及很多知识都不了解，还需加油。</p>
</blockquote>
<hr>
<h3 id="牛客华为笔试题目"><a href="#牛客华为笔试题目" class="headerlink" title="牛客华为笔试题目"></a>牛客华为笔试题目</h3><p> <strong>2019 华为网络精英挑战赛初赛模拟题_基础开发 C++ 方向</strong></p>
<a id="more"></a>

<h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><ol>
<li><p>（判断题）小型机通常采用 RISC 和 unix 操作系统。</p>
<p>正确</p>
<blockquote>
<p>小型机操作系统一般是UNIX，PC服务器操作系统一般是windows。但是题干中RISC不是操作系统，是精简指令集计算机，是计算机处理器的一种设计模式，这种设计思路对指令数目和<a href="https://baike.baidu.com/item/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">寻址方式</a>都做了精简，使其实现更容易，指令<a href="https://baike.baidu.com/item/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C">并行执行</a>程度更好，编译器的效率更高，是CPU的设计模式，对应ARM。RISC专注高性能、高性能功耗比、小体积以及移动设备领域，CISC专注桌面、高性能和民用市场。</p>
</blockquote>
</li>
<li><p>（单选题）磁盘接口的类型包括：1、SAS；2、SATA；3、NL-SAS；4、SCSI；5、IDE。请对上述五种类型的接口速率由快到慢进行排序，正确的一项是？</p>
<p>13245</p>
<blockquote>
<p>IDE 电子集成驱动器，“硬盘控制器”与“盘体”集成在一起的硬盘驱动器，一般指的是最早出现的 ATA-1, 速度较慢，目前已经逐渐淘汰。</p>
<p>SCSI 指的是小型计算机接口，其速度，性能和稳定性能都优于 IDE，主要面向服务器和工作站市场。</p>
<p>SATA 指的是 Serial Advanced Technology Attachment，是串行 ATA。优点是持热插拔 ，传输速度快，执行效率高。</p>
<p>SAS 是指 SAS 是 Serial Attach SCSI，串行 SCSI。</p>
<p>NL-SAS 是采用了 SAS 的磁盘接口和 SATA 的盘体的综合体。</p>
<p>首先串行速度高于非串行的，SCSI 是高于 IDE（ATA）的。</p>
</blockquote>
</li>
<li><p>（判断题）将编译程序分成若干个“遍”是为了使程序的结构更加清晰。</p>
<p>正确</p>
</li>
<li><p>（单选题）匹配”英文字母文件名：一个或者多个空格 行号”的正则表达式为：</p>
<p><code>[a-zA-Z]+:[ ]+[0-9]+</code></p>
<blockquote>
<p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 *<strong>** 或 **+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共 6 种。</p>
</blockquote>
</li>
</ol>
<blockquote>
<table>
<thead>
<tr>
<th>*</th>
<th>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。至少匹配 n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
</blockquote>
<ol start="5">
<li><p>（单选题）若要将当前目录中的 myfile.txt 文件压缩成 myfile.txt.tar.gz，命令为</p>
<p><code>tar -zcvf myfile.txt.tar.gz myfile.txt</code></p>
<blockquote>
<p>tar 命令 tar option des sou option: -c 创建压缩文件 -x 解压压缩文件 -z 使用 gzip -f 指定压缩文件 -v 显示压缩过程</p>
</blockquote>
</li>
<li><p>（判断题）对于整数 n，(n &amp; (n-1) ) == 0 的含义是判断 n 是否为偶数。</p>
<p>错误</p>
<blockquote>
<p>位运算是真没咋接触过，得好好看看。</p>
<p>要判断奇偶数，直接用二进制最后一位去比较就可以。</p>
<p><code>if(n &amp; 1) cout &lt;&lt; &quot;奇数&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;偶数&quot; &lt;&lt; endl;</code></p>
<p>n &amp; (n-1) 的作用是把 n 的最低位 1 设置为 0;</p>
<p> <code>XXX10000 -&gt; XXX00000</code></p>
<p>所以这个表达式 (n &amp; (n-1) ) == 0 可以用来判断 n 是否是 0 或者 2 的整数倍。</p>
</blockquote>
</li>
<li><p>（判断题）局部变量可以和全局变量重名，编译的时候不会出现错误，但一旦不小心，就可能导致使用错误变量，所以在定义局部变量的时候不要和全局变量重名。</p>
<p>正确</p>
<blockquote>
<p>局部变量是可以和全局变量重名，但有可能会导致运算错误。</p>
</blockquote>
</li>
<li><p>（单选题）关于数组初始化说法错误的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">显式初始化的数组需要指定数组的维数值。</span><br><span class="line">正确如下：</span><br><span class="line">在函数体外定义的内置数组，其元素均初始化为 0</span><br><span class="line">在函数体内定义的内置数组，其元素无初始化。</span><br><span class="line">如果其元素为类类型，则自动调用该类的默认构造函数进行初始化。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数<strong>体外</strong>定义的内置类型数组（即内置类型的全局数组），元素初始化为 0；</p>
<p>函数<strong>体内</strong>定义的内置类型数组，元素无初始化（注意，若只初始化部分元素，其后的元素此时也会被初始化为 0）；</p>
<p>如果不是内置类型，则不管其在哪定义，自动调用其默认构造函数为其初始化，若该类型无默认构造函数则会报错。</p>
</blockquote>
</li>
</ol>
<h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><ol>
<li><p>（多选题）auto_ptr 类使用必须满足下列限制：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">不要使用 <span class="built_in">auto</span>_ptr 对象保存指向静态分配对象的指针。</span><br><span class="line">不要使用两个 <span class="built_in">auto</span>_ptrs 对象指向同一对象。</span><br><span class="line">不要使用 <span class="built_in">auto</span>_ptr 对象保存指向动态分配数组的指针。</span><br><span class="line">不要将 <span class="built_in">auto</span>_ptr 对象存储在容器中。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建 auto_ptr 对象时注意的几个问题</p>
<p>(1) auto_ptr 的构造函数为 explicit，阻止了一般指针隐式类型转换为 auto_ptr 的构造，所以如下的创建方式是编译不过的。</p>
<p>(2) 由于 auto_ptr 对象析构时会删除它所拥有的指针，所以使用时避免多个 auto_ptr 对象管理同一个指针。如下的使用方法应该避免。</p>
<p>(3)auto_ptr 的内部实现中，析构函数中删除对象使用 delete 而不是 delete[]，所以 auto_ptr 不能用来管理数组指针。</p>
<p>(4)C++ 中对一个空指针 NULL 执行 delete 操作是安全的。所以在 auto_ptr 的析构函数中无须判断它所拥有指针是否为空。</p>
<p>(5) C++ 的 STL 容器对于容器元素类型的要求是有值语义，即可以赋值和复制。auto_ptr 在赋值和复制时都进行了特殊操作，所以 auto_ptr 对象不能作为 STL 容器元素。</p>
</blockquote>
</li>
<li><p>（多选题）可以使用 memset，memcpy 直接进行初始化和拷贝的有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结构</span><br><span class="line">枚举</span><br><span class="line">指针</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在网上看到这样一条评论，觉得有道理：<br><strong>任何类都不能用 memset, 一旦暴力，就等于你、</strong>*了她的内部数据，她已经崩溃了**</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Huawei</category>
      </categories>
      <tags>
        <tag>华为</tag>
        <tag>笔试</tag>
        <tag>错题</tag>
      </tags>
  </entry>
  <entry>
    <title>库调用的那点事</title>
    <url>/wiki/%E5%BA%93%E8%B0%83%E7%94%A8%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="动态库调用的那些事"><a href="#动态库调用的那些事" class="headerlink" title="动态库调用的那些事"></a>动态库调用的那些事</h1><h2 id="调用动态库的两种方式"><a href="#调用动态库的两种方式" class="headerlink" title="调用动态库的两种方式"></a>调用动态库的两种方式</h2><h3 id="1-类似静态库—-头文件"><a href="#1-类似静态库—-头文件" class="headerlink" title="1. 类似静态库—-头文件"></a>1. 类似静态库—-头文件</h3><p>这种方式生成的程序会在启动时候就加载so动态库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = add(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;7+8 = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译生成<code>libadd.so</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libadd.so add.c</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-shared</code>表明生成共享库</p>
</li>
<li><p>如果不加<code>-fPIC</code>,则加载<code>.so</code>文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容, 这就造成每个使用这个<code>.so</code>文件代码段的进程在内核里都会生成这个<code>.so</code>文件代码段的copy.每个copy都不一样, 取决于<br>这个<code>.so</code>文件代码段和数据段内存映射的位置.</p>
</li>
<li><p>另外比较重要的第一点是最好显式添加<code>-fPIC</code>表明使用地址无关代码        PIC：Position Independent Code</p>
<blockquote>
<p>-shared</p>
<pre><code>       Produce a shared object which can then be linked with other objects to form an executable.  Not all systems support this option.  For predictable results, you must also specify the same set of
       options used for compilation (-fpic, -fPIC, or model suboptions) when you specify this linker option.[1] </code></pre>
</blockquote>
</li>
</ul>
<p>编译main，使用<code>-L./</code>指定add库在当前目录。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -o main main.c -L./ -ladd</span><br></pre></td></tr></table></figure>

<p>此时如果不使用<code>-L</code>来指定动态库路径的话, 可以使用<code>LIBRARY_PATH</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LIBRARY_PATH=LIBDIR1:LIBDIR2:$LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>LIBRARY_PATH</code>为<em>程序编译期间</em>查找共享库的路径. </p>
<p>开发时，设置<code>LIBRARY_PATH</code>，以便gcc能够找到编译时需要的动态链接库</p>
</li>
</ul>
<h2 id="2-使用dlopen-dlsum动态加载动态库—-不使用头文件"><a href="#2-使用dlopen-dlsum动态加载动态库—-不使用头文件" class="headerlink" title="2. 使用dlopen/dlsum动态加载动态库—-不使用头文件"></a>2. 使用dlopen/dlsum动态加载动态库—-不使用头文件</h2><p>这种方式生成的程序会在代码执行到<strong>指定行位置</strong>加载so动态库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*手动加载指定位置的so动态库*/</span></span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">&quot;./libadd.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">int</span> (*add)(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根据动态链接库操作句柄与符号，返回符号对应的地址*/</span></span><br><span class="line">    add = dlsym(handle, <span class="string">&quot;add&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = add(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;7+8 = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译<code>so</code>，生成<code>libadd.so</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libadd.so add.c</span><br></pre></td></tr></table></figure>

<p>编译main，不需要指定<code>libadd.so</code>相关信息进行编译，执行时候会在指定目录加载</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -o main main.c -ldl</span><br></pre></td></tr></table></figure>

<p>一般需要添加<code>LD_LIBRARY_PATH</code></p>
<p><code>LD_LIBRARY_PATH</code>环境变量用于在<em>程序加载运行期间</em>查找动态链接库时指定除了系统默认路径之外的其他路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=LIBDIR1:LIBDIR2:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<ul>
<li>发布和使用时，设置<code>LD_LIBRARY_PATH</code>，以便程序加载运行时能够自动找到需要的动态链接库。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>总结</tag>
        <tag>动态库</tag>
      </tags>
  </entry>
  <entry>
    <title>Debug- 无符号 char</title>
    <url>/wiki/%E6%97%A0%E7%AC%A6%E5%8F%B7char/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Expression: c &gt;= -1 &amp;&amp; c &lt;= 255<br>在 Markdown 解析器项目开发中遇到了这个 bug，网上处理方法是：</p>
<p>将项目设置中 -&gt;配置属性 -&gt;C/C++&gt;语言 -&gt;默认 Char 无符号，选择是 (/J)</p>
<a id="more"></a>

<p>这个操作是将项目中的默认 char 类型更改为无符号 char（unsigned char）。现行 vs2017 已结没有选项。</p>
<p>调试后，发现 isdigit() 函数在 isctype.c 中，通过查看 isctype.c 的实现源码发现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">int</span> __cdecl _chvalidator(<span class="keyword">int</span> <span class="keyword">const</span> c, <span class="keyword">int</span> <span class="keyword">const</span> mask)</span><br><span class="line">&#123;</span><br><span class="line">    _ASSERTE(c &gt;= <span class="number">-1</span> &amp;&amp; c &lt;= <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">return</span> _chvalidator_l(<span class="literal">nullptr</span>, c, mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">int</span> __cdecl _chvalidator_l(<span class="keyword">_locale_t</span> <span class="keyword">const</span> locale, <span class="keyword">int</span> <span class="keyword">const</span> c, <span class="keyword">int</span> <span class="keyword">const</span> mask)</span><br><span class="line">&#123;</span><br><span class="line">    _ASSERTE(c &gt;= <span class="number">-1</span> &amp;&amp; c &lt;= <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">_LocaleUpdate <span class="title">locale_update</span><span class="params">(locale)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> index = (c &gt;= <span class="number">-1</span> &amp;&amp; c &lt;= <span class="number">255</span>) ? c : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> locale_update.GetLocaleT()-&gt;locinfo-&gt;_public._locale_pctype[index] &amp; mask;</span><br></pre></td></tr></table></figure>

<p>项目默认 char 为有符号类型，其取值范围为 [-128 ~ 127]，当传入的字符超过 127（可能是中文）时，此时 char 类型值溢出为负数，而当调用之前提到的函数时，则会触发中断_ASSERTE（c&gt; = -1 &amp;&amp; c &lt;= 255）。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>1. 在调用这些函数时，将参数先强转为无符号 char 类型（取值范围 0~255）</strong></p>
<p><code>eg: isdigit((unsigned char)*ptr);</code></p>
<p>**2. 使用 release 模式编译连接可通过，另外 gcc 也可直接通过 **</p>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>解析器</tag>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title>视频编解码基础概念</title>
    <url>/wiki/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>原始图像信息被采集后，视频数据体积非常大，不利于传输和储存，必须进行编码压缩。播放时只需要采用对应的解码技术就可以恢复播放。<br>本文只涉及这个编解码流程中的基础概念、定义等。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote>
<p>以下摘录自<a href="https://www.cnblogs.com/leisure_chn/p/10285829.html">https://www.cnblogs.com/leisure_chn/p/10285829.html</a></p>
</blockquote>
<h3 id="熵与冗余"><a href="#熵与冗余" class="headerlink" title="熵与冗余"></a>熵与冗余</h3><p>引自参考资料[1]第1.5节</p>
<blockquote>
<p>在所有的实际节目素材中，存在着两种类型的信号分量：即异常的、不可预见的信号分量和可以预见的信号分量。异常分量称为<strong>熵</strong>，它是信号中的真正信息。其余部分称为<strong>冗余</strong>，因为它不是必需的信息。冗余可以是空间性的，如在图像的大片区域中，邻近像素几乎具有相同的数值。冗余也可以是时间性的，例如连续图像之间的相似部分。在所有的压缩系统编码器中都是将熵与冗余相分离，只有熵被编码和传输，而在解码器中再从编码器的发送的信号中计算出冗余。</p>
</blockquote>
<h3 id="帧内编码"><a href="#帧内编码" class="headerlink" title="帧内编码"></a>帧内编码</h3><p>帧内编码是空间域编码，利用图像空间性冗余度进行图像压缩，处理的是一幅独立的图像，不会跨越多幅图像。空间域编码依赖于一幅图像中相邻像素间的相似性和图案区的主要空间域频率。</p>
<p>JPEG标准用于静止图像(即图片)，只使用了空间域压缩，只使用帧内编码。</p>
<h3 id="帧间编码"><a href="#帧间编码" class="headerlink" title="帧间编码"></a>帧间编码</h3><p>帧间编码是时间域编码，是利用一组连续图像间的时间性冗余度进行图像压缩。如果某帧图像可被解码器使用，那么解码器只须利用两帧图像的差异即可得到下一帧图像。比如运动平缓的几帧图像的相似性大，差异性小，而运动剧烈的几幅图像则相似性小，差异性大。当得到一帧完整的图像信息后，可以利用与后一帧图像的差异值推算得到后一帧图像，这样就实现了数据量的压缩。时间域编码依赖于连续图像帧间的相似性，尽可能利用已接收处理的图像信息来“预测”生成当前图像。</p>
<p>MPEG标准用于运动图像(即视频)，会使用空间域编码和时间域编码，因此是帧内编码和帧间编码结合使用。</p>
<h3 id="运动矢量"><a href="#运动矢量" class="headerlink" title="运动矢量"></a>运动矢量</h3><p>一组连续图像记录了目标的运动。运动矢量用于衡量两帧图像间目标的运动程度，运动矢量由水平位移量和垂直位移量二者构成。</p>
<h3 id="运动补偿"><a href="#运动补偿" class="headerlink" title="运动补偿"></a>运动补偿</h3><p>目标的运动降低了图像间的相似性，增加了差异数据量。而运动补偿则通过运行矢量来降低图像间的差异数据量。</p>
<p>下图为运动补偿的示意图。当某一目标运动时，其位置会变化但形状颜色等基本不变。编码器则可利用运动矢量减低图像差值，解码器根据图像差值中的运动矢量移动目标到合适的位置即可。假设图中是理想情况，目标除移动位置外其他任何属性无任何变化，则两幅图像间的差值仅包含运动矢量这一数据量。显然运动补偿可以显著减少图像差值数据量。<br><img src="https://leichn.github.io/img/avideo_basics/motion_compensation.jpg" alt="图1 运动补偿"></p>
<h3 id="双向预测"><a href="#双向预测" class="headerlink" title="双向预测"></a>双向预测</h3><p>先看示意图：<br><img src="https://leichn.github.io/img/avideo_basics/bi-directionally_predicted.jpg" alt="图2 双向预测"></p>
<p>连续的三幅图像中，目标块有垂直位置上的移动，背景块无位置移动。我们考虑如何取得当前帧图像(画面N)：<br>画面N中，目标向上移动后，露出背景块。<br>画面N-1中，因为背景块被目标块遮挡住了，因此没有背景块相关信息。<br>画面N+1中，完整包含背景块的数据，因此画面N可以从画面N-1中取得背景块。<br>如何可以得到画面N呢？解码器可以先解码得到画面N-1和画面N+1，通过画面N-1中的目标块数据结合运动矢量即可得到画面N中的目标块数据，通过画面N+1中的背景块数据则可得到画面N中的背景块数据。三幅画面的解码顺序为：N-1, N+1, N。三幅画面的显示顺序为：N-1, N, N+1。画面N通过其前一幅画面N-1和后一幅画面N+1推算(预测，predicted)得到，因此这种方式称为双向预测(或前向预测、双向参考)。</p>
<h3 id="I帧-IDR帧-P帧-B帧"><a href="#I帧-IDR帧-P帧-B帧" class="headerlink" title="I帧/IDR帧/P帧/B帧"></a>I帧/IDR帧/P帧/B帧</h3><p><strong>I帧</strong>：I帧(Intra-coded picture, 帧内编码帧，常称为关键帧)包含一幅完整的图像信息，属于帧内编码图像，不含运动矢量，在解码时不需要参考其他帧图像。因此在I帧图像处可以切换频道，而不会导致图像丢失或无法解码。I帧图像用于阻止误差的累积和扩散。在闭合式GOP中，每个GOP的第一个帧一定是I帧，且当前GOP的数据不会参考前后GOP的数据。</p>
<p><strong>IDR帧</strong>：IDR帧(Instantaneous Decoding Refresh picture, 即时解码刷新帧)是一种特殊的I帧。当解码器解码到IDR帧时，会将DPB(Decoded Picture Buffer，指前后向参考帧列表)清空，将已解码的数据全部输出或抛弃，然后开始一次全新的解码序列。IDR帧之后的图像不会参考IDR帧之前的图像，因此IDR帧可以阻止视频流中的错误传播，同时IDR帧也是解码器、播放器的一个安全访问点。</p>
<p><strong>P帧</strong>：P帧(Predictive-coded picture, 预测编码图像帧)是帧间编码帧，利用之前的I帧或P帧进行预测编码。</p>
<p><strong>B帧</strong>：B帧(Bi-directionally predicted picture, 双向预测编码图像帧)是帧间编码帧，利用之前和(或)之后的I帧或P帧进行双向预测编码。B帧不可以作为参考帧。<br>B帧具有更高的压缩率，但需要更多的缓冲时间以及更高的CPU占用率，因此B帧适合本地存储以及视频点播，而不适用对实时性要求较高的直播系统。</p>
<h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><p>GOP(Group Of Pictures, 图像组)是一组连续的图像，由一个I帧和多个B/P帧组成，是编解码器存取的基本单位。GOP结构常用的两个参数M和N，M指定GOP中两个anchor frame(anchor frame指可被其他帧参考的帧，即I帧或P帧)之间的距离，N指定一个GOP的大小。例如M=3，N=15，GOP结构为：IBBPBBPBBPBBPBB</p>
<p>TODO: GOP中是否每两个anchor frame的间隔是相同的？推测：未必相同。实际上分析不少视频文件，规律并不一致。此处没有彻底弄清楚，待进一步积累素材、分析与确认。</p>
<p>GOP有两种：闭合式GOP和开放式GOP：</p>
<p><strong>闭合式GOP</strong>：闭合式GOP只需要参考本GOP内的图像即可，不需参考前后GOP的数据。这种模式决定了，闭合式GOP的显示顺序总是以I帧开始以P帧结束</p>
<p>TODO: 闭合式GOP是否一定是以P帧结束？推测：可能未必有此定义。有看到某些视频文件GOP以B帧结束。</p>
<p><strong>开放式GOP</strong>：开放式GOP中的B帧解码时可能要用到其前一个GOP或后一个GOP的某些帧。码流里面包含B帧的时候才会出现开放式GOP。</p>
<p>TODO: 开放式GOP是否规定是以B帧开始，P帧结束？推测：可能未必有此定义。是否以B帧开始？网上资料说法不一。是否以P帧结束？有看到某些视频文件GOP以B帧结束。</p>
<p>在开放式GOP中，普通I帧和IDR帧功能是有差别的，需要明确区分两种帧类型。在闭合式GOP中，普通I帧和IDR帧功能没有差别，可以不作区分。</p>
<p>开放式GOP和闭合式GOP中I帧、P帧、B帧的依赖关系如下图所示：<br><img src="https://leichn.github.io/img/avideo_basics/gop_mode.jpg" alt="图3 GOP模式"></p>
<h3 id="DTS和PTS"><a href="#DTS和PTS" class="headerlink" title="DTS和PTS"></a>DTS和PTS</h3><p>DTS(Decoding Time Stamp, 解码时间戳)，表示压缩帧的解码时间。<br>PTS(Presentation Time Stamp, 显示时间戳)，表示将压缩帧解码后得到的原始帧的显示时间。<br>音频中DTS和PTS是相同的。视频中由于B帧需要双向预测，B帧依赖于其前和其后的帧，因此含B帧的视频解码顺序与显示顺序不同，即DTS与PTS不同。当然，不含B帧的视频，其DTS和PTS是相同的。下图以一个开放式GOP示意图为例，说明视频流的解码顺序和显示顺序<br><img src="https://leichn.github.io/img/avideo_basics/decode_order.jpg" alt="图4 解码和显示顺序"><br><strong>采集顺序</strong>指图像传感器采集原始信号得到图像帧的顺序。<br><strong>编码顺序</strong>指编码器编码后图像帧的顺序。存储到磁盘的本地视频文件中图像帧的顺序与编码顺序相同。<br><strong>传输顺序</strong>指编码后的流在网络中传输过程中图像帧的顺序。<br><strong>解码顺序</strong>指解码器解码图像帧的顺序。<br><strong>显示顺序</strong>指图像帧在显示器上显示的顺序。<br><strong>采集顺序与显示顺序相同。编码顺序、传输顺序和解码顺序相同。</strong><br>以图中“B[1]”帧为例进行说明，“B[1]”帧解码时需要参考“I[0]”帧和“P[3]”帧，因此“P[3]”帧必须比“B[1]”帧先解码。这就导致了解码顺序和显示顺序的不一致，后显示的帧需要先解码。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>[1] 泰克Tektronic, MPEG基础和协议分析指南<br>[2] <a href="https://www.jianshu.com/p/04b5b1e4ff27">视频直播的理论知识</a>，<a href="https://www.jianshu.com/p/04b5b1e4ff27">https://www.jianshu.com/p/04b5b1e4ff27</a><br>[3] <a href="https://www.jianshu.com/p/d30c051b4106">open GOP &amp; close GOP</a>, <a href="https://www.jianshu.com/p/d30c051b4106">https://www.jianshu.com/p/d30c051b4106</a><br>[4] <a href="https://blog.csdn.net/abcsunl/article/details/68190136">I帧/B帧/P帧/GOP</a>, <a href="https://blog.csdn.net/abcsunl/article/details/68190136">https://blog.csdn.net/abcsunl/article/details/68190136</a><br>[5] <a href="https://www.jianshu.com/p/3578e794f6b5">FFmpeg音视频同步原理与实现</a>, <a href="https://www.jianshu.com/p/3578e794f6b5">https://www.jianshu.com/p/3578e794f6b5</a><br>[6] <a href="https://www.jianshu.com/p/27279255f67e">FFmpeg音视频同步</a>, <a href="https://www.jianshu.com/p/27279255f67e">https://www.jianshu.com/p/27279255f67e</a><br>[7] <a href="https://www.sciencedirect.com/science/article/pii/S1319157819301867">The GOP Inter Prediction of H.264 AVC</a>, <a href="https://www.sciencedirect.com/science/article/pii/S1319157819301867">https://www.sciencedirect.com/science/article/pii/S1319157819301867</a><br>[8] <a href="https://en.wikipedia.org/wiki/Group_of_pictures">WiKi Group of pictures</a>, <a href="https://en.wikipedia.org/wiki/Group_of_pictures">https://en.wikipedia.org/wiki/Group_of_pictures</a><br>[9] <a href="https://streaminglearningcenter.com/articles/open-and-closed-gops-all-you-need-to-know.html">Open and Closed GOPs – All You Need to Know</a>, <a href="https://streaminglearningcenter.com/articles/open-and-closed-gops-all-you-need-to-know.html">https://streaminglearningcenter.com/articles/open-and-closed-gops-all-you-need-to-know.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>判断闰年</title>
    <url>/wiki/%E9%97%B0%E5%B9%B4/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个 2000 至 2500 年间（包含 2000 年和 2500 年）的任意年份，判断是否是闰年。</p>
<a id="more"></a>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入一个整数 year，表示年份。输入保证 2000≤year≤2500。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>如果输入的年份是闰年，请输出“leap year”，否则请输出“not leap year”。<br>请注意不需要输出引号，行尾输出换行。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p><code>2000</code></p>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p><code>leap year</code></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">if</span> ((i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">100</span> != <span class="number">0</span>) || i % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;leap year&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>闰年</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见手写算法记录（更新）</title>
    <url>/wiki/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95(%E6%9B%B4%E6%96%B0)/</url>
    <content><![CDATA[<p>面试常见手写算法记录（更新）</p>
<a id="more"></a>

<h3 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二路归并排序主旨是“分解”与“归并”</span></span><br><span class="line"><span class="comment">//合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>, p = <span class="number">0</span>;<span class="comment">//对应a数组的下标</span></span><br><span class="line">    <span class="keyword">int</span> * r = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];<span class="comment">//申请另一个对应大小的数组来存放排好序的数据</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        r[p++] = (a[i] &lt;= a[j]) ? a[i++] : a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        r[p++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        r[p++] = a[j++];</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>, i = low; i &lt;= high; p++, i++)</span><br><span class="line">        a[i] = r[p];<span class="comment">//最后再把有序数据存进a数组中，使得a数组对应部分数据有序</span></span><br><span class="line">    <span class="keyword">delete</span>[] r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自顶向下(递归实现)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        MSort(a, low, mid);</span><br><span class="line">        MSort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">        Merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123; stack1.push(node); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B_Search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = a.size() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt;= k) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; k) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">once_QS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = a[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; key &lt;= a[high]) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[low], a[high]);</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; key &gt; a[low]) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[low], a[high]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = once_QS(a, low, high);</span><br><span class="line">        QuickSort(a, low, pos - <span class="number">1</span>);</span><br><span class="line">        QuickSort(a, pos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//虽然最简单，还是要记下，不能翻车</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">std</span>::swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先对原链表做头删操作，再对新链表做头插</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//1. 对之前的链表做头删</span></span><br><span class="line">		node = head;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2. 对新链表做头插</span></span><br><span class="line">		node-&gt;next = newHead;</span><br><span class="line">		newHead = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐个翻转</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p0</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p1</span> =</span> head;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p2</span> =</span> head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p1-&gt;next = p0;</span><br><span class="line"></span><br><span class="line">		p0 = p1;</span><br><span class="line">		p1 = p2;</span><br><span class="line">		<span class="keyword">if</span> (p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			p2 = p2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>面试</tag>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 面试总结（更新）</title>
    <url>/wiki/C++%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E6%9B%B4%E6%96%B0)/</url>
    <content><![CDATA[<blockquote>
<p>准备下面试，下面及主要记录下一些知识点</p>
</blockquote>
<a id="more"></a>

<h2 id="c-面试题总结"><a href="#c-面试题总结" class="headerlink" title="c++ 面试题总结"></a>c++ 面试题总结</h2><h3 id="1-C-和-C-区别"><a href="#1-C-和-C-区别" class="headerlink" title="1. C 和 C++ 区别"></a>1. C 和 C++ 区别</h3><ul>
<li>C 是面向过程的结构化语言，C++ 是除了面向过程，也可以面向对象。</li>
<li>C++ 具有重载、继承和多态三种特性</li>
<li>C++ 相比 C，增加多许多类型安全的功能，比如强制类型转换</li>
<li>C++ 支持范式编程，比如模板类、函数模板等</li>
</ul>
<h3 id="2-多态实现方法"><a href="#2-多态实现方法" class="headerlink" title="2. 多态实现方法"></a>2. 多态实现方法</h3><ul>
<li>C++ 中，实现多态有以下方法：虚函数，抽象类，覆盖，模板，条件是要有重写，要有继承，父类指向子类。</li>
</ul>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20200313184554050.png" alt="image-20200313184554050"></p>
<h3 id="3-虚函数"><a href="#3-虚函数" class="headerlink" title="3. 虚函数"></a>3. 虚函数</h3><p><strong>虚函数的作用：</strong> 虚函数实现了多态的机制。基类定义了虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，且这样的函数调用是无法在编译器期间确认的，而是在运行期确认，也叫做晚绑定。</p>
<p><strong>实现原理：</strong><br>  它涉及两个工具，<br>  当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的<strong>虚函数表</strong>。虚函数表实际上就是一个函数指针数组，有的编译器用的是链表。虚函数表数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个虚函数表指针，虚函数表指针指向该虚函数表的地址。所以当一个类有虚函数的，是占用内存的，占用一个指针大小的内存。<br>  虚函数表按照其声明顺序放于虚函数表中。<br>  如果子类覆盖了父类的虚函数，将覆盖虚函数表中原来父类虚函数的位置。<br>  如果派生类有多个父类，子类的成员函数存放在第一个父类的表中。</p>
<h3 id="4-深拷贝和浅拷贝（值拷贝和位拷贝）"><a href="#4-深拷贝和浅拷贝（值拷贝和位拷贝）" class="headerlink" title="4. 深拷贝和浅拷贝（值拷贝和位拷贝）"></a>4. 深拷贝和浅拷贝（值拷贝和位拷贝）</h3><p>深拷贝指拷贝时对象资源重新分配，两个对象的资源内存不同，释放一个对象资源不会影响另一个。<br>浅拷贝指两个对象均指向同一内存空间，释放一个对象的资源，另一个对象的资源也没了，造成野指针。</p>
<h3 id="5-为什么要有虚析构函数"><a href="#5-为什么要有虚析构函数" class="headerlink" title="5. 为什么要有虚析构函数"></a>5. 为什么要有虚析构函数</h3><p>C++ 中基类采用 virtual 虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当<strong>删除基类指针指向的派生类对象时</strong>就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++ 中基类的析构函数应采用 virtual 虚析构函数。</p>
<h3 id="6-构造函数能不能是虚函数"><a href="#6-构造函数能不能是虚函数" class="headerlink" title="6. 构造函数能不能是虚函数"></a>6. 构造函数能不能是虚函数</h3><p>不能</p>
<p>构造一个对象时，必须知道对象实际类型，而虚函数是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功，编译器就无法知道对象的实际类型，是该类本身，还是派生类，还是其他。</p>
<p>虚函数的执行依赖于虚函数表，而虚函数表是在构造函数中进行初始化的，即初始化虚表指针（vptr），使得正确指向虚函数表。而在构造对象期间，虚函数表（vtable）还没有被初始化，将无法进行。</p>
<h3 id="7-C-里面构造函数能有返回值吗？"><a href="#7-C-里面构造函数能有返回值吗？" class="headerlink" title="7. C++ 里面构造函数能有返回值吗？"></a>7. C++ 里面构造函数能有返回值吗？</h3><ol>
<li>构造函数没有返回值，他只是描述了类初始化的行为。</li>
<li>但是 new 一个类实例是有返回值的，因为 new 返回的是类实例的指针</li>
</ol>
<h3 id="8-构造函数和析构函数能被继承吗"><a href="#8-构造函数和析构函数能被继承吗" class="headerlink" title="8. 构造函数和析构函数能被继承吗"></a>8. 构造函数和析构函数能被继承吗</h3><p>不能</p>
<p>不是所有的函数都能自动地从基类继承到派生类中的。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对在它们的特殊层次的对象做什么。</p>
<p>所以，在整个层次中的所有的构造函数和析构函数都必须被调用，也就是说，构造函数和析构函数不能被继承。子类的构造函数会显示的调用父类的构造函数或隐式的调用父类的默认的构造函数进行父类部分的初始化。</p>
<p>析构函数也一样。它们都是每个类都有的东西，如果能被继承，那就没有办法初始化了。</p>
<h3 id="9-函数与宏的差别"><a href="#9-函数与宏的差别" class="headerlink" title="9. 函数与宏的差别"></a>9. 函数与宏的差别</h3><ol>
<li>宏做的是简单的字符串替换，不会考虑数据类型；, 而函数是参数的传递，参数是有数据类型的。</li>
<li>宏的参数替换是不经计算而直接处理的，而函数调用是将实参的值传递给形参，既然说是值，自然是计算得来的。</li>
<li>宏占用的是编译的时间，而函数占用的是执行时的时间。</li>
<li>宏的参数是不占内存空间的，因为只做字符串的替换，形参作为函数的局部变量，是占用内存的。</li>
<li>函数的调用是需要付出一定的时空开销的，因为系统在调用函数时，要保留现场，然后转入被调用函数，执行完后返回主函数，再恢复现场，这些操作在宏中是没有的。</li>
</ol>
<h3 id="10-宏函数和-inline-函数的异同点"><a href="#10-宏函数和-inline-函数的异同点" class="headerlink" title="10. 宏函数和 inline 函数的异同点"></a>10. 宏函数和 inline 函数的异同点</h3><p>1、内联函数在编译时展开，而宏在预编译时展开</p>
<p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p>
<p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p>
<p>4、宏不是函数，而 inline 是函数</p>
<p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p>
<p>6、inline 可以不展开，宏一定要展开。因为 inline 指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p>
<p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受 C++ 编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<h3 id="11-C-的内存管理机制"><a href="#11-C-的内存管理机制" class="headerlink" title="11. C++ 的内存管理机制"></a>11. C++ 的内存管理机制</h3><p>C++ 程序在执行时，将内存大方向划分为<strong>4 个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员<strong>分配</strong>和释放，若程序员不释放，程序结束时由操作系统回收</li>
</ul>
<h3 id="12-迭代和递归区别"><a href="#12-迭代和递归区别" class="headerlink" title="12. 迭代和递归区别"></a>12. 迭代和递归区别</h3><p>递归与迭代都是基于控制结构：迭代用重复结构，而递归用选择结构。<br>递归与迭代都涉及重复：迭代显式使用重复结构，而递归通过重复函数调用实现重复。<br>递归与迭代都涉及终止测试：迭代在循环条件失败时终止，递归在遇到基本情况时终止。</p>
<h3 id="13-C-11-新特性了解吗"><a href="#13-C-11-新特性了解吗" class="headerlink" title="13. C++11 新特性了解吗"></a>13. C++11 新特性了解吗</h3><ol>
<li>新增容器 std::array 保存在<strong>栈</strong>内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。</li>
<li>auto 和 decltype 这两个关键字实现了类型推导</li>
<li>替代 NULL 的 nullptr</li>
<li>三种智能指针帮助内存管理(说一下名称)、<img src="https://gitee.com/SunGitee/src/raw/master/img/image-20200313184651322.png" alt="image-20200313184651322"></li>
<li>C++11 引入了基于范围的迭代写法，比如基于范围的 for 循环，用一个冒号就可实现遍历，我们拥有了能够写出像 Python 一样简洁的循环语句</li>
</ol>
<h3 id="14-动态库和静态库？"><a href="#14-动态库和静态库？" class="headerlink" title="14. 动态库和静态库？"></a>14. 动态库和静态库？</h3><p>静态库特点总结如下：<br>静态库对函数库的链接是放在编译时期完成的。<br>程序在运行时与函数库再无瓜葛，移植方便。<br>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。<br>文件后缀常为（.a、.lib）。</p>
<p>动态库特点总结：<br>动态库把对一些库函数的链接载入推迟到程序运行的时期。<br>可以实现进程之间的资源共享。<br>将一些程序升级变得简单，直接改动态库即可。<br>文件后缀常为（.so、.dll）。</p>
<h3 id="16-堆和栈的区别，以及为什么栈效率高"><a href="#16-堆和栈的区别，以及为什么栈效率高" class="headerlink" title="16. 堆和栈的区别，以及为什么栈效率高"></a>16. 堆和栈的区别，以及为什么栈效率高</h3><p>堆是由低地址向高地址扩展；栈是由高地址向低地址扩展。<br>堆中的内存需要手动申请和手动释放；栈中内存是由 OS 自动申请和自动释放，存放着参数、局部变量等内存。<br>堆中频繁调用 malloc 和 free, 会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片。<br>堆的分配效率较低，而栈的分配效率较高。</p>
<p>栈的效率高的原因：<br>栈是<strong>操作系统提供的数据结构</strong>，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而<strong>堆是由 C/C++ 函数库</strong>提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p>
<h3 id="17-请你来说一下-C-中的智能指针"><a href="#17-请你来说一下-C-中的智能指针" class="headerlink" title="17. 请你来说一下 C++ 中的智能指针"></a>17. 请你来说一下 C++ 中的智能指针</h3><p>C++ 里面的四个智能指针：auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是 c++11 支持，并且第一个已经被 11 弃用。</p>
<p>作用：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<p>1、auto_ptr（c++98 的方案，cpp11 已经抛弃）采用所有权模式。缺点是：存在潜在的内存崩溃问题！</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">auto<span class="number">_p</span>tr&lt; string&gt; p<span class="number">1</span> (``<span class="keyword">new</span>` `string (<span class="string">&quot;I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string">``<span class="subst">auto<span class="number">_p</span>tr  p<span class="number">2</span>;p<span class="number">2</span> = p<span class="number">1</span>; </span>``</span></span><br><span class="line"><span class="string">//auto_ptr不会报错.此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</span></span><br></pre></td></tr></table></figure>

<p>2、unique_ptr（替换 auto_ptr）unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（例如“以 new 创建对象后因为发生异常而忘记调用 delete”) 特别有用。采用所有权模式。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">unique_ptr p3 (<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">string</span> (<span class="string">``</span><span class="string">&quot;auto&quot;</span><span class="string">``</span>));</span><br><span class="line"><span class="string">``</span>unique_ptr p4；<span class="string">``</span>p4 = p3;<span class="string">``</span><span class="comment">//此时会报错！！``</span></span><br><span class="line"><span class="comment">//编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</span></span><br></pre></td></tr></table></figure>

<p>3、shared_ptr<br>shared_ptr 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入 auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用 release() 时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被释放。<br>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性 (auto_ptr 是独占的）, 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>4、weak_ptr<br>weak_ptr 是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。</p>
<p>weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0, 资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。</p>
<h3 id="18-C-源文件从文本到可执行文件经历的过程？"><a href="#18-C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="18. C++ 源文件从文本到可执行文件经历的过程？"></a>18. C++ 源文件从文本到可执行文件经历的过程？</h3><p>对于 C++ 源文件，从文本到可执行文件一般需要四个过程：</p>
<ul>
<li>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</li>
<li>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</li>
<li>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</li>
<li>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</li>
</ul>
<h3 id="19-什么时候会发生段错误？"><a href="#19-什么时候会发生段错误？" class="headerlink" title="19. 什么时候会发生段错误？"></a>19. 什么时候会发生段错误？</h3><ul>
<li>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：<ul>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ul>
</li>
</ul>
<h3 id="20-右值引用"><a href="#20-右值引用" class="headerlink" title="20. 右值引用"></a>20. 右值引用</h3><p>基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</p>
<h3 id="21-const-的作用"><a href="#21-const-的作用" class="headerlink" title="21. const 的作用"></a>21. const 的作用</h3><p>const 意味着”只读”</p>
<ul>
<li><ol>
<li>修饰变量，说明该变量不可以被修改</li>
</ol>
</li>
<li><ol start="2">
<li>修饰指针，分为指向常量的指针（即常量指针）和指针常量</li>
</ol>
</li>
<li><ol start="3">
<li>常量引用，经常用于形参类型，既避免了拷贝，又避免了函数对值的修改</li>
</ol>
</li>
<li><ol start="4">
<li>修饰成员函数，说明该成员函数内不能修改成员变量</li>
</ol>
</li>
<li>const 用法如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 常量指针即常指针，指针的指向可以改变，但是所存的内容不能变</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* p2 = greeting;     <span class="comment">// 与const char* p2 等价</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 指针常量，指针是一个常量，即指针的指向不能改变，但是指针所存的内容可以改变</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 指向常量的常指针，指针和指针所存的内容都不能改变，本质是一个常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数为常量指针即指针所指的内容为常量不能变，指针指向可以改变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数为指针常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量即常量指针，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针即指针常量，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

<h3 id="22-inline-内联函数"><a href="#22-inline-内联函数" class="headerlink" title="22. inline 内联函数"></a>22. inline 内联函数</h3><ul>
<li>内联函数的特点：<ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
</li>
<li>内联函数的使用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编译器对内联函数的处理步骤<ul>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）</li>
</ul>
</li>
<li>使用内联函数的优缺点<ul>
<li>优点：<ul>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ul>
</li>
<li>缺点：<ul>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline 函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ul>
</li>
</ul>
</li>
<li>虚函数可以是内联函数吗？<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
<li>虚函数内联使用实例如下：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line">    Base b;</span><br><span class="line">    b.who();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">    ptr-&gt;who();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-用变量-a-给出下面的定义"><a href="#23-用变量-a-给出下面的定义" class="headerlink" title="23. 用变量 a 给出下面的定义"></a>23. 用变量 a 给出下面的定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A.一个整型数？</span><br><span class="line"></span><br><span class="line">答案：<span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">B.一个指向整型数的指针？</span><br><span class="line"></span><br><span class="line">答案：<span class="keyword">int</span> *a;</span><br><span class="line"></span><br><span class="line">C.一个指向指针的的指针，它指向的指针是指向一个整型数？</span><br><span class="line"></span><br><span class="line">答案：<span class="keyword">int</span> **a;</span><br><span class="line"></span><br><span class="line">D.一个有<span class="number">10</span>个整型数的数组？</span><br><span class="line"></span><br><span class="line">答案：<span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">E.一个有<span class="number">10</span>个指针的数组，该指针是指向一个整型数的？</span><br><span class="line"></span><br><span class="line">答案：<span class="keyword">int</span> *a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">F.一个指向有<span class="number">10</span>个整型数数组的指针?</span><br><span class="line"></span><br><span class="line">答案：<span class="keyword">int</span> (*a)[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">G.一个指向函数的指针，该函数有一个整型参数并返回一个整型数?</span><br><span class="line"></span><br><span class="line">答案：<span class="keyword">int</span> (*a)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">H.一个有<span class="number">10</span>个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数?</span><br><span class="line"></span><br><span class="line">答案：<span class="keyword">int</span> (*a[<span class="number">10</span>])(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<h3 id="24-sizeof-和-strlen-的区别？"><a href="#24-sizeof-和-strlen-的区别？" class="headerlink" title="24. sizeof 和 strlen 的区别？"></a>24. <strong>sizeof 和 strlen 的区别？</strong></h3><p>sizeof 是运算符，在编译时即计算好了； 而 strlen 是函数，要在运行时才能计算。</p>
<h3 id="25-请你来回答一下-i和i-的区别"><a href="#25-请你来回答一下-i和i-的区别" class="headerlink" title="25. 请你来回答一下++i和i++的区别"></a>25. 请你来回答一下++i和i++的区别</h3><p>参考回答：</p>
<p>++i先自增1，再返回，i++先返回i,再自增1</p>
<p>请你来说一说++i和i++的实现</p>
<p>参考回答：</p>
<ol>
<li>++i 实现：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  <span class="keyword">int</span>::<span class="keyword">operator</span>++（）</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> +=<span class="number">1</span>；</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>i++ 实现：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  <span class="keyword">int</span>::<span class="keyword">operator</span>（<span class="keyword">int</span>）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> oldValue = *<span class="keyword">this</span>；</span><br><span class="line">	++（*<span class="keyword">this</span>）；</span><br><span class="line">	<span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-红黑树（RB-tree）比AVL树的优势在哪？"><a href="#26-红黑树（RB-tree）比AVL树的优势在哪？" class="headerlink" title="26. 红黑树（RB-tree）比AVL树的优势在哪？"></a>26. 红黑树（RB-tree）比AVL树的优势在哪？</h3><p>红黑树是牺牲了严格的高度平衡的优越条件为 代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.</p>
<p>平衡二叉树（AVL树）：</p>
<p>平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p>红黑树：</p>
<p>红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p>
<p>性质：</p>
<ol>
<li><p>每个节点非红即黑</p>
</li>
<li><p>根节点是黑的;</p>
</li>
<li><p>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
</li>
<li><p>如果一个节点是红色的，则它的子节点必须是黑色的。</p>
</li>
<li><p>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p>
</li>
</ol>
<p>区别：</p>
<p>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<h3 id="27-请你来说一下map和set有什么区别，分别又是怎么实现的？"><a href="#27-请你来说一下map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="27. 请你来说一下map和set有什么区别，分别又是怎么实现的？"></a>27. 请你来说一下map和set有什么区别，分别又是怎么实现的？</h3><p><strong>unordered map底层结构是哈希表</strong></p>
<p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p>
<p>map和set区别在于：</p>
<p>（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p>
<p>（2）<strong>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</strong></p>
<p>（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。<strong>如果find能解决需要，尽可能用find。</strong></p>
<h3 id="28-请你来说一下STL中迭代器的作用，有指针为何还要迭代器"><a href="#28-请你来说一下STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="28. 请你来说一下STL中迭代器的作用，有指针为何还要迭代器"></a>28. 请你来说一下STL中迭代器的作用，有指针为何还要迭代器</h3><p>1、迭代器</p>
<p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<p>2、迭代器和指针的区别</p>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p>
<p>3、迭代器产生原因</p>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
<h3 id="29-STL里resize和reserve的区别"><a href="#29-STL里resize和reserve的区别" class="headerlink" title="29. STL里resize和reserve的区别"></a>29. STL里resize和reserve的区别</h3><p>参考回答里，给的代码例子，有不对的地方。a.reserve（n）的功能是，如果n&lt;=a.capacity(),则a 不做改变，若n&gt;a.capacity()则把a的capacity（）设成n. reserve()不影响size()的大小。但是resize 有可能会影响capacity的值</p>
<h3 id="30-TCP建立连接和断开连接的过程："><a href="#30-TCP建立连接和断开连接的过程：" class="headerlink" title="30. TCP建立连接和断开连接的过程："></a>30. TCP建立连接和断开连接的过程：</h3><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20200313184715540.png" alt="image-20200313184715540"></p>
<p>三次握手：</p>
<ol>
<li><p>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ol>
<p>四次挥手：</p>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p>1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。</p>
<p>2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。</p>
<p>3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认</p>
<p>4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</p>
<h3 id="31-TCP的模型，状态转移"><a href="#31-TCP的模型，状态转移" class="headerlink" title="31. TCP的模型，状态转移"></a>31. TCP的模型，状态转移</h3><p>四层TCP/IP模型如下：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20200313184743297.png" alt="image-20200313184743297"></p>
<h3 id="32-HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#32-HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="32. HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>32. HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h3><p>HTTP协议和HTTPS协议区别如下：</p>
<p>1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</p>
<p>2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</p>
<p>3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</p>
<p>4）HTTP协议端口是80，HTTPS协议端口是443</p>
<p>HTTPS优点：</p>
<p>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p>
<p>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p>
<p>HTTPS缺点：</p>
<p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
<p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
<h3 id="33-IP地址作用，以及MAC地址作用"><a href="#33-IP地址作用，以及MAC地址作用" class="headerlink" title="33. IP地址作用，以及MAC地址作用"></a>33. IP地址作用，以及MAC地址作用</h3><p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<h3 id="34-手写一下快排和二分查找的代码"><a href="#34-手写一下快排和二分查找的代码" class="headerlink" title="34. 手写一下快排和二分查找的代码"></a>34. 手写一下快排和二分查找的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B_Search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = a.size() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt;= k) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; k) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">once_QS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = a[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; key &lt;= a[high]) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[low], a[high]);</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; key &gt; a[low]) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[low], a[high]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = once_QS(a, low, high);</span><br><span class="line">        QuickSort(a, low, pos - <span class="number">1</span>);</span><br><span class="line">        QuickSort(a, pos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>MP3 文件格式解析</title>
    <url>/wiki/MP3%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="MP3-文件格式解析"><a href="#MP3-文件格式解析" class="headerlink" title="MP3 文件格式解析"></a>MP3 文件格式解析</h1><p>MP3 的全称是 MPEG Audio Layer3, 它是一种高效的计算机音频编码方案，它以较大的压缩比将音频文件转换成较小的扩展名为。MP3 的文件，基本保持原文件的音质。MP3 是 ISO/MPEG 标准的一部分，ISO/MPEG 标准描述了使用高性能感知编码方案的音频压缩，此标准一直在不断更新以满足“质高量小”的追求，现已形成 MPEGLayer1、Layer2、Layer3 三个音频编码解码方案。MPEGLayer3 压缩率可达 1:10 至 1:12,1M 的 MP3 文件可播放 1 分钟，而 1 分钟 CD 音质的 WAV 文件 (44100Hz,16bit, 双声道，60 秒）要占用 10M 空间，这样算来，一张 650M 的 MP3 光盘播放时间应在 10 小时以上，而同样容量的一张 CD 盘播放时间在 70 分钟左右。MP3 的优势是 CD 难以比拟的。</p>
<h2 id="MPEG-Audio-标准"><a href="#MPEG-Audio-标准" class="headerlink" title="MPEG Audio 标准"></a>MPEG Audio 标准</h2><p>MPEG(MovingPictureExpertsGroup) 是 ISO 下的一个动态图 像专家组，它制定的 MPEG 标准广泛应用于各种多媒体中。 MPEG 标准包括视频和音频标准，其中音频标准已制定出 MPEG-1、MPEG-2、MPEG-2AAC 和 MPEG-4。</p>
<p>MPEG-1 和 MPEG-2 标准使用同一个音频编码解码族—Layer1、2、3。MPEG-2 一个新特点是采用低采样率扩展降低数据流量，另一特点是多通道扩展，将主声道增加为 5 个。MPEG-2AAC(MPEG-2AdvancedAudioCoding) 标准是 FraunhoferIIS 同 AT&amp;T 公司于 1997 年推出的，旨在显著减少数据流量，MPEG22AAC 采用的修正的离散余弦变换 (MDCT,ModifiedDiscreteCo2sineTransform) 算法，采样率可在 8KHz 到 96KHz 之间，声道数可在 1-48 之间。</p>
<p>MPEG Audio Layer1、2、3 三个层使用相同的滤波器组、位流结构和头信息，采样频率为 32KHz、4411KHz 或 48KHz。Layer1 是为数字压缩磁带 DCC(DigitalCompactCassette) 设计的，数据流量为 384kbps,Layer2 在复杂性和性能间作了权衡，数据流量下降到 256kbps-192kbps。Layer3 一开始就为低数据流量而设计，数据流量在 128kbps-112kbps,Layer3 增加了 MDCT 变换，使其频率分辨能力是 Layer2 的 18 倍，Layer3 还使用了与 MPEGVid2eo 类似的平均信息量编码 (EntropyCoding), 减少了冗余信息。MP3 绝大部分使用的是 MPEG21 标准。</p>
<h2 id="音频压缩"><a href="#音频压缩" class="headerlink" title="音频压缩"></a>音频压缩</h2><p>MP3 格式始于 80 年代中期，德国 Erlangen 的 Fraunhofer 研究 所致力于高质量、低数据率的声音编码。</p>
<p>MP3 音频压缩包含编码和解码两个部分。编码是将 WAV 文件中的数据转换成高压缩率的位流形式，解码是接受位流并将其重建到 WAV 文件中。</p>
<p>MP3 采用了感知音频编码 (PerceptualAudioCoding) 这一失真算法。人耳感受声音的频率范围是 20Hz-220kHz,MP3 截掉了大量的冗余信号和无关的信号，编码器通过混合滤波器组将原始声音变换到频率域，利用心理声学模型，估算刚好能被察觉到的噪声水平，再经过量化，转换成 Huffman 编码，形成 MP3 位流。解码器要简单得多，它的任务是从编码后的谱线成分中，经过反 量化和逆变换，提取出声音信号。</p>
<p>在压缩音频数据时，先将原始声音数据分成固定的分块，然后作顺向 MDCT 变换，MDCT 本身并不进行数据压缩，只是将一组时域数据转换成频域数据，以得知时域变化情况，顺向 MDCT 将每块的值转换为 512 个 MDCT 系数。量化使数据得到压缩，在对量化后的变换样值进行比特分配时要考虑使整个量化块最小，这就成为有损压缩了。解压时，经反向 MDCT 将 512 个系数还原成原始声音数据，前后的原始声音数据是不一致的，因为在压缩过程中，去掉了冗余和不相关数据。</p>
<h2 id="MP3-文件结构"><a href="#MP3-文件结构" class="headerlink" title="MP3 文件结构"></a>MP3 文件结构</h2><p>MP3 文件大体分为三部分：TAG_V2(ID3V2), Frame, TAG_V1(ID3V1)</p>
<table>
<thead>
<tr>
<th>ID3V2</th>
<th>包含了作者，作曲，专辑等信息，长度不固定，扩展了 ID3V1 的信息量</th>
</tr>
</thead>
<tbody><tr>
<td>Frame</td>
<td>一系列的帧，个数有文件大小和帧长决定每个 FRAM 的长度可能不固定，也可能固定，由位率 bitrate 决定每个 FRAME 由分为帧头和数据实体两部分帧头记录了 mp3 的位率，采样率，版本等信息，每个帧之间相互独立</td>
</tr>
<tr>
<td>ID3V1</td>
<td>包含了作者，作曲，专辑等信息，长度为 128BYTE, 有些音频没有（存疑）</td>
</tr>
</tbody></table>
<h3 id="1-帧头格式"><a href="#1-帧头格式" class="headerlink" title="1. 帧头格式"></a>1. 帧头格式</h3><p>下面是一个头内容图示，使用字符 A 到 M 表示不同的区域。在表格中你可以看到每一区域<br>的详细内容。<br><code>AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM</code></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141012855-1193055958.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141029418-1919208897.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141039777-880575532.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141049012-1279776091.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141105387-1201925425.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141122168-852393751.png"></p>
<p>关于读取帧头我使用了下面的方法<br>定义一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frameHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sync1:<span class="number">8</span>; <span class="comment">//同步信息 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> error_protection:<span class="number">1</span>; <span class="comment">//CRC 校验</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> layer:<span class="number">2</span>; <span class="comment">//层</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version:<span class="number">2</span>; <span class="comment">//版本</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sync2:<span class="number">3</span>; <span class="comment">//同步信息 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extension:<span class="number">1</span>; <span class="comment">//版权</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> padding:<span class="number">1</span>; <span class="comment">//填充空白字</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sample_rate_index:<span class="number">2</span>; <span class="comment">//采样率索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bit_rate_index:<span class="number">4</span>; <span class="comment">//位率索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> emphasis:<span class="number">2</span>; <span class="comment">//强调方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> original:<span class="number">1</span>; <span class="comment">//原始媒体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> copyright:<span class="number">1</span>; <span class="comment">//版权标志</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mode_extension:<span class="number">2</span>; <span class="comment">//扩展模式,仅用于联合立体声</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> channel_mode:<span class="number">2</span>; <span class="comment">//声道模式</span></span><br><span class="line">&#125;FHEADER, *pFHEADER;</span><br></pre></td></tr></table></figure>

<p>请注意我的同步信息分成了两个部分，而且其他的位的顺序也和上表列出的有所差别，这个<br>主要是因为 c 语言在存取数据时总是从低位开始，而这个帧头是需要从高位来读取的。<br>读取方式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FHEADER header;</span><br><span class="line">fread( &amp;header, <span class="keyword">sizeof</span>( FHEADER ), <span class="number">1</span>, streams );<span class="comment">//这里假设文件已打开,读取位置已经指向帧头所在的位置这样一次就可以读入帧头的所有信息了。</span></span><br></pre></td></tr></table></figure>

<h3 id="2、如何计算帧长度"><a href="#2、如何计算帧长度" class="headerlink" title="2、如何计算帧长度"></a>2、如何计算帧长度</h3><p>我们首先区分两个术语：帧大小和帧长度。帧大小即每帧采样数表示一帧中采样的个数，这是恒定值。其值入下表所示</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012145357902-914224524.png"></p>
<p>帧长度是压缩时每一帧的长度，包括帧头。它将填充的空位也计算在内。LayerI 的一个空位长 4 字节，LayerII 和 LayerIII 的空位是 1 字节。当读取 MPEG 文件时必须计算该值以便找到相邻的帧。<br>注意：因为有填充和比特率变换，帧长度可能变化。<br>从头中读取比特率，采样频率和填充，<br>LyaerI 使用公式：</p>
<ul>
<li>帧长度（字节） = (( 每帧采样数 / 8 * 比特率 ) / 采样频率 ) + 填充 * 4</li>
</ul>
<p>LyerII 和 LyaerIII 使用公式：</p>
<ul>
<li>帧长度（字节）= (( 每帧采样数 / 8 * 比特率 ) / 采样频率 ) + 填充</li>
<li>例：<br>LayerIII 比特率 128000, 采样频率 44100, 填充 0<br>=〉帧大小 417 字节</li>
</ul>
<h3 id="3、每帧的持续时间"><a href="#3、每帧的持续时间" class="headerlink" title="3、每帧的持续时间"></a>3、每帧的持续时间</h3><p>之前看了一些文章都说 mp3 的一帧的持续时间是 26ms, 结果在实际程序的编写中发现无法正确按时间定位到帧，然后又查了一些文章才知道，所谓 26ms 一帧只是针对 MPEG1 Layer III 而且采样率为 44.1KHz 来说是对的，但 mp3 文件并不都是如此，其实这个时间也是可以通过计算来获得，下面给出计算公式</p>
<ul>
<li>每帧持续时间（毫秒） = 每帧采样数 / 采样频率 * 1000</li>
</ul>
<p>这样通过计算可知 MPEG1 Layer III 采样率为 44.1KHz 的一帧持续时间为 26.12… 不是整数，不过我们权且认为它就是 26 毫秒吧。<br>如果是 MPEG2 Layer III 采样率为 16KHz 的话那一帧要持续 36 毫秒，这个相差还是蛮大的，所以还是应该通过计算来获的，当然可以按 MPEG 版本，层数和采样率来建一个表，这样直接查表就可以知道时间了。</p>
<h3 id="5、帧数据"><a href="#5、帧数据" class="headerlink" title="5、帧数据"></a>5、帧数据</h3><p>在帧头后边是 Side Info（姑且称之为通道信息）。对标准的立体声 MP3 文件来说其长度为 32 字节。通道信息后面是 Scale factor（增益因子）信息。当解码器在读到上述信息后，就可以进行解码了。当 MP3 文件被打开后，播放器首先试图对帧进行同步，然后分别读取通道信息及增益因子等数据，再进行霍夫曼解码，至此我们已经获得解压后的数据。但这些数据仍然不能进行播放，它们还处于频域，要想听到歌曲还要将它由频域通过特定的手段转换到时域。接下来的处理分别为立体化处理；抗锯齿处理；IMDCT 变换；IDCT 变换及窗口化滑动处理。</p>
<p>我们知道，对于 mp3 来说现在有两种编码方式，一种是 CBR, 也就是固定位率，固定位率的帧的大小在整个文件中都是是固定的（公式如上所述）, 只要知道文件总长度，和从第一帧帧头读出的信息，就都可以通过计算得出这个 mp3 文件的信息，比如总的帧数，总的播放时间等等，要定位到某一帧或某个时间点也很方便，这种编码方式不需要文件头，第一帧开始就是音频数据。另一种是 VBR, 就是可变位率，VBR 是 XING 公司推出的算法，所以在 MP3 的 FRAME 里会有“Xing”这个关键字（也有用”Info”来标识的，现在很多流行的小软件也可以进行 VBR 压缩，它们是否遵守这个约定，那就不得而知了）, 它存放在 MP3 文件中的第一个有效帧的数据区里，它标识了这个 MP3 文件是 VBR 的。同时第一个帧里存放了 MP3 文件的帧的总个数，这就很容易获得了播放总时间，同时还有 100 个字节存放了播放总时间的 100 个时间分段的帧索引，假设 4 分钟的 MP3 歌曲，240S, 分成 100 段，每两个相邻 INDEX 的时间差就是 2.4S, 所以通过这个 INDEX, 只要前后处理少数的 FRAME, 就能快速找出我们需要快进的帧头。其实这第一帧就相当于文件头了。不过现在有些编码器在编码 CBR 文件时也像 VBR 那样将信息记入第一帧，比如著名的 lame, 它使用”Info”来做 CBR 的标记。</p>
<h3 id="6、VBR-头"><a href="#6、VBR-头" class="headerlink" title="6、VBR 头"></a>6、VBR 头</h3><p>这里列出 VBR 的第一帧存储文件信息的头的格式。有两种格式，一种是常见的 XING Header<br>（头部包含字符‘Xing’)<br>, 另一种是 VBRI Header （头部包含字符‘VBRI’) 鉴于 VBRI Header<br>不 常 见 , 下 面 只 说 XING Header , 关 于 VBRI Header 请 看<br><a href="http://www.codeproject.com/audio/MPEGAudioInfo.asp%E3%80%82">http://www.codeproject.com/audio/MPEGAudioInfo.asp。</a><br>XING Header 的起始位置，相对于第一帧帧头的位置，单位是字节<br>36-39 “Xing”<br>21-24 “Xing”<br>21-24 “Xing”<br>13-16 “Xing”<br>文件为 MPEG1 并且不是单声道（大多数 VBR 的 mp3 文件都是如此）<br>文件为 MPEG1 并且是单声道<br>文件为 MPEG2 并且不是单声道<br>文件为 MPEG2 并且是单声道</p>
<p>XING Header 格式</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012145845855-1416090028.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012145854840-1633635283.png"></p>
<p>这样算来，XING Header 包括帧头一共最多只需要 156 个字节就够了。当然也可以在 XING<br>Header 后面存储编码器的信息，比如 lame 在其后就是存储其版本，这需要给第一帧留足够<br>的空间才行。<br>至于 mp3 的信息用从 XING Header 读出的信息就可以计算<br>比如<br>总持续时间 = 总帧数 * 每帧采样数 / 采样率 （结果为秒）<br>平均位率 = 文件长度 / 总持续时间 * 8</p>
<h2 id="MPEG-音频标签"><a href="#MPEG-音频标签" class="headerlink" title="MPEG 音频标签"></a>MPEG 音频标签</h2><p>MPEG 音频标签分为两种，一种是 ID3v1, 存在文件尾部，长度 128 字节，另一种是 ID3v2,<br>是对 ID3v1 的扩展，存在文件头部，长度不定。</p>
<h3 id="1、ID3v1"><a href="#1、ID3v1" class="headerlink" title="1、ID3v1"></a>1、ID3v1</h3><p>ID3v1 标签用来描述 MPEG 音频文件。包含艺术家，标题，唱片集，发布年代和流派。另<br>外还有额外的注释空间。位于音频文件的最后固定为 128 字节。可以读取该文件的最后这<br>128 字节获得标签。<br>结构如下</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">AAABBBBB <span class="keyword">BBBBBBBB </span><span class="keyword">BBBBBBBB </span><span class="keyword">BBBBBBBB</span></span><br><span class="line"><span class="keyword">BCCCCCCC </span>CCCCCCCC CCCCCCCC CCCCCCCD</span><br><span class="line">DDDDDDDD DDDDDDDD DDDDDDDD DDDDDEEE</span><br><span class="line">EFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFG</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150427824-44825799.png"></p>
<p>该规格要求所有的空间必须以空字符 (ASCII 0) 填充。但是并不是所有的应用程序遵循该规<br>则，比如 winamp 就用空格 (ASCII 32) 代替之。<br>在 ID3v1.1 结构中有些改变。注释部分的最后一个字节用来定义唱片集中的轨道号。如果不<br>知道该信息时可以用空字符 (ASCII 0) 代替。<br>流派使用原码表示，为下列数字之一：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150447371-840131951.png"></p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150455027-279783863.png"></p>
<p>Winamp 扩充了这个表</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150511965-812032450.png"></p>
<p>其他任何的数值都认为是“unknown”</p>
<h3 id="2、ID3V2"><a href="#2、ID3V2" class="headerlink" title="2、ID3V2"></a>2、ID3V2</h3><p>ID3V2 到现在一共有 4 个版本，但流行的播放软件一般只支持第 3 版，既 ID3v2.3。由于<br>ID3V1 记录在 MP3 文件的末尾，ID3V2 就只好记录在 MP3 文件的首部了（如果有一天发<br>布 ID3V3, 真不知道该记录在哪里）。也正是由于这个原因，对 ID3V2 的操作比 ID3V1 要<br>慢。而且 ID3V2 结构比 ID3V1 的结构要复杂得多，但比前者全面且可以伸缩和扩展。<br>下面就介绍一下 ID3V2.3。<br>每个 ID3V2.3 的标签都一个标签头和若干个标签帧或一个扩展标签头组成。关于曲目的信息如标题、作者等都存放在不同的标签帧中，扩展标签头和标签帧并不是必要的，但每个标<br>签至少要有一个标签帧。标签头和标签帧一起顺序存放在 MP3 文件的首部。</p>
<h4 id="（一）、标签头"><a href="#（一）、标签头" class="headerlink" title="（一）、标签头"></a>（一）、标签头</h4><p>在文件的首部顺序记录 10 个字节的 ID3V2.3 的头部。数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> Header[<span class="number">3</span>]; <span class="comment">/*必须为&quot;ID3&quot;否则认为标签不存在*/</span></span><br><span class="line"><span class="keyword">char</span> Ver; <span class="comment">/*版本号 ID3V2.3 就记录 3*/</span></span><br><span class="line"><span class="keyword">char</span> Revision; <span class="comment">/*副版本号此版本记录为 0*/</span></span><br><span class="line"><span class="keyword">char</span> Flag; <span class="comment">/*存放标志的字节,这个版本只定义了三位,稍后详细解说*/</span></span><br><span class="line"><span class="keyword">char</span> Size[<span class="number">4</span>]; <span class="comment">/*标签大小,包括标签头的 10 个字节和所有的标签帧的大小*/</span></span><br><span class="line">注:对这里我有疑惑,因为在实际寻找首帧的过程中,我发现有的 mp3 文件的标签大小是不</span><br><span class="line">包含标签头的,但有的又是包含的,可能是某些 mp3 编码器写标签的 BUG,所以为了兼容</span><br><span class="line">只好认为其是包含的,如果按大小找不到,再向后搜索,直到找到首帧为止。</span><br></pre></td></tr></table></figure>

<p><strong>(1). 标志字节</strong></p>
<p>标志字节一般为 0, 定义如下：<br>abc00000<br>a – 表示是否使用 Unsynchronisation（这个单词不知道是什么意思，字典里也没有找到，一般<br>不设置）<br>b – 表示是否有扩展头部，一般没有（至少 Winamp 没有记录）, 所以一般也不设置<br>c – 表示是否为测试标签 (99.99% 的标签都不是测试用的啦，所以一般也不设置）</p>
<p><strong>(2). 标签大小</strong></p>
<p>一共四个字节，但每个字节只用 7 位，最高位不使用恒为 0。所以格式如下<br><code>0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx</code><br>计算大小时要将 0 去掉，得到一个 28 位的二进制数，就是标签大小（不懂为什么要这样做）,<br>计算公式如<br>下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> total_size;</span><br><span class="line">total_size = (<span class="built_in">Size</span>[<span class="number">0</span>]&amp;<span class="number">0</span>x7F)*<span class="number">0</span>x200000</span><br><span class="line">+(<span class="built_in">Size</span>[<span class="number">1</span>]&amp;<span class="number">0</span>x7F)*<span class="number">0</span>x4000</span><br><span class="line">+(<span class="built_in">Size</span>[<span class="number">2</span>]&amp;<span class="number">0</span>x7F)*<span class="number">0</span>x80</span><br><span class="line">+(<span class="built_in">Size</span>[<span class="number">3</span>]&amp;<span class="number">0</span>x7F)</span><br></pre></td></tr></table></figure>

<h4 id="（二）、标签帧"><a href="#（二）、标签帧" class="headerlink" title="（二）、标签帧"></a>（二）、标签帧</h4><p>每个标签帧都有一个 10 个字节的帧头和至少一个字节的不固定长度的内容组成。它们也是<br>顺序存放在文件<br>中，和标签头和其他的标签帧也没有特殊的字符分隔。得到一个完整的帧的内容只有从帧头<br>中的到内容大<br>小后才能读出，读取时要注意大小，不要将其他帧的内容或帧头读入。<br>帧头的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> FrameID[<span class="number">4</span>]; <span class="comment">/*用四个字符标识一个帧,说明其内容,稍后有常用的标识对照表*/</span><span class="keyword">char</span> Size[<span class="number">4</span>]; <span class="comment">/*帧内容的大小,不包括帧头,不得小于 1*/</span></span><br><span class="line"><span class="keyword">char</span> Flags[<span class="number">2</span>]; <span class="comment">/*存放标志,只定义了 6 位,稍后详细解说*/</span></span><br></pre></td></tr></table></figure>

<p><strong>(1). 帧标识</strong></p>
<p>用四个字符标识一个帧，说明一个帧的内容含义，常用的对照如下：<br>TIT2= 标题 表示内容为这首歌的标题，下同<br>TPE1= 作者<br>TALB= 专集<br>TRCK= 音轨 格式：N/M 其中 N 为专集中的第 N 首，M 为专集中共 M 首，N 和 M 为<br>ASCII 码表示的数字<br>TYER= 年代 是用 ASCII 码表示的数字<br>TCON= 类型 直接用字符串表示<br>COMM= 备注 格式：”eng\0 备注内容”, 其中 eng 表示备注所使用的自然语言</p>
<p><strong>(2). 大小</strong></p>
<p>这个可没有标签头的算法那么麻烦，每个字节的 8 位全用，格式如下<br><code>xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</code><br>算法如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> FSize;</span><br><span class="line">FSize = <span class="built_in">Size</span>[<span class="number">0</span>]*<span class="number">0</span>x1000000</span><br><span class="line">+<span class="built_in">Size</span>[<span class="number">1</span>]*<span class="number">0</span>x10000</span><br><span class="line">+<span class="built_in">Size</span>[<span class="number">2</span>]*<span class="number">0</span>x100</span><br><span class="line">+<span class="built_in">Size</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p><strong>(3). 标志</strong></p>
<p>只定义了 6 位，另外的 10 位为 0, 但大部分的情况下 16 位都为 0 就可以了。格式如下：<br><code>abc00000 ijk00000</code><br>a – 标签保护标志，设置时认为此帧作废<br>b – 文件保护标志，设置时认为此帧作废<br>c – 只读标志，设置时认为此帧不能修改（但我没有找到一个软件理会这个标志）<br>i – 压缩标志，设置时一个字节存放两个 BCD 码表示数字<br>j – 加密标志（没有见过哪个 MP3 文件的标签用了加密）<br>k – 组标志，设置时说明此帧和其他的某帧是一组<br>值得一提的是 winamp 在保存和读取帧内容的时候会在内容前面加个’\0’, 并把这个字节计<br>算在帧内容的<br>大小中。<br>附：帧标识的含义</p>
<p><strong>(4). Declared ID3v2 frames</strong></p>
<p>The following frames are declared in this draft.AENC Audio encryption<br>APIC Attached picture<br>COMM Comments<br>COMR Commercial frame<br>ENCR Encryption method registration<br>EQUA Equalization<br>ETCO Event timing codes<br>GEOB General encapsulated object<br>GRID Group identification registration<br>IPLS Involved people list<br>LINK Linked information<br>MCDI Music CD identifier<br>MLLT MPEG location lookup table<br>OWNE Ownership frame<br>PRIV Private frame<br>PCNT Play counter<br>POPM Popularimeter<br>POSS Position synchronisation frame<br>RBUF Recommended buffer size<br>RVAD Relative volume adjustment<br>RVRB Reverb<br>SYLT Synchronized lyric/text<br>SYTC Synchronized tempo codes<br>TALB Album/Movie/Show title<br>TBPM BPM (beats per minute)<br>TCOM Composer<br>TCON Content type<br>TCOP Copyright message<br>TDAT Date<br>TDLY Playlist delay<br>TENC Encoded by<br>TEXT Lyricist/Text writer<br>TFLT File type<br>TIME Time<br>TIT1 Content group description<br>TIT2 Title/songname/content description<br>TIT3 Subtitle/Description refinement<br>TKEY Initial key<br>TLAN Language(s)<br>TLEN Length<br>TMED Media type<br>TOAL Original album/movie/show title<br>TOFN Original filename<br>TOLY Original lyricist(s)/text writer(s)TOPE Original artist(s)/performer(s)<br>TORY Original release year<br>TOWN File owner/licensee<br>TPE1 Lead performer(s)/Soloist(s)<br>TPE2 Band/orchestra/accompaniment<br>TPE3 Conductor/performer refinement<br>TPE4 Interpreted, remixed, or otherwise modified by<br>TPOS Part of a set<br>TPUB Publisher<br>TRCK Track number/Position in set<br>TRDA Recording dates<br>TRSN Internet radio station name<br>TRSO Internet radio station owner<br>TSIZ Size<br>TSRC ISRC (international standard recording code)<br>TSSE Software/Hardware and settings used for encoding<br>TYER Year<br>TXXX User defined text information frame<br>UFID Unique file identifier<br>USER Terms of use<br>USLT Unsychronized lyric/text transcription<br>WCOM Commercial information<br>WCOP Copyright/Legal information<br>WOAF Official audio file webpage<br>WOAR Official artist/performer webpage<br>WOAS Official audio source webpage<br>WORS Official internet radio station homepage<br>WPAY Payment<br>WPUB Publishers official webpage<br>WXXX User defined URL link frame</p>
<h2 id="MP3-文件实例剖析"><a href="#MP3-文件实例剖析" class="headerlink" title="MP3 文件实例剖析"></a>MP3 文件实例剖析</h2><p>打开一个名为 test.mp3 文件，其内容如下：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">000000 FF FB<span class="number"> 52 </span>8C<span class="number"> 00 </span>00<span class="number"> 01 </span>49<span class="number"> 09 </span>C5<span class="number"> 05 </span>24<span class="number"> 60 </span>00 2A C1</span><br><span class="line">000010<span class="number"> 19 </span>40 A6<span class="number"> 00 </span>00<span class="number"> 05 </span>96<span class="number"> 41 </span>34<span class="number"> 18 </span>20<span class="number"> 80 </span>08<span class="number"> 26 </span>48 29</span><br><span class="line">000020<span class="number"> 83 </span>04<span class="number"> 00 </span>01<span class="number"> 61 </span>41<span class="number"> 40 </span>50<span class="number"> 10 </span>04<span class="number"> 00 </span>C1<span class="number"> 21 </span>41<span class="number"> 50 </span>64</span><br><span class="line">......</span><br><span class="line">0000D0 FE FF FB<span class="number"> 52 </span>8C<span class="number"> 11 </span>80<span class="number"> 01 </span>EE<span class="number"> 90 </span>65 6E<span class="number"> 08 </span>20<span class="number"> 02 </span>30</span><br><span class="line">0000E0<span class="number"> 32 </span>0C CD C0<span class="number"> 04 </span>00<span class="number"> 46 </span>16<span class="number"> 41 </span>89 B8<span class="number"> 01 </span>00<span class="number"> 08 </span>36 48</span><br><span class="line">0000F033 B7<span class="number"> 00 </span>00<span class="number"> 01 </span>02 FF FF FF F4 E1 2F FF FF FF FF</span><br><span class="line">......</span><br><span class="line">0001A0 DF FF FF FB<span class="number"> 52 </span>8C<span class="number"> 12 </span>00<span class="number"> 01 </span>FE<span class="number"> 90 </span>58 6E<span class="number"> 09 </span>A0 02</span><br><span class="line">0001B0<span class="number"> 33 </span>B0 CA<span class="number"> 85 </span>E1<span class="number"> 50 </span>01<span class="number"> 45 </span>F6<span class="number"> 19 </span>61 BC<span class="number"> 26 </span>80<span class="number"> 28 </span>7C</span><br><span class="line">0001C0<span class="number"> 05 </span>AC B4<span class="number"> 20 </span>28<span class="number"> 94 </span>FF FF FF FF FF FF FF FF FF FF......</span><br><span class="line">001390 7F FF FF FF FD 4E<span class="number"> 00 </span>54<span class="number"> 41 </span>47<span class="number"> 54 </span>45<span class="number"> 53 </span>54<span class="number"> 00 </span>00</span><br><span class="line">0013A0<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00</span><br><span class="line">......</span><br><span class="line">0013F000<span class="number"> 00 </span>00<span class="number"> 00 </span>04<span class="number"> 19 </span>14<span class="number"> 03 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00 00</span><br><span class="line">001400<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00</span><br><span class="line">001410<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00 4E</span><br></pre></td></tr></table></figure>

<p>该文件长度 1416H(5.142K), 帧头为：FF FB 52 8C, 转换成二进制为：<br><code>11111111 11111011</code><br><code>01010010 10001100</code><br>对照表 1 可知，test.mp3 帧头信息见表 5。<br>表 5 test.mp3 文件帧头信息</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150541215-1878531096.png"><br>第 1397H 开始的三个字节是 54 41 47, 存放的是字符“TAG”, 表示此文件有 ID3 V1.0 信息。<br>139AH 开始的 30 个字节存放歌名，前 4 个非 00 字节是 54 45 53 54, 表示“TEST”;<br>13F4H 开始的 4 个字节是 04 19 14 03, 存放年份“04/25/2003”;<br>最后 1 个字节是 4E, 表示音乐类别，代号为 78, 即“Rock&amp;Roll”;<br>其它字节均为 00, 未存储信息。</p>
<p>原文链接：<a href="https://www.cnblogs.com/ranson7zop/p/7655474.html">https://www.cnblogs.com/ranson7zop/p/7655474.html</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://wenku.baidu.com/view/d4877350ad02de80d4d840cb.html">MP3文件格式解析</a></li>
<li><a href="https://wenku.baidu.com/view/a071bf4e852458fb770b56a0.html">MPEG音频文件格式(包括MP3文件格式)详解</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Audio</category>
      </categories>
      <tags>
        <tag>Audio</tag>
        <tag>MP3</tag>
      </tags>
  </entry>
  <entry>
    <title>MP4 文件格式详解</title>
    <url>/wiki/MP4%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="MP4-文件格式详解"><a href="#MP4-文件格式详解" class="headerlink" title="MP4 文件格式详解"></a>MP4 文件格式详解</h1><p>目前 MP4 的概念被炒得很火，也很乱。最开始 MP4 指的是音频（MP3 的升级版），即 MPEG-2 AAC 标准。随后 MP4 概念被转移到视频上，对应的是 MPEG-4 标准。而现在我们流行的叫法，多半是指能播放 MPEG-4 标准编码格式视频的播放器。但是这篇文章介绍的内容跟上面这些都无关，我们要讨论的是 MP4 文件封装格式，对应的标准为 ISO/IEC 14496-12，即信息技术 视听对象编码的第 12 部分：ISO 基本媒体文件格式（Information technology Coding of audio-visual objects Part 12: ISO base media file format）。ISO/IEC 组织指定的标准一般用数字表示，ISO/IEC 14496 即 MPEG-4 标准。</p>
<p>  MP4 视频文件封装格式是基于 QuickTime 容器格式定义的，因此参考 QuickTime 的格式定义对理解 MP4 文件格式很有帮助。MP4 文件格式是一个十分开放的容器，几乎可以用来描述所有的媒体结构，MP4 文件中的媒体描述与媒体数据是分开的，并且媒体数据的组织也很自由，不一定要按照时间顺序排列，甚至媒体数据可以直接引用其他文件。同时，MP4 也支持流媒体。MP4 目前被广泛用于封装 h.264 视频和 AAC 音频，是高清视频的代表。</p>
<p>  现在我们就来看看 MP4 文件格式到底是什么样的。</p>
<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a><strong>1、概述</strong></h2><p>  MP4 文件中的所有数据都装在 box（QuickTime 中为 atom）中，也就是说 MP4 文件由若干个 box 组成，每个 box 有类型和长度，可以将 box 理解为一个数据对象块。box 中可以包含另一个 box，这种 box 称为 container box。一个 MP4 文件首先会有且只有一个“ftyp”类型的 box，作为 MP4 格式的标志并包含关于文件的一些信息；之后会有且只有一个“moov”类型的 box（Movie Box），它是一种 container box，子 box 包含了媒体的 metadata 信息；MP4 文件的媒体数据包含在“mdat”类型的 box（Midia Data Box）中，该类型的 box 也是 container box，可以有多个，也可以没有（当媒体数据全部引用其他文件时），媒体数据的结构由 metadata 进行描述。</p>
<p>  下面是一些概念：</p>
<p>  <strong><em>track</em></strong> 表示一些 sample 的集合，对于媒体数据来说，track 表示一个视频或音频序列。</p>
<p>  <strong><em>hint track</em></strong> 这个特殊的 track 并不包含媒体数据，而是包含了一些将其他数据 track 打包成流媒体的指示信息。</p>
<p>  <strong><em>sample</em></strong> 对于非 hint track 来说，video sample 即为一帧视频，或一组连续视频帧，audio sample 即为一段连续的压缩音频，它们统称 sample。对于 hint track，sample 定义一个或多个流媒体包的格式。</p>
<p>  <strong><em>sample table</em></strong> 指明 sampe 时序和物理布局的表。</p>
<p>  <strong><em>chunk</em></strong> 一个 track 的几个 sample 组成的单元。</p>
<p>  在本文中，我们不讨论涉及 hint 的内容，只关注包含媒体数据的本地 MP4 文件。下图为一个典型的 MP4 文件的结构树。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103255828-809042371.jpg"></p>
<h2 id="2、Box"><a href="#2、Box" class="headerlink" title="2、Box"></a><strong>2、Box</strong></h2><p>​    首先需要说明的是，box 中的字节序为网络字节序，也就是大端字节序（Big-Endian），简单的说，就是一个 32 位的 4 字节整数存储方式为高位字节在内存的低端。Box 由 header 和 body 组成，其中 header 统一指明 box 的大小和类型，body 根据类型有不同的意义和格式。</p>
<p>​    标准的 box 开头的 4 个字节（32 位）为 box size，该大小包括 box header 和 box body 整个 box 的大小，这样我们就可以在文件中定位各个 box。如果 size 为 1，则表示这个 box 的大小为 large size，真正的 size 值要在 largesize 域上得到。（实际上只有“mdat”类型的 box 才有可能用到 large size。）如果 size 为 0，表示该 box 为文件的最后一个 box，文件结尾即为该 box 结尾。（同样只存在于“mdat”类型的 box 中。）</p>
<p>​    size 后面紧跟的 32 位为 box type，一般是 4 个字符，如“ftyp”、“moov”等，这些 box type 都是已经预定义好的，分别表示固定的意义。如果是“uuid”，表示该 box 为用户扩展类型。如果 box type 是未定义的，应该将其忽略。</p>
<h2 id="3、File-Type-Box（ftyp）"><a href="#3、File-Type-Box（ftyp）" class="headerlink" title="3、File Type Box（ftyp）"></a><strong>3、File Type Box（ftyp）</strong></h2><p>   该 box 有且只有 1 个，并且只能被包含在文件层，而不能被其他 box 包含。该 box 应该被放在文件的最开始，指示该 MP4 文件应用的相关信息。</p>
<p>  “ftyp” body 依次包括 1 个 32 位的 major brand（4 个字符），1 个 32 位的 minor version（整数）和 1 个以 32 位（4 个字符）为单位元素的数组 compatible brands。这些都是用来指示文件应用级别的信息。该 box 的字节实例如下：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103308953-79513465.jpg"></p>
<h2 id="4、Movie-Box（moov）"><a href="#4、Movie-Box（moov）" class="headerlink" title="4、Movie Box（moov）"></a>4、Movie Box（moov）</h2><p>  该 box 包含了文件媒体的 metadata 信息，“moov”是一个 container box，具体内容信息由子 box 诠释。同 File Type Box 一样，该 box 有且只有一个，且只被包含在文件层。一般情况下，“moov”会紧随“ftyp”出现。</p>
<p>  一般情况下（限于篇幅，本文只讲解常见的 MP4 文件结构），“moov”中会包含 1 个“mvhd”和若干个“trak”。其中“mvhd”为 header box，一般作为“moov”的第一个子 box 出现（对于其他 container box 来说，header box 都应作为首个子 box 出现）。“trak”包含了一个 track 的相关信息，是一个 container box。下图为部分“moov”的字节实例，其中红色部分为 box header，绿色为“mvhd”，黄色为一部分“trak”。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103319000-1662662916.jpg"></p>
<h3 id="4-1-Movie-Header-Box（mvhd）"><a href="#4-1-Movie-Header-Box（mvhd）" class="headerlink" title="4.1 Movie Header Box（mvhd）"></a><strong>4.1 Movie Header Box（mvhd）</strong></h3><p>  “mvhd”结构如下表。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字节数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>box size</td>
<td>4</td>
<td>box 大小</td>
</tr>
<tr>
<td>box type</td>
<td>4</td>
<td>box 类型</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td>
</tr>
<tr>
<td>flags</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>creation time</td>
<td>4</td>
<td>创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</td>
</tr>
<tr>
<td>modification time</td>
<td>4</td>
<td>修改时间</td>
</tr>
<tr>
<td>time scale</td>
<td>4</td>
<td>文件媒体在 1 秒时间内的刻度值，可以理解为 1 秒长度的时间单元数</td>
</tr>
<tr>
<td>duration</td>
<td>4</td>
<td>该 track 的时间长度，用 duration 和 time scale 值可以计算 track 时长，比如 audio track 的 time scale = 8000, duration = 560128，时长为 70.016，video track 的 time scale = 600, duration = 42000，时长为 70</td>
</tr>
<tr>
<td>rate</td>
<td>4</td>
<td>推荐播放速率，高 16 位和低 16 位分别为小数点整数部分和小数部分，即 [16.16] 格式，该值为 1.0（0x00010000）表示正常前向播放</td>
</tr>
<tr>
<td>volume</td>
<td>2</td>
<td>与 rate 类似，[8.8] 格式，1.0（0x0100）表示最大音量</td>
</tr>
<tr>
<td>reserved</td>
<td>10</td>
<td>保留位</td>
</tr>
<tr>
<td>matrix</td>
<td>36</td>
<td>视频变换矩阵</td>
</tr>
<tr>
<td>pre-defined</td>
<td>24</td>
<td></td>
</tr>
<tr>
<td>next track id</td>
<td>4</td>
<td>下一个 track 使用的 id 号</td>
</tr>
</tbody></table>
<p>  “mvhd”的字节实例如下图，各字段已经用颜色区分开：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103340343-505155072.jpg"></p>
<h3 id="4-2-Track-Box（trak）"><a href="#4-2-Track-Box（trak）" class="headerlink" title="4.2 Track Box（trak）"></a><strong>4.2 Track Box（trak）</strong></h3><p>  “trak”也是一个 container box，其子 box 包含了该 track 的媒体数据引用和描述（hint track 除外）。一个 MP4 文件中的媒体可以包含多个 track，且至少有一个 track，这些 track 之间彼此独立，有自己的时间和空间信息。“trak”必须包含一个“tkhd”和一个“mdia”，此外还有很多可选的 box（略）。其中“tkhd”为 track header box，“mdia”为 media box，该 box 是一个包含一些 track 媒体数据信息 box 的 container box。</p>
<p>  “trak”的部分字节实例如下图，其中黄色为“trak”box 的头，绿色为“tkhd”，蓝色为“edts”（一个可选 box），红色为一部分“mdia”。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103352140-1758822429.jpg"></p>
<h4 id="4-2-1-Track-Header-Box（tkhd）"><a href="#4-2-1-Track-Header-Box（tkhd）" class="headerlink" title="4.2.1 Track Header Box（tkhd）"></a><strong>4.2.1 Track Header Box（tkhd）</strong></h4><p>  “tkhd”结构如下表。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字节数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>box size</td>
<td>4</td>
<td>box 大小</td>
</tr>
<tr>
<td>box type</td>
<td>4</td>
<td>box 类型</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td>
</tr>
<tr>
<td>flags</td>
<td>3</td>
<td>按位或操作结果值，预定义如下：0x000001 track_enabled，否则该 track 不被播放；0x000002 track_in_movie，表示该 track 在播放中被引用；0x000004 track_in_preview，表示该 track 在预览时被引用。一般该值为 7，如果一个媒体所有 track 均未设置 track_in_movie 和 track_in_preview，将被理解为所有 track 均设置了这两项；对于 hint track，该值为 0</td>
</tr>
<tr>
<td>creation time</td>
<td>4</td>
<td>创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</td>
</tr>
<tr>
<td>modification time</td>
<td>4</td>
<td>修改时间</td>
</tr>
<tr>
<td>track id</td>
<td>4</td>
<td>id 号，不能重复且不能为 0</td>
</tr>
<tr>
<td>reserved</td>
<td>4</td>
<td>保留位</td>
</tr>
<tr>
<td>duration</td>
<td>4</td>
<td>track 的时间长度</td>
</tr>
<tr>
<td>reserved</td>
<td>8</td>
<td>保留位</td>
</tr>
<tr>
<td>layer</td>
<td>2</td>
<td>视频层，默认为 0，值小的在上层</td>
</tr>
<tr>
<td>alternate group</td>
<td>2</td>
<td>track 分组信息，默认为 0 表示该 track 未与其他 track 有群组关系</td>
</tr>
<tr>
<td>volume</td>
<td>2</td>
<td>[8.8] 格式，如果为音频 track，1.0（0x0100）表示最大音量；否则为 0</td>
</tr>
<tr>
<td>reserved</td>
<td>2</td>
<td>保留位</td>
</tr>
<tr>
<td>matrix</td>
<td>36</td>
<td>视频变换矩阵</td>
</tr>
<tr>
<td>width</td>
<td>4</td>
<td>宽</td>
</tr>
<tr>
<td>height</td>
<td>4</td>
<td>高，均为 [16.16] 格式值，与 sample 描述中的实际画面大小比值，用于播放时的展示宽高</td>
</tr>
</tbody></table>
<p>  “tkhd”的字节实例如下图，各字段已经用颜色区分开：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105632828-1690291173.jpg"></p>
<h4 id="4-2-2-Media-Box（mdia）"><a href="#4-2-2-Media-Box（mdia）" class="headerlink" title="4.2.2 Media Box（mdia）"></a><strong>4.2.2 Media Box（mdia）</strong></h4><p>  “mdia”也是个 container box，其子 box 的结构和种类还是比较复杂的。先来看一个“mdia”的实例结构树图。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105617750-494904833.jpg"></p>
<p>​    总体来说，“mdia”定义了 track 媒体类型以及 sample 数据，描述 sample 信息。一般“mdia”包含一个“mdhd”，一个“hdlr”和一个“minf”，其中“mdhd”为 media header box，“hdlr”为 handler reference box，“minf”为 media information box。下面依次看一下这几个 box 的结构。</p>
<h5 id="4-2-2-1-Media-Header-Box（mdhd）"><a href="#4-2-2-1-Media-Header-Box（mdhd）" class="headerlink" title="4.2.2.1 Media Header Box（mdhd）"></a><strong>4.2.2.1 Media Header Box（mdhd）</strong></h5><p>  “mdhd”结构如下表。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字节数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>box size</td>
<td>4</td>
<td>box 大小</td>
</tr>
<tr>
<td>box type</td>
<td>4</td>
<td>box 类型</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td>
</tr>
<tr>
<td>flags</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>creation time</td>
<td>4</td>
<td>创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</td>
</tr>
<tr>
<td>modification time</td>
<td>4</td>
<td>修改时间</td>
</tr>
<tr>
<td>time scale</td>
<td>4</td>
<td>同前表</td>
</tr>
<tr>
<td>duration</td>
<td>4</td>
<td>track 的时间长度</td>
</tr>
<tr>
<td>language</td>
<td>2</td>
<td>媒体语言码。最高位为 0，后面 15 位为 3 个字符（见 ISO 639-2/T 标准中定义）</td>
</tr>
<tr>
<td>pre-defined</td>
<td>2</td>
<td></td>
</tr>
</tbody></table>
<p>  “mdhd”的字节实例如下图，各字段已经用颜色区分开：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105548187-1453820539.jpg"></p>
<h5 id="4-2-2-2-Handler-Reference-Box（hdlr）"><a href="#4-2-2-2-Handler-Reference-Box（hdlr）" class="headerlink" title="4.2.2.2 Handler Reference Box（hdlr）"></a><strong>4.2.2.2 Handler Reference Box（hdlr）</strong></h5><p>  “hdlr”解释了媒体的播放过程信息，该 box 也可以被包含在 meta box（meta）中。“hdlr”结构如下表。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字节数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>box size</td>
<td>4</td>
<td>box 大小</td>
</tr>
<tr>
<td>box type</td>
<td>4</td>
<td>box 类型</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td>
</tr>
<tr>
<td>flags</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>pre-defined</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>handler type</td>
<td>4</td>
<td>在 media box 中，该值为 4 个字符：“vide”— video track“soun”— audio track“hint”— hint track</td>
</tr>
<tr>
<td>reserved</td>
<td>12</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>不定</td>
<td>track type name，以‘\0’结尾的字符串</td>
</tr>
</tbody></table>
<p>  “hdlr”的字节实例如下图，各字段已经用颜色区分开：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105534562-2004584065.jpg"></p>
<h5 id="4-2-2-3-Media-Information-Box（minf）"><a href="#4-2-2-3-Media-Information-Box（minf）" class="headerlink" title="4.2.2.3 Media Information Box（minf）"></a><strong>4.2.2.3 Media Information Box（minf）</strong></h5><p>  “minf”存储了解释 track 媒体数据的 handler-specific 信息，media handler 用这些信息将媒体时间映射到媒体数据并进行处理。“minf”中的信息格式和内容与媒体类型以及解释媒体数据的 media handler 密切相关，其他 media handler 不知道如何解释这些信息。“minf”是一个 container box，其实际内容由子 box 说明。</p>
<p>  一般情况下，“minf”包含一个 header box，一个“dinf”和一个“stbl”，其中，header box 根据 track type（即 media handler type）分为“vmhd”、“smhd”、“hmhd”和“nmhd”，“dinf”为 data information box，“stbl”为 sample table box。下面分别介绍。</p>
<p>  下图为“minf”部分字节实例，其中红色为 box header，蓝色为“smhd”，绿色为“dinf”，黄色为一部分“stbl”。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105523765-1396178666.jpg"></p>
<h6 id="4-2-2-3-1-Media-Information-Header-Box（vmhd、smhd、hmhd、nmhd）"><a href="#4-2-2-3-1-Media-Information-Header-Box（vmhd、smhd、hmhd、nmhd）" class="headerlink" title="4.2.2.3.1 Media Information Header Box（vmhd、smhd、hmhd、nmhd）"></a><strong>4.2.2.3.1 Media Information Header Box（vmhd、smhd、hmhd、nmhd）</strong></h6><p><strong><em>Video Media Header Box（vmhd）</em></strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字节数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>box size</td>
<td>4</td>
<td>box 大小</td>
</tr>
<tr>
<td>box type</td>
<td>4</td>
<td>box 类型</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td>
</tr>
<tr>
<td>flags</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>graphics mode</td>
<td>4</td>
<td>视频合成模式，为 0 时拷贝原始图像，否则与 opcolor 进行合成</td>
</tr>
<tr>
<td>opcolor</td>
<td>2×3</td>
<td>｛red，green，blue｝</td>
</tr>
</tbody></table>
<p><strong><em>Sound Media Header Box（smhd）</em></strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字节数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>box size</td>
<td>4</td>
<td>box 大小</td>
</tr>
<tr>
<td>box type</td>
<td>4</td>
<td>box 类型</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td>
</tr>
<tr>
<td>flags</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>balance</td>
<td>2</td>
<td>立体声平衡，[8.8] 格式值，一般为 0，-1.0 表示全部左声道，1.0 表示全部右声道</td>
</tr>
<tr>
<td>reserved</td>
<td>2</td>
<td></td>
</tr>
</tbody></table>
<p><strong><em>Hint Media Header Box（hmhd）</em></strong></p>
<p>  略</p>
<p><strong><em>Null Media Header Box（nmhd）</em></strong></p>
<p>  非视音频媒体使用该 box，略。</p>
<h6 id="4-2-2-3-2-Data-Information-Box（dinf）"><a href="#4-2-2-3-2-Data-Information-Box（dinf）" class="headerlink" title="4.2.2.3.2 Data Information Box（dinf）"></a><strong>4.2.2.3.2 Data Information Box（dinf）</strong></h6><p>  “dinf”解释如何定位媒体信息，是一个 container box。“dinf”一般包含一个“dref”，即 data reference box；“dref”下会包含若干个“url”或“urn”，这些 box 组成一个表，用来定位 track 数据。简单的说，track 可以被分成若干段，每一段都可以根据“url”或“urn”指向的地址来获取数据，sample 描述中会用这些片段的序号将这些片段组成一个完整的 track。一般情况下，当数据被完全包含在文件中时，“url”或“urn”中的定位字符串是空的。</p>
<p>  “dref”的字节结构如下表。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字节数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>box size</td>
<td>4</td>
<td>box 大小</td>
</tr>
<tr>
<td>box type</td>
<td>4</td>
<td>box 类型</td>
</tr>
<tr>
<td>version</td>
<td>1</td>
<td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td>
</tr>
<tr>
<td>flags</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>entry count</td>
<td>4</td>
<td>“url”或“urn”表的元素个数</td>
</tr>
<tr>
<td>“url”或“urn”列表</td>
<td>不定</td>
<td></td>
</tr>
</tbody></table>
<p>  “url”或“urn”都是 box，“url”的内容为字符串（location string），“urn”的内容为一对字符串（name string and location string）。当“url”或“urn”的 box flag 为 1 时，字符串均为空。</p>
<p>  下面是一个“dinf”的字节实例图。其中黄色为“dinf”的 box header，由红色部分我们知道包含的“url”或“urn”个数为 1，红色后面为“url”box 的内容。紫色为“url”的 box header（根据 box type 我们知道是个“url”），绿色为 box flag，值为 1，说明“url”中的字符串为空，表示 track 数据已包含在文件中。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105445453-359347705.jpg"></p>
<h6 id="4-2-2-3-3-Sample-Table-Box（stbl）"><a href="#4-2-2-3-3-Sample-Table-Box（stbl）" class="headerlink" title="4.2.2.3.3 Sample Table Box（stbl）"></a>4.2.2.3.3 Sample Table Box（stbl）</h6><p>  “stbl”几乎是普通的 MP4 文件中最复杂的一个 box 了，首先需要回忆一下 sample 的概念。sample 是媒体数据存储的单位，存储在 media 的 chunk 中，chunk 和 sample 的长度均可互不相同，如下图所示。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105430750-1558311660.jpg"></p>
<p>  “stbl”包含了关于 track 中 sample 所有时间和位置的信息，以及 sample 的编解码等信息。利用这个表，可以解释 sample 的时序、类型、大小以及在各自存储容器中的位置。“stbl”是一个 container box，其子 box 包括：sample description box（stsd）、time to sample box（stts）、sample size box（stsz 或 stz2）、sample to chunk box（stsc）、chunk offset box（stco 或 co64）、composition time to sample box（ctts）、sync sample box（stss）等。</p>
<p>  “stsd”必不可少，且至少包含一个条目，该 box 包含了 data reference box 进行 sample 数据检索的信息。没有“stsd”就无法计算 media sample 的存储位置。“stsd”包含了编码的信息，其存储的信息随媒体类型不同而不同。</p>
<p><strong><em>Sample Description Box（stsd）</em></strong></p>
<p>  box header 和 version 字段后会有一个 entry count 字段，根据 entry 的个数，每个 entry 会有 type 信息，如“vide”、“sund”等，根据 type 不同 sample description 会提供不同的信息，例如对于 video track，会有“VisualSampleEntry”类型信息，对于 audio track 会有“AudioSampleEntry”类型信息。</p>
<p>  视频的编码类型、宽高、长度，音频的声道、采样等信息都会出现在这个 box 中。</p>
<p><strong><em>Time To Sample Box（stts）</em></strong></p>
<p>  “stts”存储了 sample 的 duration，描述了 sample 时序的映射方法，我们通过它可以找到任何时间的 sample。“stts”可以包含一个压缩的表来映射时间和 sample 序号，用其他的表来提供每个 sample 的长度和指针。表中每个条目提供了在同一个时间偏移量里面连续的 sample 序号，以及 samples 的偏移量。递增这些偏移量，就可以建立一个完整的 time to sample 表。</p>
<p><strong><em>Sample Size Box（stsz）</em></strong></p>
<p>  “stsz” 定义了每个 sample 的大小，包含了媒体中全部 sample 的数目和一张给出每个 sample 大小的表。这个 box 相对来说体积是比较大的。</p>
<p><strong><em>Sample To Chunk Box（stsc）</em></strong></p>
<p>  用 chunk 组织 sample 可以方便优化数据获取，一个 thunk 包含一个或多个 sample。“stsc”中用一个表描述了 sample 与 chunk 的映射关系，查看这张表就可以找到包含指定 sample 的 thunk，从而找到这个 sample。</p>
<p><strong><em>Sync Sample Box（stss）</em></strong></p>
<p>  “stss”确定 media 中的关键帧。对于压缩媒体数据，关键帧是一系列压缩序列的开始帧，其解压缩时不依赖以前的帧，而后续帧的解压缩将依赖于这个关键帧。“stss”可以非常紧凑的标记媒体内的随机存取点，它包含一个 sample 序号表，表内的每一项严格按照 sample 的序号排列，说明了媒体中的哪一个 sample 是关键帧。如果此表不存在，说明每一个 sample 都是一个关键帧，是一个随机存取点。</p>
<p><strong><em>Chunk Offset Box（stco）</em></strong></p>
<p>  “stco”定义了每个 thunk 在媒体流中的位置。位置有两种可能，32 位的和 64 位的，后者对非常大的电影很有用。在一个表中只会有一种可能，这个位置是在整个文件中的，而不是在任何 box 中的，这样做就可以直接在文件中找到媒体数据，而不用解释 box。需要注意的是一旦前面的 box 有了任何改变，这张表都要重新建立，因为位置信息已经改变了。</p>
<p><strong>5、Free Space Box（free 或 skip）</strong></p>
<p>  “free”中的内容是无关紧要的，可以被忽略。该 box 被删除后，不会对播放产生任何影响。</p>
<p><strong>6、Meida Data Box（mdat）</strong></p>
<p>  该 box 包含于文件层，可以有多个，也可以没有（当媒体数据全部为外部文件引用时），用来存储媒体数据。数据直接跟在 box type 字段后面，具体数据结构的意义需要参考 metadata（主要在 sample table 中描述）。</p>
<p>  普通 MP4 文件的结构就讲完了，可能会比较乱，下面这张图是常见的 box 的树结构图，可以用来大致了解 MP4 文件的构造。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105354187-597951417.jpg"></p>
<p>  这篇文章主要面向一些对 MP4 文件结构没有太多了解的初学者，算是篇比较初级的文章，本人也是参考了一些资料写出来的，对于 MP4 文件中涉及的一些概念没有太深入的了解，因此其中应该是有一些错误理解，希望大家抱着批判的眼光读这篇文章。如果有错误的地方，还请大家不吝赐教。</p>
<p>原文链接：<a href="https://www.cnblogs.com/ranson7zop/p/7889272.html">https://www.cnblogs.com/ranson7zop/p/7889272.html</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="http://www.52rd.com/blog/Blog.asp?Name=wqyuwss&Subjectid=559">mp4文件格式</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Video</tag>
        <tag>MP4</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 深浅拷贝</title>
    <url>/wiki/Python%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在很多语言中都存在<strong>深浅拷贝</strong>两种拷贝数据的方式，Python中也不例外。本文中详细介绍了Python中的深浅拷贝的相关知识，文章的内容包含：</p>
<ul>
<li>对象、数据类型、引用</li>
<li>赋值</li>
<li>浅拷贝</li>
<li>深拷贝</li>
</ul>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/20201215230531.png"></p>
<p>我们经常听到：<strong>在Python中一切皆对象</strong>。其实，说的就是我们在Python中构造的任何数据类型都是一个对象，不管是数字、字符串、字典等常见的数据结构，还是函数，甚至是我们导入的模块等，Python都会把它当做是一个对象来处理。</p>
<p>所有的Python对象都拥有3个属性：</p>
<ul>
<li>身份</li>
<li>类型</li>
<li>值</li>
</ul>
<p>我们看一个简单的例子来理解上面的3个属性：</p>
<p>假设我们声明了一个name变量，通过id、type方法能够查看对象的身份和类型：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/20201215230633.png"></p>
<p>甚至是type本身也是一个对象，它也拥有自己的身份、类型：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVZLbmI2V0dtSE9kY2M1VkNPd1pEeXlrUGxYQ09WSVF2TFdKZUlodGJSZjFDdXJNWHJoNnhvUS82NDA" alt="img"></p>
<blockquote>
<p>Python中，万物皆对象</p>
</blockquote>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h3 id="2-1-可变和不可变类型"><a href="#2-1-可变和不可变类型" class="headerlink" title="2.1 可变和不可变类型"></a>2.1 可变和不可变类型</h3><p>在Python中，按照更新对象的方式，我们可以将对象分为2大类：<strong>可变数据类型</strong>和<strong>不可变数据类型</strong>。</p>
<ul>
<li>不可变数据类型：<strong>数值、字符串、布尔值</strong>。不可变对象就是对象的身份和值都不可变。新创建的对象被关联到原来的变量名，旧对象被丢弃，垃圾回收器会在适当的时机回收这些对象。</li>
<li>可变数据类型：<strong>列表、字典、集合</strong>。所谓的可变指的是可变对象的值可变，但是身份是不可变的。</li>
</ul>
<p>首先我们看看不可变对象：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUJ1eVhNcXp0N0NFWTR1WWU0c1M1aWJ2STg1WmNZSk1zUUkxUHBQN0YzZzE5WjR1NGh6NVBWUlEvNjQw" alt="img"></p>
<p>当我们定义了一个对象str1，给其赋值了“python”，便会在内存中找到一个固定的内存地址来存放；但是，当我们将“python”定义成另一个变量名的时候，我们发现：<strong>它在内存中的位置是不变的</strong>。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTVUZlRkQlFRSkp0YU16ZGZhTVZ6dHpBbnExYWNSR0tkYU1KbGUwUXFuandTdWZqZlZDdmt6US82NDA" alt="img"></p>
<p>也就是说，这个变量在计算机内存中的位置是不变的，只是换了一个名字来存放，来看3个实际的例子：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUFzaWJDbXA1RFFBS3dGTEVVaWM4czhFcElIZFlvd3lHVk9YWWMzRDF1Y2Z1eW5nbFhCcUhLQkpnLzY0MA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWsyaWNMSkdwcE1FR2IySUVyZzVzZTNLQzRlMzcwSkZVeHp5YmNpYlc2Yk5SS1drS2paQ3BRdWVBLzY0MA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTlXSmxRd05OMklWZzRNTk51WXk3dmVRMkc2aWFET3NkbE90WE9CUmI2TnV4T2ZkTU0wQXZmMncvNjQw" alt="img"></p>
<p>以上的例子说明：当我们对<strong>字符串、数值型、布尔值</strong>的数据改变变量名，并不会影响到数据在内存中的位置。</p>
<p>我们看看可变类型的例子，列表、字典、集合都是一样的效果：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVRTaHVLbWR0WEZ4Y2hLZFNJcjdPQUZzT2RyZFllR2dFekVJNGliVmQ1aWJpYTZPak1Pd2xpYk1FQ3cvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWJpYXpmcHVxMzZoU0VpY2NwRjRBdzZZVjd6T0tTTkp5WkhpYWR3bTVBOFQ3czVpYUJlN0pETFJ3SlEvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVI5cFE2c1Zkam9sMlh3VDZ6eHp6UEFvRXViaWNiVEppYzNIN0NhdmJjeklYZWM2UkNKTEppYUVqQS82NDA" alt="img"></p>
<p>虽然是相同的数据，但是变量名字不同，<strong>内存中仍然会开辟新的内存地址</strong>来进行存放相同的数据，我们以字典为例：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeU9lZTBpY0tiQkV4TzNvSTRFaWJKaWF2bXE4SW45a0ppYnhrU1RSejhJS09qYlgxQmtjR1Yxb1A3WGcvNjQw" alt="img"></p>
<h3 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h3><p>在Python语言中，每个对象都会在内存中申请开辟一块新的空间来保存对象；对象在内存中所在位置的地址称之为引用。</p>
<p>可以说，我们定义的<strong>变量名实际上就是对象的地址引用</strong>。引用实际上就是内存中的一个数字地址编号。在使用对象的时候，只要知道这个对象的地址，我们就可以操作这个对象。</p>
<p>因为这个数字地址不太容易记忆，所以我们使用变量名的形式来代替对象的数字地址。在Python中，变量就是地址的一种表示形式，并不会开辟新的存储空间。</p>
<p>我们通过一个例子来说明变量和变量指向的引用（内存地址）实际上就是一个东西：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVRPWGliZVZaaWJ5RmhLSlVkb1BJY0Z1RGliTGhIbFNYSWo2QldGTE43NHJEZUk4NE5pYWNHWHlkN3cvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUplTVV0eHlXMXVubnFGS28yVGd1RVNpYlI5T1F3ZUlSY1BFUjZ2U1pQaWNCTmljRllnMTZzSDNDUS82NDA" alt="img"></p>
<h2 id="三、赋值"><a href="#三、赋值" class="headerlink" title="三、赋值"></a>三、赋值</h2><h3 id="3-1-相同数据，不同变量名"><a href="#3-1-相同数据，不同变量名" class="headerlink" title="3.1 相同数据，不同变量名"></a>3.1 相同数据，不同变量名</h3><p>讨论完Python的对象、属性和引用3个重要的概念之后，在正式介绍深浅拷贝之前，我们先讨论Python中的<strong>赋值</strong>。</p>
<p>在Python中，每次赋值都会开辟新的内存地址来存放数据，比如我们同时存放一个列表[1,2,3]，即使数据是相同的，但是内存地址却不同：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWljQkM2UXhBc0hyaWFHN0k5ZFFGYmZ3MlV1Q3lpYUJFVm5ldGJwYjZ5eXltemZWUGtiZmlhZ2ROU1EvNjQw" alt="img"></p>
<p>其实就是两个不同的变量，只是恰好它们存放了相同的数据而已，但是存放的地址是不同的。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeXI0TWoxU1pBSTNPOGFTaWE0VllWT0NrSE9RYzRjRDRsSkZTT0lRSkxrQVhoU2R2aWNmbFpIN3J3LzY0MA" alt="img"></p>
<p>我们给v1列表追加了一个元素，发现它的内存地址是不变的，当然v2肯定是不变的：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVlmM1VpYVhJeXl0OTFIaWFZQlN2MHlteElQODlwa0QwTnlQNnlrU3Q0Q245UEwwRTNyQTFIYmFnLzY0MA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVZFNW94U2ZDNllKeUlxaWJUaWNzelFhSFo2SzRLY01tckppYmV4V1M0RlFvWm1qeXdQTnVDN2JHUS82NDA" alt="img"></p>
<h3 id="3-2-一个变量多次赋值"><a href="#3-2-一个变量多次赋值" class="headerlink" title="3.2 一个变量多次赋值"></a>3.2 一个变量多次赋值</h3><p>如果我们对一个变量多次赋值，其内存是会变化的：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVk3NWliQ2xSeko0OXF1d1lQM3lwNExYdktsVmVnSDhnNmliUmQ2ejQ5aEZoNU9qaWNyUjZxVUF4dy82NDA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTBTbzRkMDJxZkx2aWNJYUZRS1VpY2NkeEJGTXVyaWFTTGliMGhsbHJCZHBrQ2VJNjlpYTFJS0szSFdnLzY0MA" alt="img"></p>
<h3 id="3-3-变量赋值"><a href="#3-3-变量赋值" class="headerlink" title="3.3 变量赋值"></a>3.3 变量赋值</h3><p>将一个变量赋值给另一个变量，其实它们就是同一个对象：数据相同，在内存中的地址也相同：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWZKUVBGSmY0ZE9BQm9QOFBEbjRWcHc0V3dtaGp6WnVsNHRqYTVueEFpYlhXSmxNNXU0SDFNU0EvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUdpY1R6S2hpYmV4UFpPZENoT1hZQkVEMmtjQm9yS3RzTHhIVmZaeUVwa2UyUk56NVZ1aWNmeUpHQS82NDA" alt="img"></p>
<p>当我们给V1追加一个元素，V2也会同时变化：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVRrWjJxZHB1M0tvak54aWNMZVh0QXF6SWh2OEI5SWlhVWxwZk1tU29pYUpjbDBGRjdEdjliaWE3WkEvNjQw" alt="img"></p>
<p>实际上它们就是同一个对象！！！！</p>
<h3 id="3-4-嵌套赋值"><a href="#3-4-嵌套赋值" class="headerlink" title="3.4 嵌套赋值"></a>3.4 嵌套赋值</h3><p>如果是列表中嵌套着另外的列表，那么当改变其中一个列表的时候，另一个列表中的也会随着改变：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVZBd21xaWNtNGsybHJjNlhpYVdrUTlvU2licG9lWnFXMFFrOTRqS2wzMVlqTm5oc1hwQVJ0ejBSUS82NDA" alt="img"></p>
<p>原始数据信息：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTF4UDRoSFppYjVIQ3k4WHNYejhHdzFrRGliUlhsT2d0Vk56NlpZVXMwNTY1NDhwWE5DTWx5ajFRLzY0MA" alt="img"></p>
<p>当我们给v1追加了新元素之后：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeXVJQ3NuUHh2aWFyS2dYbWYwQ0ZUaWNrTENuRXBONjV3Sm5iVDlMR21RV2NieXRoS0lBbjRZTTFnLzY0MA" alt="img"></p>
<p>总结：赋值其实就是将一个对象的地址赋值给一个变量，使得变量指向该内存地址。</p>
<h2 id="四、浅拷贝"><a href="#四、浅拷贝" class="headerlink" title="四、浅拷贝"></a>四、浅拷贝</h2><p>在Python中进行拷贝之前，我们需要导入模块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">copy</span></span><br></pre></td></tr></table></figure>

<p>⚠️<strong>浅拷贝只是拷贝数据的第一层，不会拷贝子对象</strong>。</p>
<h3 id="4-1-不可变类型的浅拷贝"><a href="#4-1-不可变类型的浅拷贝" class="headerlink" title="4.1 不可变类型的浅拷贝"></a>4.1 不可变类型的浅拷贝</h3><p>如果只是针对不可变的数据类型（字符串、数值型、布尔值），浅拷贝的对象和原数据对象是相同的内存地址：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeW9ydE1FdnptbEJNVFhZTldlOGJnWlRNdURTNmpwV3J4dmt4bzNTTlFsbDhZS2pTUkpRc00wUS82NDA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTdmNFhnMHh2aWJ1WHIwVGVOZlZ6b1l4RmljQjhoUzdoMldpY2JtRnliUEJreVlYc1Ribk5raWNQa3cvNjQw" alt="img"></p>
<p>从上面的结果中我们可以看出来：<strong>针对不可变类型的浅拷贝，只是换了一个名字，对象在内存中的地址其实是不变的</strong>。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUx5NEdQTkRsVmVjaWFhcUhLbU5qU1RicGEwZFRFaWFTd2liSUxsSXVkUWFjSnE2Ynd3cm5TR1FQQS82NDA" alt="img"></p>
<p>  image-20201115225938833 </p>
<h3 id="4-2-可变类型的浅拷贝"><a href="#4-2-可变类型的浅拷贝" class="headerlink" title="4.2 可变类型的浅拷贝"></a>4.2 可变类型的浅拷贝</h3><p>首先我们讨论的是不存在嵌套类型的可变类型数据（列表、字典、集合）：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWZpYm5pYTZpYnBpY2hRbVJsTFJiVkZRbHFJcHM1d011ZGlhZkhhTHVRNWlhNm5pYUVUV21sb3duNkRXUFEvNjQw" alt="img"></p>
<p>  image-20201115232303901 </p>
<p>从上面的例子看出来：</p>
<ul>
<li>列表本身的浅拷贝对象的地址和原对象的地址是不同的，因为列表是可变数据类型。</li>
<li>列表中的元素（第1个元素为例）和浅拷贝对象中的第一个元素的地址是相同的，因为<strong>元素本身是数值型，是不可变的</strong>。</li>
</ul>
<p>通过一个图形来说明这个关系：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUxpYkRyZEZ4MGxrbWZUdlN1MXlpYjY3eFhwbU84SEdGNFI2dmtWeXBOWUNvRmJNb1dFcWVjSXZnLzY0MA" alt="img"></p>
<p>字典中也存在相同的情况：字典本身的内存地址不同，但是里面的键、值的内存地址是相同的，因为键值都是不可变类型的数据。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWxERTB0VnpIejZlZ3QwdnRIM3R4ZVBpYmhUN3NlTVV6UFlpYWI5S2xFc2licUlJaWF0bXhTSW52REEvNjQw" alt="img"></p>
<p>如果可变类型的数据中存在嵌套的结构：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWFKc09LaWI1MnJrS0J5QXNvWGRJdm5PckVpY01RaWF5QlVuZjZ6NGZiWm92RlNycld5OFZNS2Jxdy82NDA" alt="img"></p>
<p>从上面的两个例子中我们可以看出来：</p>
<p><strong>在可变类型的数据中，如果存在嵌套的结构类型，浅拷贝只复制最外层的数据，导致内存地址发生变化，里面数据的内存地址不会变</strong>。</p>
<h2 id="五、深拷贝"><a href="#五、深拷贝" class="headerlink" title="五、深拷贝"></a>五、深拷贝</h2><p>深拷贝不同于浅拷贝的是：<strong>深拷贝会拷贝所有的可变数据类型，包含嵌套的数据中的可变数据</strong>。深拷贝是变量对应的值复制到新的内存地址中，而不是复制数据对应的内存地址。</p>
<h3 id="5-1-不可变类型的深拷贝"><a href="#5-1-不可变类型的深拷贝" class="headerlink" title="5.1 不可变类型的深拷贝"></a>5.1 不可变类型的深拷贝</h3><p>关于不可变类型的深浅拷贝，其效果是相同的，具体看下面的例子：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTRDcGlhcE9PdXIyVHFFdzFST1o4SkpKRVRsb2F5MDY4SlhERUN5aHJOdjNpYU5pYTNPT2ljNFVIVkEvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVFOQTgxbmRCUVI1NHRaaWJGbmRoUDdrRjBkNUJqMUpjbFV0aE5pYUxDdThpY0NxelpOQ0YzMXlQUS82NDA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTI2MG1HZEJPUVIxMTFKUUpDOE1rUzE0SmlickM5TTduckxrZUg3enZXZUxOaWJaUmlhczFtb01hdy82NDA" alt="img"></p>
<p>我们得出一个结论：针对<strong>不可变数据类型的深浅拷贝</strong>，其结果是相同的。</p>
<h3 id="5-2-可变类型的深拷贝"><a href="#5-2-可变类型的深拷贝" class="headerlink" title="5.2 可变类型的深拷贝"></a>5.2 可变类型的深拷贝</h3><p>首先我们讨论的是不存在嵌套的情况：</p>
<p><strong>针对列表数据</strong>：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWJqaWJnTnoyWDRTSXREZUFDUU8wclE1WU14bkNnUDBURkpxZFBzSktYOHM3SUtMYU9EMjNCakEvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTVXbWR4eEVFcHBLTDNBQ3MxbW9TYm14dkRScnJpYzJOcWh4MFZlaWNNdWpYNTZIdjVLNHpKOXF3LzY0MA" alt="img"></p>
<p><strong>针对字典数据</strong>：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUhSdHY2bmN2bHZYa0FwaWJZQzVtWTZYcFVWbzhEejJOVFg5ZEdsM0pCY3p1b1N5bTlnRHhRcEEvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUZQZ1NhMm5tQ1NKZTZBU0ZpYmU1TXI0UTA4eWljNGswcVpVcGR3RU5DRWljekNBSmlicm5uNkg1VGcvNjQw" alt="img"></p>
<p>我们可以得出结论：</p>
<ul>
<li>深拷贝对最外层数据是只拷贝数据，会开辟新的内存地址来存放数据。</li>
<li>深拷贝对里面的不可变数据类型直接复制数据和地址，和可变类型的浅拷贝是相同的效果。</li>
</ul>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWNhbVYxb01lSEdpYWxYM2JjSHdXWE5pY2hla01kaWN3MnZOcFVUNU5QRWdyY083ZGd4bmdXeGNYZy82NDA" alt="img"></p>
<p>我们讨论存在嵌套类型的深拷贝（以列表为例）。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWFIbGVHc1VoWWRYTW11bkZ0aWM0alVWMDExdHhobTZvVEYyN25ZRzZSNUc0MEJpY2dyZG9ScDJRLzY0MA" alt="img"></p>
<p><strong>结论1</strong>：对整个存在嵌套类型的数据进行深浅拷贝都会发生内存的变化，因为数据本身是可变的。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVdzUm1MQ2U5VmljVGRjQTZ3dFl3a2JjamliV043VGliZFphYU5TTGc3ZUQxT24wYXZ2aFd0eHhIZy82NDA" alt="img"></p>
<p><strong>结论2</strong>：我们查看第一个元素1的内存地址，发生三者是相同的，因为1是属于数值型，是不可变类型。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVg2Z2gzY3lvam0yaWFkYzBNWmNMaWM2NzBLaWMyZEVrd2RZU041Qk1MYXlveFBHTTl5a0hUV3Nldy82NDA" alt="img"></p>
<p><strong>结论3</strong>：我们查看第三个元素即里面嵌套列表的内存，发现只有深拷贝是不同的，因为这个嵌套的列表是可变数据类型，深拷贝在拷贝了最外层之后还会继续拷贝子层级的可变类型。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWlhNTdyb2MzUGgzSzFLRDlDS1h6eEpwSks5bXhtTWVhd1Z4RGpmdTdySWljUGxUNWozQzdjNWFRLzY0MA" alt="img"></p>
<p><strong>结论4</strong>：我们查看嵌套列表中的元素的内存地址，发现它们是相同的，因为元素是数值型，是不可变的，不受拷贝的影响。</p>
<h2 id="六、元组的深浅拷贝"><a href="#六、元组的深浅拷贝" class="headerlink" title="六、元组的深浅拷贝"></a>六、元组的深浅拷贝</h2><p>元组本身是不可变数据类型，但是其中的值是可以改变的，内部可以有嵌套可变数据类型，比如列表等，会对它的拷贝结果造成影响。</p>
<h3 id="6-1-不存在嵌套结构"><a href="#6-1-不存在嵌套结构" class="headerlink" title="6.1 不存在嵌套结构"></a>6.1 不存在嵌套结构</h3><p>当元组中<strong>不存在嵌套结构</strong>的时候，元组的深浅拷贝是相同的效果：</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUJvN2JtOW1MdmtTYkNPY1hNNDV2bXdSaWFDeWxna0taNU5scFV6VEhxaWF1bks0bnhYWWFJWk5RLzY0MA" alt="img"></p>
<h3 id="6-2-存在嵌套结构"><a href="#6-2-存在嵌套结构" class="headerlink" title="6.2 存在嵌套结构"></a>6.2 存在嵌套结构</h3><p>当元组的数据中存在嵌套的可变类型，比如列表等，<strong>深拷贝会重新开辟地址，将元组重新成成一份</strong>。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUlLZ2FSQndveUtpY3YxVHNVcjdKM0hKbnhTRXgzWEFpY1pxRFNPeHhzYkM4Q2pjZU9GQnJZN2ljZy82NDA" alt="img"></p>
<h2 id="七、is和"><a href="#七、is和" class="headerlink" title="七、is和=="></a>七、is和==</h2><p>在文章的开始就已经谈过：在Python中每个变量都有自己的<strong>标识、类型和值</strong>。每个对象一旦创建，它的标识就绝对不会变。一个对象的标识，我们可以理解成其在内存中的地址。<code>is()</code>运算符比较的是两个对象的标识；<code>id()</code>方法返回的就是对象标识的整数表示。</p>
<p>总结：<code>is()</code>比较对象的标识；<code>==</code>运算符比较两个对象的值（对象中保存的数据）。在实际的编程中，我们更多关注的是值，而不是标识本身。</p>
<p><strong>第一个例子</strong>：<strong>我们创建了两个不同的对象，只是它们的值刚好相同而已</strong>。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVV1U0M5U0p1QzlFdmRZdmliN0dEaWFGa1BSeFVJdVZXeGRRYWliQ0FpYXcxajlsTU1tdnFpY1Z6OUpBLzY0MA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTZtcDZ6WTE0WFhNM2xkTkhQSEFITHV2SHczNkg4NXVSRGlhdTNSQmtaaWNHM3VzV3FhSHk2UXVnLzY0MA" alt="img"></p>
<p><strong>第二个例子</strong>：<strong>我们先创建了一个对象v3，然后将他赋值给另一个对象v4，其实它们就是相同的对象，所以标识（内存地址）是相同的，只是它们的名字不同而已</strong>。</p>
<p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUdXUEhpYk9nYXRMelhKQk15NU95bE9pYlZHS1BMb3FlUVdSVjJtaWJaOEdmRkViVjB0cnJZaWM5Z2cvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeXd5UjlvUWdMYTZoQ3hCampBY05qc2liNDU0WG5aR3ZpYmJWb3RFVVRSaWFmQ3RSeTR4S0xYUmljbHcvNjQw" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过大量的例子，我们得出结论：</p>
<ul>
<li>在不可变数据类型中，深浅拷贝都不会开辟新的内存空间，用的都是同一个内存地址。</li>
<li>在存在嵌套可变类型的数据时，深浅拷贝都会开辟新的一块内存空间；同时，不可变类型的值还是指向原来的值的地址。</li>
</ul>
<p><strong>不同的是</strong>：在嵌套可变类型中，浅拷贝只会拷贝最外层的数据，而深拷贝会拷贝<strong>所有层级</strong>的<strong>可变类型数据</strong>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://mp.weixin.qq.com/s/KrdXyYMtyElUGuPH5eNYvg">https://mp.weixin.qq.com/s/KrdXyYMtyElUGuPH5eNYv</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Language</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
</search>
