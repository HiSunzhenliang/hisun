<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alliswell&#39;s blog</title>
  
  
  <link href="https://alliswell.top/atom.xml" rel="self"/>
  
  <link href="https://alliswell.top/"/>
  <updated>2021-01-26T02:48:56.219Z</updated>
  <id>https://alliswell.top/</id>
  
  <author>
    <name>SunZhenliang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用openmp进行多线程编程</title>
    <link href="https://alliswell.top/wiki/%E4%BD%BF%E7%94%A8openmp%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://alliswell.top/wiki/%E4%BD%BF%E7%94%A8openmp%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-08T06:59:28.000Z</published>
    <updated>2021-01-26T02:48:56.219Z</updated>
    
    <content type="html"><![CDATA[<p>转载:<a href="https://blog.csdn.net/acaiwlj/article/details/49818965">https://blog.csdn.net/acaiwlj/article/details/49818965</a></p><blockquote><p>声明：本文是基于Joel Yliluoma写的Guid into OpenMP:Easy multithreading programming for C++而写的，基本是按照自己的理解，用自己语言组织的。其中大部分例子依然用原来文章的例子，本文仅作为学习笔记之用。</p></blockquote><p>前言<br>多线程在实际的编程中的重要性不言而喻。对于C++而言，当我们需要使用多线程时，可以使用boost::thread库或者自从C++ 11开始支持的std::thread，也可以使用操作系统相关的线程API，如在Linux上，可以使用pthread库。除此之外，还可以使用omp来使用多线程。它的好处是跨平台，使用简单。<br>在Linux平台上，如果需要使用omp，只需在编译时使用”-fopenmp”指令。在Windows的visual studio开发环境中，开启omp支持的步骤为“项目属性 -&gt; C/C++ -&gt; 所有选项 -&gt; openmp支持 -&gt; 是(/openmp)”。<br>本文我们就介绍omp在C++中的使用方法。<br>c++ openmp入门简介<br>openmp是由一系列#paragma指令组成，这些指令控制如何多线程的执行程序。另外，即使编译器不支持omp，程序也也能够正常运行，只是程序不会多线程并行运行。以下为使用omp的简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vecInt</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecInt.size(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    vecInt[i] = i*i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;转载:&lt;a href=&quot;https://blog.csdn.net/acaiwlj/article/details/49818965&quot;&gt;https://blog.csdn.net/acaiwlj/article/details/49818965&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;声明：本文是基于Joel Yliluoma写的Guid into OpenMP:Easy multithreading programming for C++而写的，基本是按照自己的理解，用自己语言组织的。其中大部分例子依然用原来文章的例子，本文仅作为学习笔记之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前言&lt;br&gt;多线程在实际的编程中的重要性不言而喻。对于C++而言，当我们需要使用多线程时，可以使用boost::thread库或者自从C++ 11开始支持的std::thread，也可以使用操作系统相关的线程API，如在Linux上，可以使用pthread库。除此之外，还可以使用omp来使用多线程。它的好处是跨平台，使用简单。&lt;br&gt;在Linux平台上，如果需要使用omp，只需在编译时使用”-fopenmp”指令。在Windows的visual studio开发环境中，开启omp支持的步骤为“项目属性 -&amp;gt; C/C++ -&amp;gt; 所有选项 -&amp;gt; openmp支持 -&amp;gt; 是(/openmp)”。&lt;br&gt;本文我们就介绍omp在C++中的使用方法。&lt;br&gt;c++ openmp入门简介&lt;br&gt;openmp是由一系列#paragma指令组成，这些指令控制如何多线程的执行程序。另外，即使编译器不支持omp，程序也也能够正常运行，只是程序不会多线程并行运行。以下为使用omp的简单的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; &lt;span class=&quot;title&quot;&gt;vecInt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;pragma&lt;/span&gt; omp parallel for&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; vecInt.size(); ++i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vecInt[i] = i*i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
</summary>
    
    
    
    <category term="Multi-threads" scheme="https://alliswell.top/categories/Multi-threads/"/>
    
    
    <category term="多线程" scheme="https://alliswell.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="openmp" scheme="https://alliswell.top/tags/openmp/"/>
    
  </entry>
  
  <entry>
    <title>openmp 的的一点多线程应用</title>
    <link href="https://alliswell.top/wiki/openmp%E7%9A%84%E7%9A%84%E4%B8%80%E7%82%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8/"/>
    <id>https://alliswell.top/wiki/openmp%E7%9A%84%E7%9A%84%E4%B8%80%E7%82%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8/</id>
    <published>2021-01-05T06:57:42.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<p><code>#pragma omp parallel for</code> 的使用</p><p>openmp 一般随 gcc 一起，编译时使用 <code>-fopenmp</code>打开。会多一个<code>_OPENMP</code>宏定义生效，然后就可以用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for <span class="comment">// newline is for-loop</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.ibm.com/support/knowledgecenter/SSGH2K_13.1.2/com.ibm.xlc1312.aix.doc/compiler_ref/tuoptppp.html">tuoptppp</a></li><li><a href="https://www.ibm.com/support/knowledgecenter/SSGH2K_13.1.2/com.ibm.xlc1312.aix.doc/compiler_ref/prag_omp_parallel.html">prag_omp_parallel</a></li><li><a href="https://www.openmp.org/specifications/">https://www.openmp.org/specifications/</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;#pragma omp parallel for&lt;/code&gt; 的使用&lt;/p&gt;
&lt;p&gt;openmp 一般随 gcc 一起，编译时使用 &lt;code&gt;-fopenmp&lt;/code&gt;打开。会多一个&lt;code&gt;_OPENMP&lt;/code&gt;宏定义生效，然后就可以用了。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;pragma&lt;/span&gt; omp parallel for &lt;span class=&quot;comment&quot;&gt;// newline is for-loop&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;i = %d\n&amp;quot;&lt;/span&gt;, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;end\n&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/SSGH2K_13.1.2/com.ibm.xlc1312.aix.doc/compiler_ref/tuoptppp.html&quot;&gt;tuoptppp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/SSGH2K_13.1.2/com.ibm.xlc1312.aix.doc/compiler_ref/prag_omp_parallel.html&quot;&gt;prag_omp_parallel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.openmp.org/specifications/&quot;&gt;https://www.openmp.org/specifications/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</summary>
    
    
    
    <category term="Multi-threads" scheme="https://alliswell.top/categories/Multi-threads/"/>
    
    
    <category term="C" scheme="https://alliswell.top/tags/C/"/>
    
    <category term="多线程" scheme="https://alliswell.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="openmp" scheme="https://alliswell.top/tags/openmp/"/>
    
  </entry>
  
  <entry>
    <title>do...while(0)特殊用法</title>
    <link href="https://alliswell.top/wiki/do-while-0-%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95/"/>
    <id>https://alliswell.top/wiki/do-while-0-%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95/</id>
    <published>2021-01-01T14:53:32.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<p>最近在FFmpeg和sox源码中发现有<code>#define do...while(0)</code>的用法，不太能理解就查了下。发现在Linux内核中也有这些用法。</p><p>总结大概有以下几点：</p><ol><li>空语句编译时会产生警告<code>#define FOO do&#123; &#125; while(0)</code></li><li>创建一个局部空间，可以在其中定义局部变量</li><li>在宏定义中使用复杂语法，单只产生单条语句而不是语句块<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> exch(x,y) &#123; int tmp; tmp=x; x=y; y=tmp; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用上面的宏</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">　　exch(x,y);          <span class="comment">// Branch 1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">　　do_something();     <span class="comment">// Branch 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但展开是这样</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; y) &#123;                <span class="comment">// 单分支if</span></span><br><span class="line">　　<span class="keyword">int</span> tmp;</span><br><span class="line">　　tmp = x;</span><br><span class="line">　　x = y;</span><br><span class="line">　　y = tmp;</span><br><span class="line">&#125;</span><br><span class="line">　;                           <span class="comment">// 空语句</span></span><br><span class="line"><span class="keyword">else</span>                        <span class="comment">// 错误!!! &quot;parse error before else&quot;</span></span><br><span class="line">　　do_something();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用do while</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">　　<span class="keyword">do</span> &#123;</span><br><span class="line">　　<span class="keyword">int</span> tmp;</span><br><span class="line">　　tmp = x;</span><br><span class="line">　　x = y;</span><br><span class="line">　　y = tmp;</span><br><span class="line">　　&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">　　do_something();</span><br></pre></td></tr></table></figure></li></ol><p>具体参考以下内核说明文档<a href="https://kernelnewbies.org/FAQ/DoWhile0">https://kernelnewbies.org/FAQ/DoWhile0</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://kernelnewbies.org/FAQ/DoWhile0">https://kernelnewbies.org/FAQ/DoWhile0</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在FFmpeg和sox源码中发现有&lt;code&gt;#define do...while(0)&lt;/code&gt;的用法，不太能理解就查了下。发现在Linux内核中也有这些用法。&lt;/p&gt;
&lt;p&gt;总结大概有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空语句编译时会产生警告&lt;code&gt;#define FOO do&amp;#123; &amp;#125; while(0)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建一个局部空间，可以在其中定义局部变量&lt;/li&gt;
&lt;li&gt;在宏定义中使用复杂语法，单只产生单条语句而不是语句块&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; exch(x,y) &amp;#123; int tmp; tmp=x; x=y; y=tmp; &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这样调用上面的宏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x &amp;gt; y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　exch(x,y);          &lt;span class=&quot;comment&quot;&gt;// Branch 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　do_something();     &lt;span class=&quot;comment&quot;&gt;// Branch 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 但展开是这样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x &amp;gt; y) &amp;#123;                &lt;span class=&quot;comment&quot;&gt;// 单分支if&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　tmp = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　x = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　y = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　;                           &lt;span class=&quot;comment&quot;&gt;// 空语句&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;                        &lt;span class=&quot;comment&quot;&gt;// 错误!!! &amp;quot;parse error before else&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　do_something();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 采用do while&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x &amp;gt; y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　tmp = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　x = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　y = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　do_something();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体参考以下内核说明文档&lt;a href=&quot;https://kernelnewbies.org/FAQ/DoWhile0&quot;&gt;https://kernelnewbies.org/FAQ/DoWhile0&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kernelnewbies.org/FAQ/DoWhile0&quot;&gt;https://kernelnewbies.org/FAQ/DoWhile0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</summary>
    
    
    
    <category term="Language" scheme="https://alliswell.top/categories/Language/"/>
    
    <category term="C/C++" scheme="https://alliswell.top/categories/Language/C-C/"/>
    
    
    <category term="C++" scheme="https://alliswell.top/tags/C/"/>
    
    <category term="C" scheme="https://alliswell.top/tags/C/"/>
    
    <category term="kernel" scheme="https://alliswell.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>三种存储类型</title>
    <link href="https://alliswell.top/wiki/%E4%B8%89%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://alliswell.top/wiki/%E4%B8%89%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-12-29T05:19:24.000Z</published>
    <updated>2021-01-26T02:48:56.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Storage-Research"><a href="#Storage-Research" class="headerlink" title="Storage Research"></a>Storage Research</h1><h2 id="块存储"><a href="#块存储" class="headerlink" title="块存储"></a>块存储</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>最底层的数据组织方式，所有数据按照固定的大小分块写入，每一块赋予一个用于寻址的编号。</p><h3 id="应用方式："><a href="#应用方式：" class="headerlink" title="应用方式："></a>应用方式：</h3><ol><li>为了方便管理，硬盘这样的块设备通常可以划分为多个逻辑块设备，也就是我们熟悉的硬盘分区（Partition）。</li><li>单个介质的容量、性能有限，可以通过某些技术手段把多个物理块设备组合成一个逻辑块设备，例如各种级别的RAID，JBOD，某些操作系统的卷管理系统（Volume Manager）如Windows的动态磁盘、Linux的LVM等。</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>这种方式的好处当然是因为通过了Raid与LVM等手段，对数据提供了保护；</li><li>可以将多块廉价的硬盘组合起来，称为一个大容量的逻辑盘对外提供服务，提高了容量；</li><li>写入数据时，由于是多块磁盘组合出来的逻辑盘，所以几块硬盘可以并行写入的，提升了读写效率；</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>主机之间数据无法共享，在服务器不做集群的情况下，块存储裸盘映射给主机，在格式化使用后，对于主机来说相当于本地盘，那么主机A的本地盘根本不能给主机B去使用，无法共享数据</li><li>无目录系统</li></ol><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>用“文件”这个概念对这些数据进行组织，所有用于同一用途的数据，按照不同应用程序要求的结构方式组成不同类型的文件（通常用不同的后缀来指代不同的类型），然后我们给每一个文件起一个方便理解记忆的名字。而当文件很多的时候，我们按照某种划分方式给这些文件分组，每一组文件放在同一个目录（或者叫文件夹）里面，当然我们也需要给这些目录起一个容易理解和记忆的名字。而且目录下面除了文件还可以有下一级目录（称之为子目录或者子文件夹），所有的文件、目录形成一个树状结构</p><h3 id="应用方式：-1"><a href="#应用方式：-1" class="headerlink" title="应用方式："></a>应用方式：</h3><p>把存储介质上的数据组织成目录-子目录-文件这种形式的数据结构，用于从这个结构中寻找、添加、修改、删除文件的程序，以及用于维护这个结构的程序，组成的系统有一个专用的名字：<strong>文件系统（File System）</strong></p><p>文件系统有很多，常见的有Windows的FAT/FAT32/NTFS，Linux的EXT2/EXT3/EXT4/XFS/BtrFS等。而在网络存储中，底层数据并非存储在本地的存储介质，而是另外一台服务器上，不同的客户端都可以用类似文件系统的方式访问这台服务器上的文件，这样的系统叫<strong>网络文件系统（Network File System）</strong>，常见的网络文件系统有Windows网络的CIFS（也叫SMB）、类Unix系统网络的NFS等。而文件存储除了网络文件系统外，FTP、HTTP其实也算是文件存储的某种特殊实现，都是可以通过某个url来访问一个文件。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>有目录检索，用户友好。</li><li>方便共享。</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>读写速度较慢，因为需要遍历树状目录结构。</li></ol><h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>对象存储一般体现形式是一个ID，数据和元数据打包在一起作为一个整体对象存在一个超大池子里。对于对象访问，只需要报出它的ID，就能立即找到它，但访问的时候对象是作为一个整体访问的。</p><h3 id="应用方式：-2"><a href="#应用方式：-2" class="headerlink" title="应用方式："></a>应用方式：</h3><ul><li>大多数对象存储的实现本质上是键值对存储系统</li><li>采用扁平化的管理方式(根据键，找到值)<strong>无层次结构</strong></li><li>值可以是任何东西，可以是小文件(小二进制片段)，可以是大文件</li></ul><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>对象存储将元数据独立了出来，控制节点叫元数据服务器（服务器+对象存储管理软件），里面主要负责存储对象的属性（主要是对象的数据被打散存放到了那几台分布式服务器中的信息），而其他负责存储数据的分布式服务器叫做OSD，主要负责存储文件的数据部分。当用户访问对象，会先访问元数据服务器，元数据服务器只负责反馈对象存储在哪些OSD，假设反馈文件A存储在B、C、D三台OSD，那么用户就会再次直接访问3台OSD服务器去读取数据。</p><p>这时候由于是3台OSD同时对外传输数据，所以传输的速度就加快了。当OSD服务器数量越多，这种读写速度的提升就越大，通过此种方式，实现了<strong>读写快</strong>的目的。</p><p>另一方面，对象存储软件是有专门的文件系统的，所以OSD对外又相当于<strong>文件服务器</strong>，那么就不存在文件共享方面的困难了，也解决了文件共享方面的问题。</p><p>所以对象存储的出现，很好地结合了块存储与文件存储的优点。</p><p>对象存储的无层次结构特点，对象存储有以下优点：</p><ul><li>效率更高。不受复杂目录系统对性能的影响。</li><li>可扩展性更强。分布式架构，更便于进行水平扩展，从而容纳进任意大规模的数据。</li><li>可用性更强。数据一般都会有多个位于不同机器的复制，确保数据不丢失。</li></ul><h2 id="三种存储类型的联系"><a href="#三种存储类型的联系" class="headerlink" title="三种存储类型的联系"></a>三种存储类型的联系</h2><p>块存储、文件存储、对象存储的关系：</p><ol><li>它们就是不同的接口。块存储就是最接近存储介质的接口，也就是包装最薄的，或者说没有包装。文件和对象存储都是对块存储的包装。可以简单认为对象存储就是不分层次的文件存储。</li></ol><p>分布式存储的应用场景相对于其存储接口，现在流行分为三种:</p><ol><li>对象存储: 也就是通常意义的键值存储，其接口就是简单的GET、PUT、DEL和其他扩展，如七牛、又拍、Swift、S3</li><li>块存储: 这种接口通常以QEMU Driver或者Kernel Module的方式存在，这种接口需要实现Linux的Block Device的接口或者QEMU提供的Block Driver接口，如Sheepdog，AWS的EBS，青云的云硬盘和阿里云的盘古系统，还有Ceph的RBD（RBD是Ceph面向块存储的接口）</li><li>文件存储: 通常意义是支持POSIX接口，它跟传统的文件系统如Ext4是一个类型的，但区别在于分布式存储提供了并行化的能力，如Ceph的CephFS(CephFS是Ceph面向文件存储的接口)，但是有时候又会把GFS，HDFS这种非POSIX接口的类文件存储接口归入此类。</li></ol><p>元数据管理的差别: </p><ol><li>块存储，服务端不维护元数据，服务端只保留blockid到block的映射关系。</li><li>对象存储，保存简单的元数据，为了管理和隔离，加入了volumn bucket等概念。最根本的存储方面，实际上是以key value形式组织的。其中key之间没有关联，value是block序列组成的对象。</li><li>文件存储的元数据相对对象存储元数据更加复杂，元数据以目录树(inode tree)的形式管理，每个inode tree的文件节点对应一个value是block序列组成的文件。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.zhihu.com/question/21536660">https://www.zhihu.com/question/21536660</a></li><li><a href="https://www.cnblogs.com/hukey/p/8323853.html">https://www.cnblogs.com/hukey/p/8323853.html</a></li><li><a href="https://www.redhat.com/zh/topics/data-storage/file-block-object-storage">https://www.redhat.com/zh/topics/data-storage/file-block-object-storage</a></li><li><a href="https://help.aliyun.com/document_detail/63136.html">https://help.aliyun.com/document_detail/63136.html</a></li><li><a href="https://help.aliyun.com/document_detail/140812.html?spm=a2c4g.11186623.6.543.460845d7sDlUAA">https://help.aliyun.com/document_detail/140812.html?spm=a2c4g.11186623.6.543.460845d7sDlUAA</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Storage-Research&quot;&gt;&lt;a href=&quot;#Storage-Research&quot; class=&quot;headerlink&quot; title=&quot;Storage Research&quot;&gt;&lt;/a&gt;Storage Research&lt;/h1&gt;&lt;h2 id=&quot;块存储&quot;&gt;&lt;a href=&quot;#块存储&quot; class=&quot;headerlink&quot; title=&quot;块存储&quot;&gt;&lt;/a&gt;块存储&lt;/h2&gt;&lt;h3 id=&quot;定义：&quot;&gt;&lt;a href=&quot;#定义：&quot; class=&quot;headerlink&quot; title=&quot;定义：&quot;&gt;&lt;/a&gt;定义：&lt;/h3&gt;&lt;p&gt;最底层的数据组织方式，所有数据按照固定的大小分块写入，每一块赋予一个用于寻址的编号。&lt;/p&gt;
&lt;h3 id=&quot;应用方式：&quot;&gt;&lt;a href=&quot;#应用方式：&quot; class=&quot;headerlink&quot; title=&quot;应用方式：&quot;&gt;&lt;/a&gt;应用方式：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;为了方便管理，硬盘这样的块设备通常可以划分为多个逻辑块设备，也就是我们熟悉的硬盘分区（Partition）。&lt;/li&gt;
&lt;li&gt;单个介质的容量、性能有限，可以通过某些技术手段把多个物理块设备组合成一个逻辑块设备，例如各种级别的RAID，JBOD，某些操作系统的卷管理系统（Volume Manager）如Windows的动态磁盘、Linux的LVM等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;这种方式的好处当然是因为通过了Raid与LVM等手段，对数据提供了保护；&lt;/li&gt;
&lt;li&gt;可以将多块廉价的硬盘组合起来，称为一个大容量的逻辑盘对外提供服务，提高了容量；&lt;/li&gt;
&lt;li&gt;写入数据时，由于是多块磁盘组合出来的逻辑盘，所以几块硬盘可以并行写入的，提升了读写效率；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点&quot;&gt;&lt;/a&gt;缺点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;主机之间数据无法共享，在服务器不做集群的情况下，块存储裸盘映射给主机，在格式化使用后，对于主机来说相当于本地盘，那么主机A的本地盘根本不能给主机B去使用，无法共享数据&lt;/li&gt;
&lt;li&gt;无目录系统&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Storage" scheme="https://alliswell.top/categories/Storage/"/>
    
    
    <category term="存储" scheme="https://alliswell.top/tags/%E5%AD%98%E5%82%A8/"/>
    
    <category term="块存储" scheme="https://alliswell.top/tags/%E5%9D%97%E5%AD%98%E5%82%A8/"/>
    
    <category term="对象存储" scheme="https://alliswell.top/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
    
    <category term="文件存储" scheme="https://alliswell.top/tags/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>视频编解码基础概念</title>
    <link href="https://alliswell.top/wiki/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://alliswell.top/wiki/%E8%A7%86%E9%A2%91%E7%BC%96%E8%A7%A3%E7%A0%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2020-12-18T08:14:39.000Z</published>
    <updated>2021-01-26T02:48:56.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>原始图像信息被采集后，视频数据体积非常大，不利于传输和储存，必须进行编码压缩。播放时只需要采用对应的解码技术就可以恢复播放。<br>本文只涉及这个编解码流程中的基础概念、定义等。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote><p>以下摘录自<a href="https://www.cnblogs.com/leisure_chn/p/10285829.html">https://www.cnblogs.com/leisure_chn/p/10285829.html</a></p></blockquote><h3 id="熵与冗余"><a href="#熵与冗余" class="headerlink" title="熵与冗余"></a>熵与冗余</h3><p>引自参考资料[1]第1.5节</p><blockquote><p>在所有的实际节目素材中，存在着两种类型的信号分量：即异常的、不可预见的信号分量和可以预见的信号分量。异常分量称为<strong>熵</strong>，它是信号中的真正信息。其余部分称为<strong>冗余</strong>，因为它不是必需的信息。冗余可以是空间性的，如在图像的大片区域中，邻近像素几乎具有相同的数值。冗余也可以是时间性的，例如连续图像之间的相似部分。在所有的压缩系统编码器中都是将熵与冗余相分离，只有熵被编码和传输，而在解码器中再从编码器的发送的信号中计算出冗余。</p></blockquote><h3 id="帧内编码"><a href="#帧内编码" class="headerlink" title="帧内编码"></a>帧内编码</h3><p>帧内编码是空间域编码，利用图像空间性冗余度进行图像压缩，处理的是一幅独立的图像，不会跨越多幅图像。空间域编码依赖于一幅图像中相邻像素间的相似性和图案区的主要空间域频率。</p><p>JPEG标准用于静止图像(即图片)，只使用了空间域压缩，只使用帧内编码。</p><h3 id="帧间编码"><a href="#帧间编码" class="headerlink" title="帧间编码"></a>帧间编码</h3><p>帧间编码是时间域编码，是利用一组连续图像间的时间性冗余度进行图像压缩。如果某帧图像可被解码器使用，那么解码器只须利用两帧图像的差异即可得到下一帧图像。比如运动平缓的几帧图像的相似性大，差异性小，而运动剧烈的几幅图像则相似性小，差异性大。当得到一帧完整的图像信息后，可以利用与后一帧图像的差异值推算得到后一帧图像，这样就实现了数据量的压缩。时间域编码依赖于连续图像帧间的相似性，尽可能利用已接收处理的图像信息来“预测”生成当前图像。</p><p>MPEG标准用于运动图像(即视频)，会使用空间域编码和时间域编码，因此是帧内编码和帧间编码结合使用。</p><h3 id="运动矢量"><a href="#运动矢量" class="headerlink" title="运动矢量"></a>运动矢量</h3><p>一组连续图像记录了目标的运动。运动矢量用于衡量两帧图像间目标的运动程度，运动矢量由水平位移量和垂直位移量二者构成。</p><h3 id="运动补偿"><a href="#运动补偿" class="headerlink" title="运动补偿"></a>运动补偿</h3><p>目标的运动降低了图像间的相似性，增加了差异数据量。而运动补偿则通过运行矢量来降低图像间的差异数据量。</p><p>下图为运动补偿的示意图。当某一目标运动时，其位置会变化但形状颜色等基本不变。编码器则可利用运动矢量减低图像差值，解码器根据图像差值中的运动矢量移动目标到合适的位置即可。假设图中是理想情况，目标除移动位置外其他任何属性无任何变化，则两幅图像间的差值仅包含运动矢量这一数据量。显然运动补偿可以显著减少图像差值数据量。<br><img src="https://leichn.github.io/img/avideo_basics/motion_compensation.jpg" alt="图1 运动补偿"></p><h3 id="双向预测"><a href="#双向预测" class="headerlink" title="双向预测"></a>双向预测</h3><p>先看示意图：<br><img src="https://leichn.github.io/img/avideo_basics/bi-directionally_predicted.jpg" alt="图2 双向预测"></p><p>连续的三幅图像中，目标块有垂直位置上的移动，背景块无位置移动。我们考虑如何取得当前帧图像(画面N)：<br>画面N中，目标向上移动后，露出背景块。<br>画面N-1中，因为背景块被目标块遮挡住了，因此没有背景块相关信息。<br>画面N+1中，完整包含背景块的数据，因此画面N可以从画面N-1中取得背景块。<br>如何可以得到画面N呢？解码器可以先解码得到画面N-1和画面N+1，通过画面N-1中的目标块数据结合运动矢量即可得到画面N中的目标块数据，通过画面N+1中的背景块数据则可得到画面N中的背景块数据。三幅画面的解码顺序为：N-1, N+1, N。三幅画面的显示顺序为：N-1, N, N+1。画面N通过其前一幅画面N-1和后一幅画面N+1推算(预测，predicted)得到，因此这种方式称为双向预测(或前向预测、双向参考)。</p><h3 id="I帧-IDR帧-P帧-B帧"><a href="#I帧-IDR帧-P帧-B帧" class="headerlink" title="I帧/IDR帧/P帧/B帧"></a>I帧/IDR帧/P帧/B帧</h3><p><strong>I帧</strong>：I帧(Intra-coded picture, 帧内编码帧，常称为关键帧)包含一幅完整的图像信息，属于帧内编码图像，不含运动矢量，在解码时不需要参考其他帧图像。因此在I帧图像处可以切换频道，而不会导致图像丢失或无法解码。I帧图像用于阻止误差的累积和扩散。在闭合式GOP中，每个GOP的第一个帧一定是I帧，且当前GOP的数据不会参考前后GOP的数据。</p><p><strong>IDR帧</strong>：IDR帧(Instantaneous Decoding Refresh picture, 即时解码刷新帧)是一种特殊的I帧。当解码器解码到IDR帧时，会将DPB(Decoded Picture Buffer，指前后向参考帧列表)清空，将已解码的数据全部输出或抛弃，然后开始一次全新的解码序列。IDR帧之后的图像不会参考IDR帧之前的图像，因此IDR帧可以阻止视频流中的错误传播，同时IDR帧也是解码器、播放器的一个安全访问点。</p><p><strong>P帧</strong>：P帧(Predictive-coded picture, 预测编码图像帧)是帧间编码帧，利用之前的I帧或P帧进行预测编码。</p><p><strong>B帧</strong>：B帧(Bi-directionally predicted picture, 双向预测编码图像帧)是帧间编码帧，利用之前和(或)之后的I帧或P帧进行双向预测编码。B帧不可以作为参考帧。<br>B帧具有更高的压缩率，但需要更多的缓冲时间以及更高的CPU占用率，因此B帧适合本地存储以及视频点播，而不适用对实时性要求较高的直播系统。</p><h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><p>GOP(Group Of Pictures, 图像组)是一组连续的图像，由一个I帧和多个B/P帧组成，是编解码器存取的基本单位。GOP结构常用的两个参数M和N，M指定GOP中两个anchor frame(anchor frame指可被其他帧参考的帧，即I帧或P帧)之间的距离，N指定一个GOP的大小。例如M=3，N=15，GOP结构为：IBBPBBPBBPBBPBB</p><p>TODO: GOP中是否每两个anchor frame的间隔是相同的？推测：未必相同。实际上分析不少视频文件，规律并不一致。此处没有彻底弄清楚，待进一步积累素材、分析与确认。</p><p>GOP有两种：闭合式GOP和开放式GOP：</p><p><strong>闭合式GOP</strong>：闭合式GOP只需要参考本GOP内的图像即可，不需参考前后GOP的数据。这种模式决定了，闭合式GOP的显示顺序总是以I帧开始以P帧结束</p><p>TODO: 闭合式GOP是否一定是以P帧结束？推测：可能未必有此定义。有看到某些视频文件GOP以B帧结束。</p><p><strong>开放式GOP</strong>：开放式GOP中的B帧解码时可能要用到其前一个GOP或后一个GOP的某些帧。码流里面包含B帧的时候才会出现开放式GOP。</p><p>TODO: 开放式GOP是否规定是以B帧开始，P帧结束？推测：可能未必有此定义。是否以B帧开始？网上资料说法不一。是否以P帧结束？有看到某些视频文件GOP以B帧结束。</p><p>在开放式GOP中，普通I帧和IDR帧功能是有差别的，需要明确区分两种帧类型。在闭合式GOP中，普通I帧和IDR帧功能没有差别，可以不作区分。</p><p>开放式GOP和闭合式GOP中I帧、P帧、B帧的依赖关系如下图所示：<br><img src="https://leichn.github.io/img/avideo_basics/gop_mode.jpg" alt="图3 GOP模式"></p><h3 id="DTS和PTS"><a href="#DTS和PTS" class="headerlink" title="DTS和PTS"></a>DTS和PTS</h3><p>DTS(Decoding Time Stamp, 解码时间戳)，表示压缩帧的解码时间。<br>PTS(Presentation Time Stamp, 显示时间戳)，表示将压缩帧解码后得到的原始帧的显示时间。<br>音频中DTS和PTS是相同的。视频中由于B帧需要双向预测，B帧依赖于其前和其后的帧，因此含B帧的视频解码顺序与显示顺序不同，即DTS与PTS不同。当然，不含B帧的视频，其DTS和PTS是相同的。下图以一个开放式GOP示意图为例，说明视频流的解码顺序和显示顺序<br><img src="https://leichn.github.io/img/avideo_basics/decode_order.jpg" alt="图4 解码和显示顺序"><br><strong>采集顺序</strong>指图像传感器采集原始信号得到图像帧的顺序。<br><strong>编码顺序</strong>指编码器编码后图像帧的顺序。存储到磁盘的本地视频文件中图像帧的顺序与编码顺序相同。<br><strong>传输顺序</strong>指编码后的流在网络中传输过程中图像帧的顺序。<br><strong>解码顺序</strong>指解码器解码图像帧的顺序。<br><strong>显示顺序</strong>指图像帧在显示器上显示的顺序。<br><strong>采集顺序与显示顺序相同。编码顺序、传输顺序和解码顺序相同。</strong><br>以图中“B[1]”帧为例进行说明，“B[1]”帧解码时需要参考“I[0]”帧和“P[3]”帧，因此“P[3]”帧必须比“B[1]”帧先解码。这就导致了解码顺序和显示顺序的不一致，后显示的帧需要先解码。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>[1] 泰克Tektronic, MPEG基础和协议分析指南<br>[2] <a href="https://www.jianshu.com/p/04b5b1e4ff27">视频直播的理论知识</a>，<a href="https://www.jianshu.com/p/04b5b1e4ff27">https://www.jianshu.com/p/04b5b1e4ff27</a><br>[3] <a href="https://www.jianshu.com/p/d30c051b4106">open GOP &amp; close GOP</a>, <a href="https://www.jianshu.com/p/d30c051b4106">https://www.jianshu.com/p/d30c051b4106</a><br>[4] <a href="https://blog.csdn.net/abcsunl/article/details/68190136">I帧/B帧/P帧/GOP</a>, <a href="https://blog.csdn.net/abcsunl/article/details/68190136">https://blog.csdn.net/abcsunl/article/details/68190136</a><br>[5] <a href="https://www.jianshu.com/p/3578e794f6b5">FFmpeg音视频同步原理与实现</a>, <a href="https://www.jianshu.com/p/3578e794f6b5">https://www.jianshu.com/p/3578e794f6b5</a><br>[6] <a href="https://www.jianshu.com/p/27279255f67e">FFmpeg音视频同步</a>, <a href="https://www.jianshu.com/p/27279255f67e">https://www.jianshu.com/p/27279255f67e</a><br>[7] <a href="https://www.sciencedirect.com/science/article/pii/S1319157819301867">The GOP Inter Prediction of H.264 AVC</a>, <a href="https://www.sciencedirect.com/science/article/pii/S1319157819301867">https://www.sciencedirect.com/science/article/pii/S1319157819301867</a><br>[8] <a href="https://en.wikipedia.org/wiki/Group_of_pictures">WiKi Group of pictures</a>, <a href="https://en.wikipedia.org/wiki/Group_of_pictures">https://en.wikipedia.org/wiki/Group_of_pictures</a><br>[9] <a href="https://streaminglearningcenter.com/articles/open-and-closed-gops-all-you-need-to-know.html">Open and Closed GOPs – All You Need to Know</a>, <a href="https://streaminglearningcenter.com/articles/open-and-closed-gops-all-you-need-to-know.html">https://streaminglearningcenter.com/articles/open-and-closed-gops-all-you-need-to-know.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;原始图像信息被采集后，视频数据体积非常大，不利于传输和储存，必须进行编码压缩。播放时只需要采用对应的解码技术就可以恢复播放。&lt;br&gt;本文只涉及这个编解码流程中的基础概念、定义等。&lt;/p&gt;
&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以下摘录自&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10285829.html&quot;&gt;https://www.cnblogs.com/leisure_chn/p/10285829.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;熵与冗余&quot;&gt;&lt;a href=&quot;#熵与冗余&quot; class=&quot;headerlink&quot; title=&quot;熵与冗余&quot;&gt;&lt;/a&gt;熵与冗余&lt;/h3&gt;&lt;p&gt;引自参考资料[1]第1.5节&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在所有的实际节目素材中，存在着两种类型的信号分量：即异常的、不可预见的信号分量和可以预见的信号分量。异常分量称为&lt;strong&gt;熵&lt;/strong&gt;，它是信号中的真正信息。其余部分称为&lt;strong&gt;冗余&lt;/strong&gt;，因为它不是必需的信息。冗余可以是空间性的，如在图像的大片区域中，邻近像素几乎具有相同的数值。冗余也可以是时间性的，例如连续图像之间的相似部分。在所有的压缩系统编码器中都是将熵与冗余相分离，只有熵被编码和传输，而在解码器中再从编码器的发送的信号中计算出冗余。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;帧内编码&quot;&gt;&lt;a href=&quot;#帧内编码&quot; class=&quot;headerlink&quot; title=&quot;帧内编码&quot;&gt;&lt;/a&gt;帧内编码&lt;/h3&gt;&lt;p&gt;帧内编码是空间域编码，利用图像空间性冗余度进行图像压缩，处理的是一幅独立的图像，不会跨越多幅图像。空间域编码依赖于一幅图像中相邻像素间的相似性和图案区的主要空间域频率。&lt;/p&gt;
&lt;p&gt;JPEG标准用于静止图像(即图片)，只使用了空间域压缩，只使用帧内编码。&lt;/p&gt;</summary>
    
    
    
    <category term="Video" scheme="https://alliswell.top/categories/Video/"/>
    
    
    <category term="video" scheme="https://alliswell.top/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 开发环境构建</title>
    <link href="https://alliswell.top/wiki/FFmpeg%E5%AE%89%E8%A3%85/"/>
    <id>https://alliswell.top/wiki/FFmpeg%E5%AE%89%E8%A3%85/</id>
    <published>2020-12-18T06:14:59.000Z</published>
    <updated>2021-01-26T02:48:56.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装平台"><a href="#安装平台" class="headerlink" title="安装平台"></a>安装平台</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">             ............</span><br><span class="line">         .&#x27;;;;;;.       .,;,.            ----------</span><br><span class="line">      .,;;;;;;;.       &#x27;;;;;;;;.         OS: Deepin 20 x86_64</span><br><span class="line">    .;::::::::&#x27;     .,::;;,&#x27;&#x27;&#x27;&#x27;&#x27;,.       Model: 10SMCTO1WW ThinkCentre M920t-N000</span><br><span class="line">   ,&#x27;.::::::::    .;;&#x27;.          &#x27;;      Kernel: 5.4.70-amd64-desktop</span><br><span class="line">  ;&#x27;  &#x27;cccccc,   ,&#x27; :: &#x27;..        .:     Uptime: 4 days, 4 hours, 14 minutes</span><br><span class="line"> ,,    :ccccc.  ;: .c, &#x27;&#x27; :.       ,;    Packages: 2561 (dpkg), 9 (snap)</span><br><span class="line">.l.     cllll&#x27; ., .lc  :; .l&#x27;       l.   Shell: zsh 5.7.1</span><br><span class="line">.c       :lllc  ;cl:  .l&#x27; .ll.      :&#x27;   Resolution: 1920x1080</span><br><span class="line">.l        &#x27;looc. .   ,o:  &#x27;oo&#x27;      c,   DE: Deepin</span><br><span class="line">.o.         .:ool::coc&#x27;  .ooo&#x27;      o.   WM: KWin</span><br><span class="line"> ::            .....   .;dddo      ;c    Theme: deepin-dark [GTK2/3]</span><br><span class="line">  l:...            .&#x27;;lddddo.     ,o     Icons: Papirus [GTK3]</span><br><span class="line">   lxxxxxdoolllodxxxxxxxxxc      :l      Terminal: konsole</span><br><span class="line">    ,dxxxxxxxxxxxxxxxxxxl.     &#x27;o,       CPU: Intel i5-9500F (6) @ 4.400GHz</span><br><span class="line">      ,dkkkkkkkkkkkkko;.    .;o;         GPU: AMD ATI Radeon HD 8570 / R7 240/340 / R520 OEM</span><br><span class="line">        .;okkkkkdl;.    .,cl:.           Memory: 4032MiB / 7836MiB</span><br><span class="line">            .,:cccccccc:,.</span><br></pre></td></tr></table></figure><h2 id="安装本体"><a href="#安装本体" class="headerlink" title="安装本体"></a>安装本体</h2><p>ffmpeg-4.3.git<br>官网<a href="https://ffmpeg.org/">https://ffmpeg.org/</a></p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h3><p>Simple DirectMedia Layer 是一个跨平台的开发库，旨在通过 OpenGL 和 Direct3D 提供对音频、键盘、鼠标、操纵杆和图形硬件的低级访问。它用于视频播放软件、模拟器和流行游戏。<br>SDL官网<a href="https://www.libsdl.org/">https://www.libsdl.org/</a></p><h3 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h3><p>Netwide Assembler 是 x86 架构的汇编与反汇编工具。<br>如果在在 arm 等其他平台，交叉编译工具链中包含有对应的汇编器，则交叉编译 ffmpeg 时需要 <code>--disable-x86asm</code> 选项。<br>NASM 官网：<a href="https://www.nasm.us/">https://www.nasm.us/</a></p><h3 id="x264"><a href="#x264" class="headerlink" title="x264"></a>x264</h3><p>x264 是开源的 h264 编码器。<br>ffmpeg 工程中实现了 h264 解码器，但无 h264 编码器。因此需要安装第三方编码器 x264<br>x264 官网<a href="https://www.videolan.org/developers/x264.html">https://www.videolan.org/developers/x264.html</a></p><h3 id="x265"><a href="#x265" class="headerlink" title="x265"></a>x265</h3><p>x265 是开源的 h265 编码器。<br>ffmpeg 工程中实现了 h265 解码器，但无 h265 编码器。因此需要安装第三方编码器 x265<br>x265 官网：<a href="http://www.x265.org/">http://www.x265.org/</a></p><h3 id="libmp3lame"><a href="#libmp3lame" class="headerlink" title="libmp3lame"></a>libmp3lame</h3><p>libmp3lame 是开源的 mp3 编码器。<br>libmp3lame 官网<a href="http://lame.sourceforge.net/">http://lame.sourceforge.net/</a></p><h3 id="libopencore-amr"><a href="#libopencore-amr" class="headerlink" title="libopencore-amr"></a>libopencore-amr</h3><p>libopencore-amr 是开源 amr 编解码器<br>libopencore-amr 官网<a href="https://sourceforge.net/projects/opencore-amr/files/">https://sourceforge.net/projects/opencore-amr/files/</a></p><h2 id="编译安装过程"><a href="#编译安装过程" class="headerlink" title="编译安装过程"></a>编译安装过程</h2><p>先安装上述依赖，一般优先<code>apt install</code>。如果源里没有则下载源码编译安装。</p><p>ffmpeg 不是使用 automake 等工具，而是自己编写的构建脚本。</p><ol><li>configure<br>Configure 一方面用于检测 FFmpeg 的编译环境，另一方面根据用户配置的选项生成 config.mak，config.h 文件（可能还有 config.asm），提供给 Makefile 使用。FFmpeg 的 configure 脚本很复杂（一个 4000-5000 行的 Shell 脚本）。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=PATH \</span><br><span class="line">--enable-sdl \</span><br><span class="line">--enable-gpl \</span><br><span class="line">--enable-version3 \</span><br><span class="line">--enable-libmp3lame \</span><br><span class="line">--enable-debug  \</span><br><span class="line">--enable-libopencore-amrnb \</span><br><span class="line">--enable-libopencore-amrwb \</span><br><span class="line">--enable-libx265 \</span><br><span class="line">--enable-libx264</span><br></pre></td></tr></table></figure><p><code>--enable-gpl</code>、<code>--enable-version3</code>是 ffmpeg 中使用不同的链接动态库需要不同的开源协议支持。一般可以查询官网 wiki 或者脚本会提示需要指定开源协议版本。<br><code>./configure --help</code>查看可用选项。其中 ffmpeg 也内置 fate 测试和检查工具等。<br>2. <code>make</code><br>3. <code>make install</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>ffmpeg -v</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg version N-99648-g0c9cf6ea9a Copyright (c) 2000-2020 the FFmpeg developers</span><br><span class="line">  built with gcc 8 (Uos 8.3.0.3-3+rebuild)</span><br><span class="line">  configuration: --prefix=/home/sun/.local --enable-sdl --enable-gpl --enable-version3 --disable-x86asm --enable-libmp3lame --enable-debug --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libx265 --enable-libx264</span><br><span class="line">  libavutil      56. 60.100 / 56. 60.100</span><br><span class="line">  libavcodec     58.111.101 / 58.111.101</span><br><span class="line">  libavformat    58. 62.100 / 58. 62.100</span><br><span class="line">  libavdevice    58. 11.102 / 58. 11.102</span><br><span class="line">  libavfilter     7. 87.100 /  7. 87.100</span><br><span class="line">  libswscale      5.  8.100 /  5.  8.100</span><br><span class="line">  libswresample   3.  8.100 /  3.  8.100</span><br><span class="line">  libpostproc    55.  8.100 / 55.  8.100</span><br><span class="line">Missing argument for option &#x27;v&#x27;.</span><br><span class="line">Error splitting the argument list: Invalid argument</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://ffmpeg.org/documentation.html">ffmpeg document</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安装平台&quot;&gt;&lt;a href=&quot;#安装平台&quot; class=&quot;headerlink&quot; title=&quot;安装平台&quot;&gt;&lt;/a&gt;安装平台&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;             ............&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         .&amp;#x27;;;;;;.       .,;,.            ----------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .,;;;;;;;.       &amp;#x27;;;;;;;;.         OS: Deepin 20 x86_64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .;::::::::&amp;#x27;     .,::;;,&amp;#x27;&amp;#x27;&amp;#x27;&amp;#x27;&amp;#x27;,.       Model: 10SMCTO1WW ThinkCentre M920t-N000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ,&amp;#x27;.::::::::    .;;&amp;#x27;.          &amp;#x27;;      Kernel: 5.4.70-amd64-desktop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ;&amp;#x27;  &amp;#x27;cccccc,   ,&amp;#x27; :: &amp;#x27;..        .:     Uptime: 4 days, 4 hours, 14 minutes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ,,    :ccccc.  ;: .c, &amp;#x27;&amp;#x27; :.       ,;    Packages: 2561 (dpkg), 9 (snap)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.l.     cllll&amp;#x27; ., .lc  :; .l&amp;#x27;       l.   Shell: zsh 5.7.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.c       :lllc  ;cl:  .l&amp;#x27; .ll.      :&amp;#x27;   Resolution: 1920x1080&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.l        &amp;#x27;looc. .   ,o:  &amp;#x27;oo&amp;#x27;      c,   DE: Deepin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.o.         .:ool::coc&amp;#x27;  .ooo&amp;#x27;      o.   WM: KWin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ::            .....   .;dddo      ;c    Theme: deepin-dark [GTK2/3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  l:...            .&amp;#x27;;lddddo.     ,o     Icons: Papirus [GTK3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   lxxxxxdoolllodxxxxxxxxxc      :l      Terminal: konsole&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ,dxxxxxxxxxxxxxxxxxxl.     &amp;#x27;o,       CPU: Intel i5-9500F (6) @ 4.400GHz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ,dkkkkkkkkkkkkko;.    .;o;         GPU: AMD ATI Radeon HD 8570 / R7 240/340 / R520 OEM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .;okkkkkdl;.    .,cl:.           Memory: 4032MiB / 7836MiB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .,:cccccccc:,.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;安装本体&quot;&gt;&lt;a href=&quot;#安装本体&quot; class=&quot;headerlink&quot; title=&quot;安装本体&quot;&gt;&lt;/a&gt;安装本体&lt;/h2&gt;&lt;p&gt;ffmpeg-4.3.git&lt;br&gt;官网&lt;a href=&quot;https://ffmpeg.org/&quot;&gt;https://ffmpeg.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;安装依赖&lt;/h2&gt;&lt;h3 id=&quot;SDL&quot;&gt;&lt;a href=&quot;#SDL&quot; class=&quot;headerlink&quot; title=&quot;SDL&quot;&gt;&lt;/a&gt;SDL&lt;/h3&gt;&lt;p&gt;Simple DirectMedia Layer 是一个跨平台的开发库，旨在通过 OpenGL 和 Direct3D 提供对音频、键盘、鼠标、操纵杆和图形硬件的低级访问。它用于视频播放软件、模拟器和流行游戏。&lt;br&gt;SDL官网&lt;a href=&quot;https://www.libsdl.org/&quot;&gt;https://www.libsdl.org/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;nasm&quot;&gt;&lt;a href=&quot;#nasm&quot; class=&quot;headerlink&quot; title=&quot;nasm&quot;&gt;&lt;/a&gt;nasm&lt;/h3&gt;&lt;p&gt;Netwide Assembler 是 x86 架构的汇编与反汇编工具。&lt;br&gt;如果在在 arm 等其他平台，交叉编译工具链中包含有对应的汇编器，则交叉编译 ffmpeg 时需要 &lt;code&gt;--disable-x86asm&lt;/code&gt; 选项。&lt;br&gt;NASM 官网：&lt;a href=&quot;https://www.nasm.us/&quot;&gt;https://www.nasm.us/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;x264&quot;&gt;&lt;a href=&quot;#x264&quot; class=&quot;headerlink&quot; title=&quot;x264&quot;&gt;&lt;/a&gt;x264&lt;/h3&gt;</summary>
    
    
    
    <category term="Video" scheme="https://alliswell.top/categories/Video/"/>
    
    <category term="FFmpeg" scheme="https://alliswell.top/categories/Video/FFmpeg/"/>
    
    
    <category term="FFmpeg" scheme="https://alliswell.top/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>sip协议学习</title>
    <link href="https://alliswell.top/wiki/sip%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://alliswell.top/wiki/sip%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-12-16T06:29:36.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sip协议学习"><a href="#sip协议学习" class="headerlink" title="sip协议学习"></a>sip协议学习</h1><p>最近项目接触到几个通讯协议, 这里来学习一下.</p><h2 id="sip简介"><a href="#sip简介" class="headerlink" title="sip简介"></a>sip简介</h2><p>SIP（Session Initiation Protocol，会话初始协议）, 一种多媒体通讯协议, 支持并应用于语言、视频等多媒体业务。<br>SIP is an application-layer control protocol that can establish,<br>modify, and terminate multimedia sessions (conferences) such as<br>Internet telephony calls.</p><p>SIP协议总的来说就是一堆协议拼起来使用。实现媒体通信、控制等业务功能。</p><p>注意，SIP消息和具体的媒体流并不是在一个层面运作的。例如，一个VoIP电话是先通过SIP信令完成交互后再开始具体媒体流的传输的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://tools.ietf.org/html/rfc3428">Session Initiation Protocol (SIP) Extension for Instant Messaging</a></li><li><a href="https://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a></li><li><a href="https://www.cnblogs.com/xiaxveliang/p/12434170.html">SIP 协议详解</a></li><li><a href="https://www.cnblogs.com/gnuhpc/archive/2012/01/16/2323637.html">【SIP协议】学习初学笔记</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;sip协议学习&quot;&gt;&lt;a href=&quot;#sip协议学习&quot; class=&quot;headerlink&quot; title=&quot;sip协议学习&quot;&gt;&lt;/a&gt;sip协议学习&lt;/h1&gt;&lt;p&gt;最近项目接触到几个通讯协议, 这里来学习一下.&lt;/p&gt;
&lt;h2 id=&quot;sip简介&quot;&gt;&lt;a href=&quot;#sip简介&quot; class=&quot;headerlink&quot; title=&quot;sip简介&quot;&gt;&lt;/a&gt;sip简介&lt;/h2&gt;&lt;p&gt;SIP（Session Initiation Protocol，会话初始协议）, 一种多媒体通讯协议, 支持并应用于语言、视频等多媒体业务。&lt;br&gt;SIP is an application-layer control protocol that can establish,&lt;br&gt;modify, and terminate multimedia sessions (conferences) such as&lt;br&gt;Internet telephony calls.&lt;/p&gt;
&lt;p&gt;SIP协议总的来说就是一堆协议拼起来使用。实现媒体通信、控制等业务功能。&lt;/p&gt;
&lt;p&gt;注意，SIP消息和具体的媒体流并不是在一个层面运作的。例如，一个VoIP电话是先通过SIP信令完成交互后再开始具体媒体流的传输的。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3428&quot;&gt;Session Initiation Protocol (SIP) Extension for Instant Messaging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3261&quot;&gt;SIP: Session Initiation Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaxveliang/p/12434170.html&quot;&gt;SIP 协议详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/gnuhpc/archive/2012/01/16/2323637.html&quot;&gt;【SIP协议】学习初学笔记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</summary>
    
    
    
    <category term="Protocols" scheme="https://alliswell.top/categories/Protocols/"/>
    
    
    <category term="Protocol" scheme="https://alliswell.top/tags/Protocol/"/>
    
    <category term="SIP" scheme="https://alliswell.top/tags/SIP/"/>
    
    <category term="通信" scheme="https://alliswell.top/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python 深浅拷贝</title>
    <link href="https://alliswell.top/wiki/Python%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://alliswell.top/wiki/Python%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-12-14T08:02:10.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在很多语言中都存在<strong>深浅拷贝</strong>两种拷贝数据的方式，Python中也不例外。本文中详细介绍了Python中的深浅拷贝的相关知识，文章的内容包含：</p><ul><li>对象、数据类型、引用</li><li>赋值</li><li>浅拷贝</li><li>深拷贝</li></ul><p><img src="https://gitee.com/SunGitee/src/raw/master/img/20201215230531.png"></p><p>我们经常听到：<strong>在Python中一切皆对象</strong>。其实，说的就是我们在Python中构造的任何数据类型都是一个对象，不管是数字、字符串、字典等常见的数据结构，还是函数，甚至是我们导入的模块等，Python都会把它当做是一个对象来处理。</p><p>所有的Python对象都拥有3个属性：</p><ul><li>身份</li><li>类型</li><li>值</li></ul><p>我们看一个简单的例子来理解上面的3个属性：</p><p>假设我们声明了一个name变量，通过id、type方法能够查看对象的身份和类型：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/20201215230633.png"></p><p>甚至是type本身也是一个对象，它也拥有自己的身份、类型：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVZLbmI2V0dtSE9kY2M1VkNPd1pEeXlrUGxYQ09WSVF2TFdKZUlodGJSZjFDdXJNWHJoNnhvUS82NDA" alt="img"></p><blockquote><p>Python中，万物皆对象</p></blockquote><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h3 id="2-1-可变和不可变类型"><a href="#2-1-可变和不可变类型" class="headerlink" title="2.1 可变和不可变类型"></a>2.1 可变和不可变类型</h3><p>在Python中，按照更新对象的方式，我们可以将对象分为2大类：<strong>可变数据类型</strong>和<strong>不可变数据类型</strong>。</p><ul><li>不可变数据类型：<strong>数值、字符串、布尔值</strong>。不可变对象就是对象的身份和值都不可变。新创建的对象被关联到原来的变量名，旧对象被丢弃，垃圾回收器会在适当的时机回收这些对象。</li><li>可变数据类型：<strong>列表、字典、集合</strong>。所谓的可变指的是可变对象的值可变，但是身份是不可变的。</li></ul><p>首先我们看看不可变对象：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUJ1eVhNcXp0N0NFWTR1WWU0c1M1aWJ2STg1WmNZSk1zUUkxUHBQN0YzZzE5WjR1NGh6NVBWUlEvNjQw" alt="img"></p><p>当我们定义了一个对象str1，给其赋值了“python”，便会在内存中找到一个固定的内存地址来存放；但是，当我们将“python”定义成另一个变量名的时候，我们发现：<strong>它在内存中的位置是不变的</strong>。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTVUZlRkQlFRSkp0YU16ZGZhTVZ6dHpBbnExYWNSR0tkYU1KbGUwUXFuandTdWZqZlZDdmt6US82NDA" alt="img"></p><p>也就是说，这个变量在计算机内存中的位置是不变的，只是换了一个名字来存放，来看3个实际的例子：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUFzaWJDbXA1RFFBS3dGTEVVaWM4czhFcElIZFlvd3lHVk9YWWMzRDF1Y2Z1eW5nbFhCcUhLQkpnLzY0MA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWsyaWNMSkdwcE1FR2IySUVyZzVzZTNLQzRlMzcwSkZVeHp5YmNpYlc2Yk5SS1drS2paQ3BRdWVBLzY0MA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTlXSmxRd05OMklWZzRNTk51WXk3dmVRMkc2aWFET3NkbE90WE9CUmI2TnV4T2ZkTU0wQXZmMncvNjQw" alt="img"></p><p>以上的例子说明：当我们对<strong>字符串、数值型、布尔值</strong>的数据改变变量名，并不会影响到数据在内存中的位置。</p><p>我们看看可变类型的例子，列表、字典、集合都是一样的效果：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVRTaHVLbWR0WEZ4Y2hLZFNJcjdPQUZzT2RyZFllR2dFekVJNGliVmQ1aWJpYTZPak1Pd2xpYk1FQ3cvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWJpYXpmcHVxMzZoU0VpY2NwRjRBdzZZVjd6T0tTTkp5WkhpYWR3bTVBOFQ3czVpYUJlN0pETFJ3SlEvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVI5cFE2c1Zkam9sMlh3VDZ6eHp6UEFvRXViaWNiVEppYzNIN0NhdmJjeklYZWM2UkNKTEppYUVqQS82NDA" alt="img"></p><p>虽然是相同的数据，但是变量名字不同，<strong>内存中仍然会开辟新的内存地址</strong>来进行存放相同的数据，我们以字典为例：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeU9lZTBpY0tiQkV4TzNvSTRFaWJKaWF2bXE4SW45a0ppYnhrU1RSejhJS09qYlgxQmtjR1Yxb1A3WGcvNjQw" alt="img"></p><h3 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h3><p>在Python语言中，每个对象都会在内存中申请开辟一块新的空间来保存对象；对象在内存中所在位置的地址称之为引用。</p><p>可以说，我们定义的<strong>变量名实际上就是对象的地址引用</strong>。引用实际上就是内存中的一个数字地址编号。在使用对象的时候，只要知道这个对象的地址，我们就可以操作这个对象。</p><p>因为这个数字地址不太容易记忆，所以我们使用变量名的形式来代替对象的数字地址。在Python中，变量就是地址的一种表示形式，并不会开辟新的存储空间。</p><p>我们通过一个例子来说明变量和变量指向的引用（内存地址）实际上就是一个东西：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVRPWGliZVZaaWJ5RmhLSlVkb1BJY0Z1RGliTGhIbFNYSWo2QldGTE43NHJEZUk4NE5pYWNHWHlkN3cvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUplTVV0eHlXMXVubnFGS28yVGd1RVNpYlI5T1F3ZUlSY1BFUjZ2U1pQaWNCTmljRllnMTZzSDNDUS82NDA" alt="img"></p><h2 id="三、赋值"><a href="#三、赋值" class="headerlink" title="三、赋值"></a>三、赋值</h2><h3 id="3-1-相同数据，不同变量名"><a href="#3-1-相同数据，不同变量名" class="headerlink" title="3.1 相同数据，不同变量名"></a>3.1 相同数据，不同变量名</h3><p>讨论完Python的对象、属性和引用3个重要的概念之后，在正式介绍深浅拷贝之前，我们先讨论Python中的<strong>赋值</strong>。</p><p>在Python中，每次赋值都会开辟新的内存地址来存放数据，比如我们同时存放一个列表[1,2,3]，即使数据是相同的，但是内存地址却不同：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWljQkM2UXhBc0hyaWFHN0k5ZFFGYmZ3MlV1Q3lpYUJFVm5ldGJwYjZ5eXltemZWUGtiZmlhZ2ROU1EvNjQw" alt="img"></p><p>其实就是两个不同的变量，只是恰好它们存放了相同的数据而已，但是存放的地址是不同的。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeXI0TWoxU1pBSTNPOGFTaWE0VllWT0NrSE9RYzRjRDRsSkZTT0lRSkxrQVhoU2R2aWNmbFpIN3J3LzY0MA" alt="img"></p><p>我们给v1列表追加了一个元素，发现它的内存地址是不变的，当然v2肯定是不变的：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVlmM1VpYVhJeXl0OTFIaWFZQlN2MHlteElQODlwa0QwTnlQNnlrU3Q0Q245UEwwRTNyQTFIYmFnLzY0MA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVZFNW94U2ZDNllKeUlxaWJUaWNzelFhSFo2SzRLY01tckppYmV4V1M0RlFvWm1qeXdQTnVDN2JHUS82NDA" alt="img"></p><h3 id="3-2-一个变量多次赋值"><a href="#3-2-一个变量多次赋值" class="headerlink" title="3.2 一个变量多次赋值"></a>3.2 一个变量多次赋值</h3><p>如果我们对一个变量多次赋值，其内存是会变化的：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVk3NWliQ2xSeko0OXF1d1lQM3lwNExYdktsVmVnSDhnNmliUmQ2ejQ5aEZoNU9qaWNyUjZxVUF4dy82NDA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTBTbzRkMDJxZkx2aWNJYUZRS1VpY2NkeEJGTXVyaWFTTGliMGhsbHJCZHBrQ2VJNjlpYTFJS0szSFdnLzY0MA" alt="img"></p><h3 id="3-3-变量赋值"><a href="#3-3-变量赋值" class="headerlink" title="3.3 变量赋值"></a>3.3 变量赋值</h3><p>将一个变量赋值给另一个变量，其实它们就是同一个对象：数据相同，在内存中的地址也相同：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWZKUVBGSmY0ZE9BQm9QOFBEbjRWcHc0V3dtaGp6WnVsNHRqYTVueEFpYlhXSmxNNXU0SDFNU0EvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUdpY1R6S2hpYmV4UFpPZENoT1hZQkVEMmtjQm9yS3RzTHhIVmZaeUVwa2UyUk56NVZ1aWNmeUpHQS82NDA" alt="img"></p><p>当我们给V1追加一个元素，V2也会同时变化：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVRrWjJxZHB1M0tvak54aWNMZVh0QXF6SWh2OEI5SWlhVWxwZk1tU29pYUpjbDBGRjdEdjliaWE3WkEvNjQw" alt="img"></p><p>实际上它们就是同一个对象！！！！</p><h3 id="3-4-嵌套赋值"><a href="#3-4-嵌套赋值" class="headerlink" title="3.4 嵌套赋值"></a>3.4 嵌套赋值</h3><p>如果是列表中嵌套着另外的列表，那么当改变其中一个列表的时候，另一个列表中的也会随着改变：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVZBd21xaWNtNGsybHJjNlhpYVdrUTlvU2licG9lWnFXMFFrOTRqS2wzMVlqTm5oc1hwQVJ0ejBSUS82NDA" alt="img"></p><p>原始数据信息：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTF4UDRoSFppYjVIQ3k4WHNYejhHdzFrRGliUlhsT2d0Vk56NlpZVXMwNTY1NDhwWE5DTWx5ajFRLzY0MA" alt="img"></p><p>当我们给v1追加了新元素之后：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeXVJQ3NuUHh2aWFyS2dYbWYwQ0ZUaWNrTENuRXBONjV3Sm5iVDlMR21RV2NieXRoS0lBbjRZTTFnLzY0MA" alt="img"></p><p>总结：赋值其实就是将一个对象的地址赋值给一个变量，使得变量指向该内存地址。</p><h2 id="四、浅拷贝"><a href="#四、浅拷贝" class="headerlink" title="四、浅拷贝"></a>四、浅拷贝</h2><p>在Python中进行拷贝之前，我们需要导入模块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">copy</span></span><br></pre></td></tr></table></figure><p>⚠️<strong>浅拷贝只是拷贝数据的第一层，不会拷贝子对象</strong>。</p><h3 id="4-1-不可变类型的浅拷贝"><a href="#4-1-不可变类型的浅拷贝" class="headerlink" title="4.1 不可变类型的浅拷贝"></a>4.1 不可变类型的浅拷贝</h3><p>如果只是针对不可变的数据类型（字符串、数值型、布尔值），浅拷贝的对象和原数据对象是相同的内存地址：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeW9ydE1FdnptbEJNVFhZTldlOGJnWlRNdURTNmpwV3J4dmt4bzNTTlFsbDhZS2pTUkpRc00wUS82NDA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTdmNFhnMHh2aWJ1WHIwVGVOZlZ6b1l4RmljQjhoUzdoMldpY2JtRnliUEJreVlYc1Ribk5raWNQa3cvNjQw" alt="img"></p><p>从上面的结果中我们可以看出来：<strong>针对不可变类型的浅拷贝，只是换了一个名字，对象在内存中的地址其实是不变的</strong>。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUx5NEdQTkRsVmVjaWFhcUhLbU5qU1RicGEwZFRFaWFTd2liSUxsSXVkUWFjSnE2Ynd3cm5TR1FQQS82NDA" alt="img"></p><p>  image-20201115225938833 </p><h3 id="4-2-可变类型的浅拷贝"><a href="#4-2-可变类型的浅拷贝" class="headerlink" title="4.2 可变类型的浅拷贝"></a>4.2 可变类型的浅拷贝</h3><p>首先我们讨论的是不存在嵌套类型的可变类型数据（列表、字典、集合）：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWZpYm5pYTZpYnBpY2hRbVJsTFJiVkZRbHFJcHM1d011ZGlhZkhhTHVRNWlhNm5pYUVUV21sb3duNkRXUFEvNjQw" alt="img"></p><p>  image-20201115232303901 </p><p>从上面的例子看出来：</p><ul><li>列表本身的浅拷贝对象的地址和原对象的地址是不同的，因为列表是可变数据类型。</li><li>列表中的元素（第1个元素为例）和浅拷贝对象中的第一个元素的地址是相同的，因为<strong>元素本身是数值型，是不可变的</strong>。</li></ul><p>通过一个图形来说明这个关系：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUxpYkRyZEZ4MGxrbWZUdlN1MXlpYjY3eFhwbU84SEdGNFI2dmtWeXBOWUNvRmJNb1dFcWVjSXZnLzY0MA" alt="img"></p><p>字典中也存在相同的情况：字典本身的内存地址不同，但是里面的键、值的内存地址是相同的，因为键值都是不可变类型的数据。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWxERTB0VnpIejZlZ3QwdnRIM3R4ZVBpYmhUN3NlTVV6UFlpYWI5S2xFc2licUlJaWF0bXhTSW52REEvNjQw" alt="img"></p><p>如果可变类型的数据中存在嵌套的结构：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWFKc09LaWI1MnJrS0J5QXNvWGRJdm5PckVpY01RaWF5QlVuZjZ6NGZiWm92RlNycld5OFZNS2Jxdy82NDA" alt="img"></p><p>从上面的两个例子中我们可以看出来：</p><p><strong>在可变类型的数据中，如果存在嵌套的结构类型，浅拷贝只复制最外层的数据，导致内存地址发生变化，里面数据的内存地址不会变</strong>。</p><h2 id="五、深拷贝"><a href="#五、深拷贝" class="headerlink" title="五、深拷贝"></a>五、深拷贝</h2><p>深拷贝不同于浅拷贝的是：<strong>深拷贝会拷贝所有的可变数据类型，包含嵌套的数据中的可变数据</strong>。深拷贝是变量对应的值复制到新的内存地址中，而不是复制数据对应的内存地址。</p><h3 id="5-1-不可变类型的深拷贝"><a href="#5-1-不可变类型的深拷贝" class="headerlink" title="5.1 不可变类型的深拷贝"></a>5.1 不可变类型的深拷贝</h3><p>关于不可变类型的深浅拷贝，其效果是相同的，具体看下面的例子：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTRDcGlhcE9PdXIyVHFFdzFST1o4SkpKRVRsb2F5MDY4SlhERUN5aHJOdjNpYU5pYTNPT2ljNFVIVkEvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVFOQTgxbmRCUVI1NHRaaWJGbmRoUDdrRjBkNUJqMUpjbFV0aE5pYUxDdThpY0NxelpOQ0YzMXlQUS82NDA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTI2MG1HZEJPUVIxMTFKUUpDOE1rUzE0SmlickM5TTduckxrZUg3enZXZUxOaWJaUmlhczFtb01hdy82NDA" alt="img"></p><p>我们得出一个结论：针对<strong>不可变数据类型的深浅拷贝</strong>，其结果是相同的。</p><h3 id="5-2-可变类型的深拷贝"><a href="#5-2-可变类型的深拷贝" class="headerlink" title="5.2 可变类型的深拷贝"></a>5.2 可变类型的深拷贝</h3><p>首先我们讨论的是不存在嵌套的情况：</p><p><strong>针对列表数据</strong>：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWJqaWJnTnoyWDRTSXREZUFDUU8wclE1WU14bkNnUDBURkpxZFBzSktYOHM3SUtMYU9EMjNCakEvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTVXbWR4eEVFcHBLTDNBQ3MxbW9TYm14dkRScnJpYzJOcWh4MFZlaWNNdWpYNTZIdjVLNHpKOXF3LzY0MA" alt="img"></p><p><strong>针对字典数据</strong>：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUhSdHY2bmN2bHZYa0FwaWJZQzVtWTZYcFVWbzhEejJOVFg5ZEdsM0pCY3p1b1N5bTlnRHhRcEEvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUZQZ1NhMm5tQ1NKZTZBU0ZpYmU1TXI0UTA4eWljNGswcVpVcGR3RU5DRWljekNBSmlicm5uNkg1VGcvNjQw" alt="img"></p><p>我们可以得出结论：</p><ul><li>深拷贝对最外层数据是只拷贝数据，会开辟新的内存地址来存放数据。</li><li>深拷贝对里面的不可变数据类型直接复制数据和地址，和可变类型的浅拷贝是相同的效果。</li></ul><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWNhbVYxb01lSEdpYWxYM2JjSHdXWE5pY2hla01kaWN3MnZOcFVUNU5QRWdyY083ZGd4bmdXeGNYZy82NDA" alt="img"></p><p>我们讨论存在嵌套类型的深拷贝（以列表为例）。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWFIbGVHc1VoWWRYTW11bkZ0aWM0alVWMDExdHhobTZvVEYyN25ZRzZSNUc0MEJpY2dyZG9ScDJRLzY0MA" alt="img"></p><p><strong>结论1</strong>：对整个存在嵌套类型的数据进行深浅拷贝都会发生内存的变化，因为数据本身是可变的。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVdzUm1MQ2U5VmljVGRjQTZ3dFl3a2JjamliV043VGliZFphYU5TTGc3ZUQxT24wYXZ2aFd0eHhIZy82NDA" alt="img"></p><p><strong>结论2</strong>：我们查看第一个元素1的内存地址，发生三者是相同的，因为1是属于数值型，是不可变类型。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVg2Z2gzY3lvam0yaWFkYzBNWmNMaWM2NzBLaWMyZEVrd2RZU041Qk1MYXlveFBHTTl5a0hUV3Nldy82NDA" alt="img"></p><p><strong>结论3</strong>：我们查看第三个元素即里面嵌套列表的内存，发现只有深拷贝是不同的，因为这个嵌套的列表是可变数据类型，深拷贝在拷贝了最外层之后还会继续拷贝子层级的可变类型。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeWlhNTdyb2MzUGgzSzFLRDlDS1h6eEpwSks5bXhtTWVhd1Z4RGpmdTdySWljUGxUNWozQzdjNWFRLzY0MA" alt="img"></p><p><strong>结论4</strong>：我们查看嵌套列表中的元素的内存地址，发现它们是相同的，因为元素是数值型，是不可变的，不受拷贝的影响。</p><h2 id="六、元组的深浅拷贝"><a href="#六、元组的深浅拷贝" class="headerlink" title="六、元组的深浅拷贝"></a>六、元组的深浅拷贝</h2><p>元组本身是不可变数据类型，但是其中的值是可以改变的，内部可以有嵌套可变数据类型，比如列表等，会对它的拷贝结果造成影响。</p><h3 id="6-1-不存在嵌套结构"><a href="#6-1-不存在嵌套结构" class="headerlink" title="6.1 不存在嵌套结构"></a>6.1 不存在嵌套结构</h3><p>当元组中<strong>不存在嵌套结构</strong>的时候，元组的深浅拷贝是相同的效果：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUJvN2JtOW1MdmtTYkNPY1hNNDV2bXdSaWFDeWxna0taNU5scFV6VEhxaWF1bks0bnhYWWFJWk5RLzY0MA" alt="img"></p><h3 id="6-2-存在嵌套结构"><a href="#6-2-存在嵌套结构" class="headerlink" title="6.2 存在嵌套结构"></a>6.2 存在嵌套结构</h3><p>当元组的数据中存在嵌套的可变类型，比如列表等，<strong>深拷贝会重新开辟地址，将元组重新成成一份</strong>。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUlLZ2FSQndveUtpY3YxVHNVcjdKM0hKbnhTRXgzWEFpY1pxRFNPeHhzYkM4Q2pjZU9GQnJZN2ljZy82NDA" alt="img"></p><h2 id="七、is和"><a href="#七、is和" class="headerlink" title="七、is和=="></a>七、is和==</h2><p>在文章的开始就已经谈过：在Python中每个变量都有自己的<strong>标识、类型和值</strong>。每个对象一旦创建，它的标识就绝对不会变。一个对象的标识，我们可以理解成其在内存中的地址。<code>is()</code>运算符比较的是两个对象的标识；<code>id()</code>方法返回的就是对象标识的整数表示。</p><p>总结：<code>is()</code>比较对象的标识；<code>==</code>运算符比较两个对象的值（对象中保存的数据）。在实际的编程中，我们更多关注的是值，而不是标识本身。</p><p><strong>第一个例子</strong>：<strong>我们创建了两个不同的对象，只是它们的值刚好相同而已</strong>。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeVV1U0M5U0p1QzlFdmRZdmliN0dEaWFGa1BSeFVJdVZXeGRRYWliQ0FpYXcxajlsTU1tdnFpY1Z6OUpBLzY0MA" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeTZtcDZ6WTE0WFhNM2xkTkhQSEFITHV2SHczNkg4NXVSRGlhdTNSQmtaaWNHM3VzV3FhSHk2UXVnLzY0MA" alt="img"></p><p><strong>第二个例子</strong>：<strong>我们先创建了一个对象v3，然后将他赋值给另一个对象v4，其实它们就是相同的对象，所以标识（内存地址）是相同的，只是它们的名字不同而已</strong>。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeUdXUEhpYk9nYXRMelhKQk15NU95bE9pYlZHS1BMb3FlUVdSVjJtaWJaOEdmRkViVjB0cnJZaWM5Z2cvNjQw" alt="img"><img src="https://gitee.com/SunGitee/src/raw/master/img/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy92STluWWU5NGZzRlpiQUFlSWpnN3BMQTBtVDJoNVhVeXd5UjlvUWdMYTZoQ3hCampBY05qc2liNDU0WG5aR3ZpYmJWb3RFVVRSaWFmQ3RSeTR4S0xYUmljbHcvNjQw" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过大量的例子，我们得出结论：</p><ul><li>在不可变数据类型中，深浅拷贝都不会开辟新的内存空间，用的都是同一个内存地址。</li><li>在存在嵌套可变类型的数据时，深浅拷贝都会开辟新的一块内存空间；同时，不可变类型的值还是指向原来的值的地址。</li></ul><p><strong>不同的是</strong>：在嵌套可变类型中，浅拷贝只会拷贝最外层的数据，而深拷贝会拷贝<strong>所有层级</strong>的<strong>可变类型数据</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/KrdXyYMtyElUGuPH5eNYvg">https://mp.weixin.qq.com/s/KrdXyYMtyElUGuPH5eNYv</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在很多语言中都存在&lt;strong&gt;深浅拷贝&lt;/strong&gt;两种拷贝数据的方式，Python中也不例外。本文中详细介绍了Python中的深浅拷贝的相关知识，文章的内容包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象、数据类型、引用&lt;/li&gt;
&lt;li&gt;赋值&lt;/li&gt;
&lt;li&gt;浅拷贝&lt;/li&gt;
&lt;li&gt;深拷贝&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/SunGitee/src/raw/master/img/20201215230531.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们经常听到：&lt;strong&gt;在Python中一切皆对象&lt;/strong&gt;。其实，说的就是我们在Python中构造的任何数据类型都是一个对象，不管是数字、字符串、字典等常见的数据结构，还是函数，甚至是我们导入的模块等，Python都会把它当做是一个对象来处理。&lt;/p&gt;
&lt;p&gt;所有的Python对象都拥有3个属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;身份&lt;/li&gt;
&lt;li&gt;类型&lt;/li&gt;
&lt;li&gt;值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们看一个简单的例子来理解上面的3个属性：&lt;/p&gt;
&lt;p&gt;假设我们声明了一个name变量，通过id、type方法能够查看对象的身份和类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/SunGitee/src/raw/master/img/20201215230633.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="https://alliswell.top/categories/Language/"/>
    
    <category term="Python" scheme="https://alliswell.top/categories/Language/Python/"/>
    
    
    <category term="Python" scheme="https://alliswell.top/tags/Python/"/>
    
    <category term="深拷贝" scheme="https://alliswell.top/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
    <category term="浅拷贝" scheme="https://alliswell.top/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>code review 行话</title>
    <link href="https://alliswell.top/wiki/code-review%E8%A1%8C%E8%AF%9D/"/>
    <id>https://alliswell.top/wiki/code-review%E8%A1%8C%E8%AF%9D/</id>
    <published>2020-12-11T08:01:25.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在和大佬交流时，发现很多缩写不太懂，这里记录一下</p></blockquote><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LGTM  —  Looks good <span class="keyword">to</span> <span class="keyword">me</span>，表示认可这次 PR，同意 merge 合并代码到远程仓库</span><br><span class="line">ASAP -— <span class="keyword">as</span> soon <span class="keyword">as</span> possible! 尽快</span><br><span class="line">ACK  —  acknowledgement, i.e. agreed/accepted change</span><br><span class="line">NACK/NAK — negative acknowledgement, i.e. disagree <span class="keyword">with</span> change <span class="keyword">and</span>/<span class="keyword">or</span> concept</span><br><span class="line">RFC  —  request <span class="keyword">for</span> comments, i.e. I think this <span class="keyword">is</span> a good idea, lets discuss</span><br><span class="line">WIP：Work <span class="keyword">In</span> Progress 「进展中」，常见词汇，这里做为 Best Practice 单独提出来，主要针对改动较多的 PR，可以先提交部分，标题或 Tag 加上 WIP，表示尚未完成，这样别人可以先 review 已提交的部分</span><br><span class="line">AFAIK/AFAICT  —  <span class="keyword">as</span> far <span class="keyword">as</span> I know / can tell</span><br><span class="line">IIRC  —  <span class="keyword">if</span> I recall correctly</span><br><span class="line">IANAL  — “ I am <span class="keyword">not</span> a lawyer ”, but I smell licensing issues</span><br><span class="line">IMO  — （<span class="keyword">In</span> my opinion），在我看来</span><br><span class="line">TL;DR  —  Too <span class="built_in">Long</span>; Didn<span class="comment">&#x27;t Read 「太长懒得看」，README 文档常见。</span></span><br><span class="line">PR  —  Pull request「合并请求」</span><br><span class="line">CR  —  Code Review 「代码审查」</span><br><span class="line">PTAL  —  Please <span class="keyword">Take</span> A Look. 你来瞅瞅？用来提示别人来看一下</span><br><span class="line">TBR  —  <span class="keyword">To</span> Be Reviewed. 提示维护者进行 review</span><br><span class="line">TBD  —  <span class="keyword">To</span> Be Done(<span class="keyword">or</span> Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思。</span><br><span class="line">TBH  —  <span class="keyword">To</span> be honest 「老实说」</span><br><span class="line">atm  —  at the moment 「现阶段」，</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.jianshu.com/p/238a1e1f4037">code review 行话</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在和大佬交流时，发现很多缩写不太懂，这里记录一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight vbnet&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LGTM  —  Looks good &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;me&lt;/span&gt;，表示认可这次 PR，同意 merge 合并代码到远程仓库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ASAP -— &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; soon &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; possible! 尽快&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ACK  —  acknowledgement, i.e. agreed/accepted change&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NACK/NAK — negative acknowledgement, i.e. disagree &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; change &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt;/&lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; concept&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RFC  —  request &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; comments, i.e. I think this &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; a good idea, lets discuss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WIP：Work &lt;span class=&quot;keyword&quot;&gt;In&lt;/span&gt; Progress 「进展中」，常见词汇，这里做为 Best Practice 单独提出来，主要针对改动较多的 PR，可以先提交部分，标题或 Tag 加上 WIP，表示尚未完成，这样别人可以先 review 已提交的部分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AFAIK/AFAICT  —  &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; far &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; I know / can tell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IIRC  —  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; I recall correctly&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IANAL  — “ I am &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; a lawyer ”, but I smell licensing issues&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMO  — （&lt;span class=&quot;keyword&quot;&gt;In&lt;/span&gt; my opinion），在我看来&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TL;DR  —  Too &lt;span class=&quot;built_in&quot;&gt;Long&lt;/span&gt;; Didn&lt;span class=&quot;comment&quot;&gt;&amp;#x27;t Read 「太长懒得看」，README 文档常见。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PR  —  Pull request「合并请求」&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CR  —  Code Review 「代码审查」&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PTAL  —  Please &lt;span class=&quot;keyword&quot;&gt;Take&lt;/span&gt; A Look. 你来瞅瞅？用来提示别人来看一下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TBR  —  &lt;span class=&quot;keyword&quot;&gt;To&lt;/span&gt; Be Reviewed. 提示维护者进行 review&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TBD  —  &lt;span class=&quot;keyword&quot;&gt;To&lt;/span&gt; Be Done(&lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; Defined/Discussed/Decided/Determined). 根据语境不同意义有所区别，但一般都是还没搞定的意思。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TBH  —  &lt;span class=&quot;keyword&quot;&gt;To&lt;/span&gt; be honest 「老实说」&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;atm  —  at the moment 「现阶段」，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/238a1e1f4037&quot;&gt;code review 行话&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</summary>
    
    
    
    <category term="Language" scheme="https://alliswell.top/categories/Language/"/>
    
    
    <category term="code review" scheme="https://alliswell.top/tags/code-review/"/>
    
  </entry>
  
  <entry>
    <title>zsh快捷键</title>
    <link href="https://alliswell.top/wiki/zsh%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://alliswell.top/wiki/zsh%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-12-06T07:49:39.000Z</published>
    <updated>2021-01-26T02:48:56.219Z</updated>
    
    <content type="html"><![CDATA[<ul><li>⌃ + a：移动到行首</li><li>⌃ + e：移动到行尾</li><li>⌃ + f：向前移动</li><li>⌃ + b：向后移动</li><li>⌃ + p：上一条命令</li><li>⌃ + n：下一条命令</li><li>⌃ + r：搜索历史命令</li><li>⌃ + y：召回最近用命令删除的文字</li><li>⌃ + h：删除光标之前的字符</li><li>⌃ + d：删除光标所指的字符</li><li>⌃ + w：删除光标之前的单词</li><li>⌃ + k：删除从光标到行尾的内容</li><li>⌃ + t：交换光标和之前的字符</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;⌃ + a：移动到行首&lt;/li&gt;
&lt;li&gt;⌃ + e：移动到行尾&lt;/li&gt;
&lt;li&gt;⌃ + f：向前移动&lt;/li&gt;
&lt;li&gt;⌃ + b：向后移动&lt;/li&gt;
&lt;li&gt;⌃ + p：上一条命令&lt;/li&gt;
&lt;li&gt;⌃ + n：下一条命令&lt;/li&gt;
&lt;li&gt;⌃ + r：搜索历史命令&lt;/li&gt;
&lt;li&gt;⌃ + y：召回最近用命令删除的文字&lt;/li&gt;
&lt;li&gt;⌃ + h：删除光标之前的字符&lt;/li&gt;
&lt;li&gt;⌃ + d：删除光标所指的字符&lt;/li&gt;
&lt;li&gt;⌃ + w：删除光标之前的单词&lt;/li&gt;
&lt;li&gt;⌃ + k：删除从光标到行尾的内容&lt;/li&gt;
&lt;li&gt;⌃ + t：交换光标和之前的字符&lt;/li&gt;
&lt;/ul&gt;
</summary>
    
    
    
    <category term="zsh" scheme="https://alliswell.top/categories/zsh/"/>
    
    
    <category term="zsh" scheme="https://alliswell.top/tags/zsh/"/>
    
    <category term="快捷键" scheme="https://alliswell.top/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python getopt简单使用</title>
    <link href="https://alliswell.top/wiki/python-getopt%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://alliswell.top/wiki/python-getopt%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2020-12-01T15:32:53.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-getopt的简单使用"><a href="#Python-getopt的简单使用" class="headerlink" title="Python getopt的简单使用"></a>Python getopt的简单使用</h1><p>一般 <code>getopt</code>使用在解析参数列表上。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>一般情况下，选项有“短选项”和“长选项”两种</p><p>短选项格式：一个减号一个字母；长选项格式：俩减号多个字母</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Options</span>:</span><br><span class="line">        -h, --help  Help info</span><br><span class="line">        -f          <span class="meta">INPUT</span> Mardown <span class="meta">file</span></span><br><span class="line">        -s          css for pages</span><br><span class="line">        -d          <span class="meta">OUTPUT</span> HTML <span class="meta">file</span> path</span><br><span class="line">        -F          <span class="meta">OUTPUT</span> HTML <span class="meta">file</span> name</span><br></pre></td></tr></table></figure><p> <code>getopt.getopt</code> 方法有仨参数：要处理的对象列表、短选项组、长选项组</p><ul><li>短选项组为字符串，若选项有参数，后面加冒号</li><li>长选项组为列表，若选项有参数，后面加等号</li></ul><p>该方法返回值为二元元组，元组中每个元素都是列表, 一个是选项解析结果，另一个是其余参数</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArgsParse</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    命令行参数解析类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数说明</span></span><br><span class="line">    options_explain = <span class="string">&#x27;&#x27;&#x27;Options:</span></span><br><span class="line"><span class="string">        -h, --help  Help info</span></span><br><span class="line"><span class="string">        -f          INPUT Mardown file</span></span><br><span class="line"><span class="string">        -s          css for pages</span></span><br><span class="line"><span class="string">        -d          OUTPUT HTML file path</span></span><br><span class="line"><span class="string">        -F          OUTPUT HTML file name</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        选项有“短选项”和“长选项”两种</span></span><br><span class="line"><span class="string">        短选项格式：一个减号一个字母；长选项格式：俩减号多个字母</span></span><br><span class="line"><span class="string">        getopt.getopt 方法有仨参数：要处理的对象列表、短选项组、长选项组</span></span><br><span class="line"><span class="string">        短选项组为字符串，若选项有参数，后面加冒号</span></span><br><span class="line"><span class="string">        长选项组为列表，若选项有参数，后面加等号</span></span><br><span class="line"><span class="string">        该方法返回值为二元元组，元组中每个元素都是列表</span></span><br><span class="line"><span class="string">        一个是选项解析结果，另一个是其余参数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        options, _ = getopt.getopt(sys.argv[<span class="number">1</span>:], <span class="string">&#x27;hf:s:d:F:&#x27;</span>, [<span class="string">&#x27;help&#x27;</span>])</span><br><span class="line">        self.options_dict = (<span class="built_in">dict</span>(options))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;-h&#x27;</span> <span class="keyword">in</span> self.options_dict <span class="keyword">or</span> <span class="string">&#x27;--help&#x27;</span> <span class="keyword">in</span> self.options_dict:</span><br><span class="line">            print(self.options_explain)</span><br><span class="line">            sys.exit()</span><br><span class="line">        self.args_parse()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">args_parse</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        参数处理函数，从解析后的选项字典中读取各个文件名</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.markdown_file = self.options_dict.get(<span class="string">&#x27;-f&#x27;</span>)</span><br><span class="line">        self.css_file = self.options_dict.get(<span class="string">&#x27;-s&#x27;</span>)</span><br><span class="line">        self.html_file_dir = self.options_dict.get(<span class="string">&#x27;-d&#x27;</span>)</span><br><span class="line">        self.html_file = self.options_dict.get(<span class="string">&#x27;-F&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Python-getopt的简单使用&quot;&gt;&lt;a href=&quot;#Python-getopt的简单使用&quot; class=&quot;headerlink&quot; title=&quot;Python getopt的简单使用&quot;&gt;&lt;/a&gt;Python getopt的简单使用&lt;/h1&gt;&lt;p&gt;一般 &lt;code&gt;getopt&lt;/code&gt;使用在解析参数列表上。&lt;/p&gt;
&lt;h2 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;/a&gt;格式&lt;/h2&gt;&lt;p&gt;一般情况下，选项有“短选项”和“长选项”两种&lt;/p&gt;
&lt;p&gt;短选项格式：一个减号一个字母；长选项格式：俩减号多个字母&lt;/p&gt;
&lt;figure class=&quot;highlight sas&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;Options&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        -h, --help  Help info&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        -f          &lt;span class=&quot;meta&quot;&gt;INPUT&lt;/span&gt; Mardown &lt;span class=&quot;meta&quot;&gt;file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        -s          css for pages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        -d          &lt;span class=&quot;meta&quot;&gt;OUTPUT&lt;/span&gt; HTML &lt;span class=&quot;meta&quot;&gt;file&lt;/span&gt; path&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        -F          &lt;span class=&quot;meta&quot;&gt;OUTPUT&lt;/span&gt; HTML &lt;span class=&quot;meta&quot;&gt;file&lt;/span&gt; name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt; &lt;code&gt;getopt.getopt&lt;/code&gt; 方法有仨参数：要处理的对象列表、短选项组、长选项组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;短选项组为字符串，若选项有参数，后面加冒号&lt;/li&gt;
&lt;li&gt;长选项组为列表，若选项有参数，后面加等号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该方法返回值为二元元组，元组中每个元素都是列表, 一个是选项解析结果，另一个是其余参数&lt;/p&gt;
&lt;h2 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h2&gt;</summary>
    
    
    
    <category term="Language" scheme="https://alliswell.top/categories/Language/"/>
    
    <category term="Python" scheme="https://alliswell.top/categories/Language/Python/"/>
    
    
    <category term="Python" scheme="https://alliswell.top/tags/Python/"/>
    
    <category term="getopt" scheme="https://alliswell.top/tags/getopt/"/>
    
  </entry>
  
  <entry>
    <title>Git commit message 规范</title>
    <link href="https://alliswell.top/wiki/Git-commit-message-%E8%A7%84%E8%8C%83/"/>
    <id>https://alliswell.top/wiki/Git-commit-message-%E8%A7%84%E8%8C%83/</id>
    <published>2020-12-01T02:50:23.000Z</published>
    <updated>2021-01-26T02:48:56.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-commit-message-规范"><a href="#Git-commit-message-规范" class="headerlink" title="Git commit message 规范"></a>Git commit message 规范</h1><p>最近使用git,翻找以前的记录, 愈发觉得提交 git 记录时, commit message 很重要, 需要有一定规范. </p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>一般遵守 <a href="https://github.com/thoughtbot/dotfiles/blob/master/gitmessage"><strong>thoughtbot 规范</strong></a>，这里是详细说明 <a href="https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message">5 Useful Tips For A Better Commit Message</a></p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># 50-character subject line</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 72-character wrapped longer description. This should answer:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># * Why was this change necessary?</span></span><br><span class="line"><span class="meta"># * How does it address the problem?</span></span><br><span class="line"><span class="meta"># * Are there any side effects?</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Include a link to the ticket, if any.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Add co-authors if you worked on this code with others:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Co-authored-by: Full Name &lt;email@example.com&gt;</span></span><br><span class="line"><span class="meta"># Co-authored-by: Full Name &lt;email@example.com&gt;</span></span><br></pre></td></tr></table></figure><p>Note:</p><p>Never use the <code>-m </code> / <code>--message=</code> flag to <code>git commit</code>.</p><p><code>-m</code>的表述内容太少, 不要在正式提交中使用.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message"><strong>5 Useful Tips For A Better Commit Message</strong></a></li><li><a href="https://github.com/thoughtbot/dotfiles/blob/master/gitmessage"><strong>thoughtbot 规范</strong></a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git-commit-message-规范&quot;&gt;&lt;a href=&quot;#Git-commit-message-规范&quot; class=&quot;headerlink&quot; title=&quot;Git commit message 规范&quot;&gt;&lt;/a&gt;Git commit message 规范&lt;/h1&gt;&lt;p&gt;最近使用git,翻找以前的记录, 愈发觉得提交 git 记录时, commit message 很重要, 需要有一定规范. &lt;/p&gt;
&lt;h2 id=&quot;规范&quot;&gt;&lt;a href=&quot;#规范&quot; class=&quot;headerlink&quot; title=&quot;规范&quot;&gt;&lt;/a&gt;规范&lt;/h2&gt;&lt;p&gt;一般遵守 &lt;a href=&quot;https://github.com/thoughtbot/dotfiles/blob/master/gitmessage&quot;&gt;&lt;strong&gt;thoughtbot 规范&lt;/strong&gt;&lt;/a&gt;，这里是详细说明 &lt;a href=&quot;https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message&quot;&gt;5 Useful Tips For A Better Commit Message&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight vala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# 50-character subject line&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# 72-character wrapped longer description. This should answer:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# * Why was this change necessary?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# * How does it address the problem?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# * Are there any side effects?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Include a link to the ticket, if any.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Add co-authors if you worked on this code with others:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Co-authored-by: Full Name &amp;lt;email@example.com&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Co-authored-by: Full Name &amp;lt;email@example.com&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;Never use the &lt;code&gt;-m &lt;/code&gt; / &lt;code&gt;--message=&lt;/code&gt; flag to &lt;code&gt;git commit&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt;的表述内容太少, 不要在正式提交中使用.&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message&quot;&gt;&lt;strong&gt;5 Useful Tips For A Better Commit Message&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/thoughtbot/dotfiles/blob/master/gitmessage&quot;&gt;&lt;strong&gt;thoughtbot 规范&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Git" scheme="https://alliswell.top/categories/Git/"/>
    
    
    <category term="git" scheme="https://alliswell.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>MP4 文件格式详解</title>
    <link href="https://alliswell.top/wiki/MP4%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://alliswell.top/wiki/MP4%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-11-30T08:39:53.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MP4-文件格式详解"><a href="#MP4-文件格式详解" class="headerlink" title="MP4 文件格式详解"></a>MP4 文件格式详解</h1><p>目前 MP4 的概念被炒得很火，也很乱。最开始 MP4 指的是音频（MP3 的升级版），即 MPEG-2 AAC 标准。随后 MP4 概念被转移到视频上，对应的是 MPEG-4 标准。而现在我们流行的叫法，多半是指能播放 MPEG-4 标准编码格式视频的播放器。但是这篇文章介绍的内容跟上面这些都无关，我们要讨论的是 MP4 文件封装格式，对应的标准为 ISO/IEC 14496-12，即信息技术 视听对象编码的第 12 部分：ISO 基本媒体文件格式（Information technology Coding of audio-visual objects Part 12: ISO base media file format）。ISO/IEC 组织指定的标准一般用数字表示，ISO/IEC 14496 即 MPEG-4 标准。</p><p>  MP4 视频文件封装格式是基于 QuickTime 容器格式定义的，因此参考 QuickTime 的格式定义对理解 MP4 文件格式很有帮助。MP4 文件格式是一个十分开放的容器，几乎可以用来描述所有的媒体结构，MP4 文件中的媒体描述与媒体数据是分开的，并且媒体数据的组织也很自由，不一定要按照时间顺序排列，甚至媒体数据可以直接引用其他文件。同时，MP4 也支持流媒体。MP4 目前被广泛用于封装 h.264 视频和 AAC 音频，是高清视频的代表。</p><p>  现在我们就来看看 MP4 文件格式到底是什么样的。</p><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a><strong>1、概述</strong></h2><p>  MP4 文件中的所有数据都装在 box（QuickTime 中为 atom）中，也就是说 MP4 文件由若干个 box 组成，每个 box 有类型和长度，可以将 box 理解为一个数据对象块。box 中可以包含另一个 box，这种 box 称为 container box。一个 MP4 文件首先会有且只有一个“ftyp”类型的 box，作为 MP4 格式的标志并包含关于文件的一些信息；之后会有且只有一个“moov”类型的 box（Movie Box），它是一种 container box，子 box 包含了媒体的 metadata 信息；MP4 文件的媒体数据包含在“mdat”类型的 box（Midia Data Box）中，该类型的 box 也是 container box，可以有多个，也可以没有（当媒体数据全部引用其他文件时），媒体数据的结构由 metadata 进行描述。</p><p>  下面是一些概念：</p><p>  <strong><em>track</em></strong> 表示一些 sample 的集合，对于媒体数据来说，track 表示一个视频或音频序列。</p><p>  <strong><em>hint track</em></strong> 这个特殊的 track 并不包含媒体数据，而是包含了一些将其他数据 track 打包成流媒体的指示信息。</p><p>  <strong><em>sample</em></strong> 对于非 hint track 来说，video sample 即为一帧视频，或一组连续视频帧，audio sample 即为一段连续的压缩音频，它们统称 sample。对于 hint track，sample 定义一个或多个流媒体包的格式。</p><p>  <strong><em>sample table</em></strong> 指明 sampe 时序和物理布局的表。</p><p>  <strong><em>chunk</em></strong> 一个 track 的几个 sample 组成的单元。</p><p>  在本文中，我们不讨论涉及 hint 的内容，只关注包含媒体数据的本地 MP4 文件。下图为一个典型的 MP4 文件的结构树。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103255828-809042371.jpg"></p><h2 id="2、Box"><a href="#2、Box" class="headerlink" title="2、Box"></a><strong>2、Box</strong></h2><p>​    首先需要说明的是，box 中的字节序为网络字节序，也就是大端字节序（Big-Endian），简单的说，就是一个 32 位的 4 字节整数存储方式为高位字节在内存的低端。Box 由 header 和 body 组成，其中 header 统一指明 box 的大小和类型，body 根据类型有不同的意义和格式。</p><p>​    标准的 box 开头的 4 个字节（32 位）为 box size，该大小包括 box header 和 box body 整个 box 的大小，这样我们就可以在文件中定位各个 box。如果 size 为 1，则表示这个 box 的大小为 large size，真正的 size 值要在 largesize 域上得到。（实际上只有“mdat”类型的 box 才有可能用到 large size。）如果 size 为 0，表示该 box 为文件的最后一个 box，文件结尾即为该 box 结尾。（同样只存在于“mdat”类型的 box 中。）</p><p>​    size 后面紧跟的 32 位为 box type，一般是 4 个字符，如“ftyp”、“moov”等，这些 box type 都是已经预定义好的，分别表示固定的意义。如果是“uuid”，表示该 box 为用户扩展类型。如果 box type 是未定义的，应该将其忽略。</p><h2 id="3、File-Type-Box（ftyp）"><a href="#3、File-Type-Box（ftyp）" class="headerlink" title="3、File Type Box（ftyp）"></a><strong>3、File Type Box（ftyp）</strong></h2><p>   该 box 有且只有 1 个，并且只能被包含在文件层，而不能被其他 box 包含。该 box 应该被放在文件的最开始，指示该 MP4 文件应用的相关信息。</p><p>  “ftyp” body 依次包括 1 个 32 位的 major brand（4 个字符），1 个 32 位的 minor version（整数）和 1 个以 32 位（4 个字符）为单位元素的数组 compatible brands。这些都是用来指示文件应用级别的信息。该 box 的字节实例如下：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103308953-79513465.jpg"></p><h2 id="4、Movie-Box（moov）"><a href="#4、Movie-Box（moov）" class="headerlink" title="4、Movie Box（moov）"></a>4、Movie Box（moov）</h2><p>  该 box 包含了文件媒体的 metadata 信息，“moov”是一个 container box，具体内容信息由子 box 诠释。同 File Type Box 一样，该 box 有且只有一个，且只被包含在文件层。一般情况下，“moov”会紧随“ftyp”出现。</p><p>  一般情况下（限于篇幅，本文只讲解常见的 MP4 文件结构），“moov”中会包含 1 个“mvhd”和若干个“trak”。其中“mvhd”为 header box，一般作为“moov”的第一个子 box 出现（对于其他 container box 来说，header box 都应作为首个子 box 出现）。“trak”包含了一个 track 的相关信息，是一个 container box。下图为部分“moov”的字节实例，其中红色部分为 box header，绿色为“mvhd”，黄色为一部分“trak”。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103319000-1662662916.jpg"></p><h3 id="4-1-Movie-Header-Box（mvhd）"><a href="#4-1-Movie-Header-Box（mvhd）" class="headerlink" title="4.1 Movie Header Box（mvhd）"></a><strong>4.1 Movie Header Box（mvhd）</strong></h3><p>  “mvhd”结构如下表。</p><table><thead><tr><th>字段</th><th>字节数</th><th>意义</th></tr></thead><tbody><tr><td>box size</td><td>4</td><td>box 大小</td></tr><tr><td>box type</td><td>4</td><td>box 类型</td></tr><tr><td>version</td><td>1</td><td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td></tr><tr><td>flags</td><td>3</td><td></td></tr><tr><td>creation time</td><td>4</td><td>创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</td></tr><tr><td>modification time</td><td>4</td><td>修改时间</td></tr><tr><td>time scale</td><td>4</td><td>文件媒体在 1 秒时间内的刻度值，可以理解为 1 秒长度的时间单元数</td></tr><tr><td>duration</td><td>4</td><td>该 track 的时间长度，用 duration 和 time scale 值可以计算 track 时长，比如 audio track 的 time scale = 8000, duration = 560128，时长为 70.016，video track 的 time scale = 600, duration = 42000，时长为 70</td></tr><tr><td>rate</td><td>4</td><td>推荐播放速率，高 16 位和低 16 位分别为小数点整数部分和小数部分，即 [16.16] 格式，该值为 1.0（0x00010000）表示正常前向播放</td></tr><tr><td>volume</td><td>2</td><td>与 rate 类似，[8.8] 格式，1.0（0x0100）表示最大音量</td></tr><tr><td>reserved</td><td>10</td><td>保留位</td></tr><tr><td>matrix</td><td>36</td><td>视频变换矩阵</td></tr><tr><td>pre-defined</td><td>24</td><td></td></tr><tr><td>next track id</td><td>4</td><td>下一个 track 使用的 id 号</td></tr></tbody></table><p>  “mvhd”的字节实例如下图，各字段已经用颜色区分开：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103340343-505155072.jpg"></p><h3 id="4-2-Track-Box（trak）"><a href="#4-2-Track-Box（trak）" class="headerlink" title="4.2 Track Box（trak）"></a><strong>4.2 Track Box（trak）</strong></h3><p>  “trak”也是一个 container box，其子 box 包含了该 track 的媒体数据引用和描述（hint track 除外）。一个 MP4 文件中的媒体可以包含多个 track，且至少有一个 track，这些 track 之间彼此独立，有自己的时间和空间信息。“trak”必须包含一个“tkhd”和一个“mdia”，此外还有很多可选的 box（略）。其中“tkhd”为 track header box，“mdia”为 media box，该 box 是一个包含一些 track 媒体数据信息 box 的 container box。</p><p>  “trak”的部分字节实例如下图，其中黄色为“trak”box 的头，绿色为“tkhd”，蓝色为“edts”（一个可选 box），红色为一部分“mdia”。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124103352140-1758822429.jpg"></p><h4 id="4-2-1-Track-Header-Box（tkhd）"><a href="#4-2-1-Track-Header-Box（tkhd）" class="headerlink" title="4.2.1 Track Header Box（tkhd）"></a><strong>4.2.1 Track Header Box（tkhd）</strong></h4><p>  “tkhd”结构如下表。</p><table><thead><tr><th>字段</th><th>字节数</th><th>意义</th></tr></thead><tbody><tr><td>box size</td><td>4</td><td>box 大小</td></tr><tr><td>box type</td><td>4</td><td>box 类型</td></tr><tr><td>version</td><td>1</td><td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td></tr><tr><td>flags</td><td>3</td><td>按位或操作结果值，预定义如下：0x000001 track_enabled，否则该 track 不被播放；0x000002 track_in_movie，表示该 track 在播放中被引用；0x000004 track_in_preview，表示该 track 在预览时被引用。一般该值为 7，如果一个媒体所有 track 均未设置 track_in_movie 和 track_in_preview，将被理解为所有 track 均设置了这两项；对于 hint track，该值为 0</td></tr><tr><td>creation time</td><td>4</td><td>创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</td></tr><tr><td>modification time</td><td>4</td><td>修改时间</td></tr><tr><td>track id</td><td>4</td><td>id 号，不能重复且不能为 0</td></tr><tr><td>reserved</td><td>4</td><td>保留位</td></tr><tr><td>duration</td><td>4</td><td>track 的时间长度</td></tr><tr><td>reserved</td><td>8</td><td>保留位</td></tr><tr><td>layer</td><td>2</td><td>视频层，默认为 0，值小的在上层</td></tr><tr><td>alternate group</td><td>2</td><td>track 分组信息，默认为 0 表示该 track 未与其他 track 有群组关系</td></tr><tr><td>volume</td><td>2</td><td>[8.8] 格式，如果为音频 track，1.0（0x0100）表示最大音量；否则为 0</td></tr><tr><td>reserved</td><td>2</td><td>保留位</td></tr><tr><td>matrix</td><td>36</td><td>视频变换矩阵</td></tr><tr><td>width</td><td>4</td><td>宽</td></tr><tr><td>height</td><td>4</td><td>高，均为 [16.16] 格式值，与 sample 描述中的实际画面大小比值，用于播放时的展示宽高</td></tr></tbody></table><p>  “tkhd”的字节实例如下图，各字段已经用颜色区分开：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105632828-1690291173.jpg"></p><h4 id="4-2-2-Media-Box（mdia）"><a href="#4-2-2-Media-Box（mdia）" class="headerlink" title="4.2.2 Media Box（mdia）"></a><strong>4.2.2 Media Box（mdia）</strong></h4><p>  “mdia”也是个 container box，其子 box 的结构和种类还是比较复杂的。先来看一个“mdia”的实例结构树图。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105617750-494904833.jpg"></p><p>​    总体来说，“mdia”定义了 track 媒体类型以及 sample 数据，描述 sample 信息。一般“mdia”包含一个“mdhd”，一个“hdlr”和一个“minf”，其中“mdhd”为 media header box，“hdlr”为 handler reference box，“minf”为 media information box。下面依次看一下这几个 box 的结构。</p><h5 id="4-2-2-1-Media-Header-Box（mdhd）"><a href="#4-2-2-1-Media-Header-Box（mdhd）" class="headerlink" title="4.2.2.1 Media Header Box（mdhd）"></a><strong>4.2.2.1 Media Header Box（mdhd）</strong></h5><p>  “mdhd”结构如下表。</p><table><thead><tr><th>字段</th><th>字节数</th><th>意义</th></tr></thead><tbody><tr><td>box size</td><td>4</td><td>box 大小</td></tr><tr><td>box type</td><td>4</td><td>box 类型</td></tr><tr><td>version</td><td>1</td><td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td></tr><tr><td>flags</td><td>3</td><td></td></tr><tr><td>creation time</td><td>4</td><td>创建时间（相对于 UTC 时间 1904-01-01 零点的秒数）</td></tr><tr><td>modification time</td><td>4</td><td>修改时间</td></tr><tr><td>time scale</td><td>4</td><td>同前表</td></tr><tr><td>duration</td><td>4</td><td>track 的时间长度</td></tr><tr><td>language</td><td>2</td><td>媒体语言码。最高位为 0，后面 15 位为 3 个字符（见 ISO 639-2/T 标准中定义）</td></tr><tr><td>pre-defined</td><td>2</td><td></td></tr></tbody></table><p>  “mdhd”的字节实例如下图，各字段已经用颜色区分开：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105548187-1453820539.jpg"></p><h5 id="4-2-2-2-Handler-Reference-Box（hdlr）"><a href="#4-2-2-2-Handler-Reference-Box（hdlr）" class="headerlink" title="4.2.2.2 Handler Reference Box（hdlr）"></a><strong>4.2.2.2 Handler Reference Box（hdlr）</strong></h5><p>  “hdlr”解释了媒体的播放过程信息，该 box 也可以被包含在 meta box（meta）中。“hdlr”结构如下表。</p><table><thead><tr><th>字段</th><th>字节数</th><th>意义</th></tr></thead><tbody><tr><td>box size</td><td>4</td><td>box 大小</td></tr><tr><td>box type</td><td>4</td><td>box 类型</td></tr><tr><td>version</td><td>1</td><td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td></tr><tr><td>flags</td><td>3</td><td></td></tr><tr><td>pre-defined</td><td>4</td><td></td></tr><tr><td>handler type</td><td>4</td><td>在 media box 中，该值为 4 个字符：“vide”— video track“soun”— audio track“hint”— hint track</td></tr><tr><td>reserved</td><td>12</td><td></td></tr><tr><td>name</td><td>不定</td><td>track type name，以‘\0’结尾的字符串</td></tr></tbody></table><p>  “hdlr”的字节实例如下图，各字段已经用颜色区分开：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105534562-2004584065.jpg"></p><h5 id="4-2-2-3-Media-Information-Box（minf）"><a href="#4-2-2-3-Media-Information-Box（minf）" class="headerlink" title="4.2.2.3 Media Information Box（minf）"></a><strong>4.2.2.3 Media Information Box（minf）</strong></h5><p>  “minf”存储了解释 track 媒体数据的 handler-specific 信息，media handler 用这些信息将媒体时间映射到媒体数据并进行处理。“minf”中的信息格式和内容与媒体类型以及解释媒体数据的 media handler 密切相关，其他 media handler 不知道如何解释这些信息。“minf”是一个 container box，其实际内容由子 box 说明。</p><p>  一般情况下，“minf”包含一个 header box，一个“dinf”和一个“stbl”，其中，header box 根据 track type（即 media handler type）分为“vmhd”、“smhd”、“hmhd”和“nmhd”，“dinf”为 data information box，“stbl”为 sample table box。下面分别介绍。</p><p>  下图为“minf”部分字节实例，其中红色为 box header，蓝色为“smhd”，绿色为“dinf”，黄色为一部分“stbl”。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105523765-1396178666.jpg"></p><h6 id="4-2-2-3-1-Media-Information-Header-Box（vmhd、smhd、hmhd、nmhd）"><a href="#4-2-2-3-1-Media-Information-Header-Box（vmhd、smhd、hmhd、nmhd）" class="headerlink" title="4.2.2.3.1 Media Information Header Box（vmhd、smhd、hmhd、nmhd）"></a><strong>4.2.2.3.1 Media Information Header Box（vmhd、smhd、hmhd、nmhd）</strong></h6><p><strong><em>Video Media Header Box（vmhd）</em></strong></p><table><thead><tr><th>字段</th><th>字节数</th><th>意义</th></tr></thead><tbody><tr><td>box size</td><td>4</td><td>box 大小</td></tr><tr><td>box type</td><td>4</td><td>box 类型</td></tr><tr><td>version</td><td>1</td><td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td></tr><tr><td>flags</td><td>3</td><td></td></tr><tr><td>graphics mode</td><td>4</td><td>视频合成模式，为 0 时拷贝原始图像，否则与 opcolor 进行合成</td></tr><tr><td>opcolor</td><td>2×3</td><td>｛red，green，blue｝</td></tr></tbody></table><p><strong><em>Sound Media Header Box（smhd）</em></strong></p><table><thead><tr><th>字段</th><th>字节数</th><th>意义</th></tr></thead><tbody><tr><td>box size</td><td>4</td><td>box 大小</td></tr><tr><td>box type</td><td>4</td><td>box 类型</td></tr><tr><td>version</td><td>1</td><td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td></tr><tr><td>flags</td><td>3</td><td></td></tr><tr><td>balance</td><td>2</td><td>立体声平衡，[8.8] 格式值，一般为 0，-1.0 表示全部左声道，1.0 表示全部右声道</td></tr><tr><td>reserved</td><td>2</td><td></td></tr></tbody></table><p><strong><em>Hint Media Header Box（hmhd）</em></strong></p><p>  略</p><p><strong><em>Null Media Header Box（nmhd）</em></strong></p><p>  非视音频媒体使用该 box，略。</p><h6 id="4-2-2-3-2-Data-Information-Box（dinf）"><a href="#4-2-2-3-2-Data-Information-Box（dinf）" class="headerlink" title="4.2.2.3.2 Data Information Box（dinf）"></a><strong>4.2.2.3.2 Data Information Box（dinf）</strong></h6><p>  “dinf”解释如何定位媒体信息，是一个 container box。“dinf”一般包含一个“dref”，即 data reference box；“dref”下会包含若干个“url”或“urn”，这些 box 组成一个表，用来定位 track 数据。简单的说，track 可以被分成若干段，每一段都可以根据“url”或“urn”指向的地址来获取数据，sample 描述中会用这些片段的序号将这些片段组成一个完整的 track。一般情况下，当数据被完全包含在文件中时，“url”或“urn”中的定位字符串是空的。</p><p>  “dref”的字节结构如下表。</p><table><thead><tr><th>字段</th><th>字节数</th><th>意义</th></tr></thead><tbody><tr><td>box size</td><td>4</td><td>box 大小</td></tr><tr><td>box type</td><td>4</td><td>box 类型</td></tr><tr><td>version</td><td>1</td><td>box 版本，0 或 1，一般为 0。（以下字节数均按 version=0）</td></tr><tr><td>flags</td><td>3</td><td></td></tr><tr><td>entry count</td><td>4</td><td>“url”或“urn”表的元素个数</td></tr><tr><td>“url”或“urn”列表</td><td>不定</td><td></td></tr></tbody></table><p>  “url”或“urn”都是 box，“url”的内容为字符串（location string），“urn”的内容为一对字符串（name string and location string）。当“url”或“urn”的 box flag 为 1 时，字符串均为空。</p><p>  下面是一个“dinf”的字节实例图。其中黄色为“dinf”的 box header，由红色部分我们知道包含的“url”或“urn”个数为 1，红色后面为“url”box 的内容。紫色为“url”的 box header（根据 box type 我们知道是个“url”），绿色为 box flag，值为 1，说明“url”中的字符串为空，表示 track 数据已包含在文件中。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105445453-359347705.jpg"></p><h6 id="4-2-2-3-3-Sample-Table-Box（stbl）"><a href="#4-2-2-3-3-Sample-Table-Box（stbl）" class="headerlink" title="4.2.2.3.3 Sample Table Box（stbl）"></a>4.2.2.3.3 Sample Table Box（stbl）</h6><p>  “stbl”几乎是普通的 MP4 文件中最复杂的一个 box 了，首先需要回忆一下 sample 的概念。sample 是媒体数据存储的单位，存储在 media 的 chunk 中，chunk 和 sample 的长度均可互不相同，如下图所示。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105430750-1558311660.jpg"></p><p>  “stbl”包含了关于 track 中 sample 所有时间和位置的信息，以及 sample 的编解码等信息。利用这个表，可以解释 sample 的时序、类型、大小以及在各自存储容器中的位置。“stbl”是一个 container box，其子 box 包括：sample description box（stsd）、time to sample box（stts）、sample size box（stsz 或 stz2）、sample to chunk box（stsc）、chunk offset box（stco 或 co64）、composition time to sample box（ctts）、sync sample box（stss）等。</p><p>  “stsd”必不可少，且至少包含一个条目，该 box 包含了 data reference box 进行 sample 数据检索的信息。没有“stsd”就无法计算 media sample 的存储位置。“stsd”包含了编码的信息，其存储的信息随媒体类型不同而不同。</p><p><strong><em>Sample Description Box（stsd）</em></strong></p><p>  box header 和 version 字段后会有一个 entry count 字段，根据 entry 的个数，每个 entry 会有 type 信息，如“vide”、“sund”等，根据 type 不同 sample description 会提供不同的信息，例如对于 video track，会有“VisualSampleEntry”类型信息，对于 audio track 会有“AudioSampleEntry”类型信息。</p><p>  视频的编码类型、宽高、长度，音频的声道、采样等信息都会出现在这个 box 中。</p><p><strong><em>Time To Sample Box（stts）</em></strong></p><p>  “stts”存储了 sample 的 duration，描述了 sample 时序的映射方法，我们通过它可以找到任何时间的 sample。“stts”可以包含一个压缩的表来映射时间和 sample 序号，用其他的表来提供每个 sample 的长度和指针。表中每个条目提供了在同一个时间偏移量里面连续的 sample 序号，以及 samples 的偏移量。递增这些偏移量，就可以建立一个完整的 time to sample 表。</p><p><strong><em>Sample Size Box（stsz）</em></strong></p><p>  “stsz” 定义了每个 sample 的大小，包含了媒体中全部 sample 的数目和一张给出每个 sample 大小的表。这个 box 相对来说体积是比较大的。</p><p><strong><em>Sample To Chunk Box（stsc）</em></strong></p><p>  用 chunk 组织 sample 可以方便优化数据获取，一个 thunk 包含一个或多个 sample。“stsc”中用一个表描述了 sample 与 chunk 的映射关系，查看这张表就可以找到包含指定 sample 的 thunk，从而找到这个 sample。</p><p><strong><em>Sync Sample Box（stss）</em></strong></p><p>  “stss”确定 media 中的关键帧。对于压缩媒体数据，关键帧是一系列压缩序列的开始帧，其解压缩时不依赖以前的帧，而后续帧的解压缩将依赖于这个关键帧。“stss”可以非常紧凑的标记媒体内的随机存取点，它包含一个 sample 序号表，表内的每一项严格按照 sample 的序号排列，说明了媒体中的哪一个 sample 是关键帧。如果此表不存在，说明每一个 sample 都是一个关键帧，是一个随机存取点。</p><p><strong><em>Chunk Offset Box（stco）</em></strong></p><p>  “stco”定义了每个 thunk 在媒体流中的位置。位置有两种可能，32 位的和 64 位的，后者对非常大的电影很有用。在一个表中只会有一种可能，这个位置是在整个文件中的，而不是在任何 box 中的，这样做就可以直接在文件中找到媒体数据，而不用解释 box。需要注意的是一旦前面的 box 有了任何改变，这张表都要重新建立，因为位置信息已经改变了。</p><p><strong>5、Free Space Box（free 或 skip）</strong></p><p>  “free”中的内容是无关紧要的，可以被忽略。该 box 被删除后，不会对播放产生任何影响。</p><p><strong>6、Meida Data Box（mdat）</strong></p><p>  该 box 包含于文件层，可以有多个，也可以没有（当媒体数据全部为外部文件引用时），用来存储媒体数据。数据直接跟在 box type 字段后面，具体数据结构的意义需要参考 metadata（主要在 sample table 中描述）。</p><p>  普通 MP4 文件的结构就讲完了，可能会比较乱，下面这张图是常见的 box 的树结构图，可以用来大致了解 MP4 文件的构造。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171124105354187-597951417.jpg"></p><p>  这篇文章主要面向一些对 MP4 文件结构没有太多了解的初学者，算是篇比较初级的文章，本人也是参考了一些资料写出来的，对于 MP4 文件中涉及的一些概念没有太深入的了解，因此其中应该是有一些错误理解，希望大家抱着批判的眼光读这篇文章。如果有错误的地方，还请大家不吝赐教。</p><p>原文链接：<a href="https://www.cnblogs.com/ranson7zop/p/7889272.html">https://www.cnblogs.com/ranson7zop/p/7889272.html</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www.52rd.com/blog/Blog.asp?Name=wqyuwss&Subjectid=559">mp4文件格式</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MP4-文件格式详解&quot;&gt;&lt;a href=&quot;#MP4-文件格式详解&quot; class=&quot;headerlink&quot; title=&quot;MP4 文件格式详解&quot;&gt;&lt;/a&gt;MP4 文件格式详解&lt;/h1&gt;&lt;p&gt;目前 MP4 的概念被炒得很火，也很乱。最开始 MP4 指的是音频（MP3 的升级版），即 MPEG-2 AAC 标准。随后 MP4 概念被转移到视频上，对应的是 MPEG-4 标准。而现在我们流行的叫法，多半是指能播放 MPEG-4 标准编码格式视频的播放器。但是这篇文章介绍的内容跟上面这些都无关，我们要讨论的是 MP4 文件封装格式，对应的标准为 ISO/IEC 14496-12，即信息技术 视听对象编码的第 12 部分：ISO 基本媒体文件格式（Information technology Coding of audio-visual objects Part 12: ISO base media file format）。ISO/IEC 组织指定的标准一般用数字表示，ISO/IEC 14496 即 MPEG-4 标准。&lt;/p&gt;
&lt;p&gt;  MP4 视频文件封装格式是基于 QuickTime 容器格式定义的，因此参考 QuickTime 的格式定义对理解 MP4 文件格式很有帮助。MP4 文件格式是一个十分开放的容器，几乎可以用来描述所有的媒体结构，MP4 文件中的媒体描述与媒体数据是分开的，并且媒体数据的组织也很自由，不一定要按照时间顺序排列，甚至媒体数据可以直接引用其他文件。同时，MP4 也支持流媒体。MP4 目前被广泛用于封装 h.264 视频和 AAC 音频，是高清视频的代表。&lt;/p&gt;
&lt;p&gt;  现在我们就来看看 MP4 文件格式到底是什么样的。&lt;/p&gt;
&lt;h2 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;  MP4 文件中的所有数据都装在 box（QuickTime 中为 atom）中，也就是说 MP4 文件由若干个 box 组成，每个 box 有类型和长度，可以将 box 理解为一个数据对象块。box 中可以包含另一个 box，这种 box 称为 container box。一个 MP4 文件首先会有且只有一个“ftyp”类型的 box，作为 MP4 格式的标志并包含关于文件的一些信息；之后会有且只有一个“moov”类型的 box（Movie Box），它是一种 container box，子 box 包含了媒体的 metadata 信息；MP4 文件的媒体数据包含在“mdat”类型的 box（Midia Data Box）中，该类型的 box 也是 container box，可以有多个，也可以没有（当媒体数据全部引用其他文件时），媒体数据的结构由 metadata 进行描述。&lt;/p&gt;
&lt;p&gt;  下面是一些概念：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;&lt;em&gt;track&lt;/em&gt;&lt;/strong&gt; 表示一些 sample 的集合，对于媒体数据来说，track 表示一个视频或音频序列。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;&lt;em&gt;hint track&lt;/em&gt;&lt;/strong&gt; 这个特殊的 track 并不包含媒体数据，而是包含了一些将其他数据 track 打包成流媒体的指示信息。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;&lt;em&gt;sample&lt;/em&gt;&lt;/strong&gt; 对于非 hint track 来说，video sample 即为一帧视频，或一组连续视频帧，audio sample 即为一段连续的压缩音频，它们统称 sample。对于 hint track，sample 定义一个或多个流媒体包的格式。&lt;/p&gt;</summary>
    
    
    
    <category term="Video" scheme="https://alliswell.top/categories/Video/"/>
    
    
    <category term="Video" scheme="https://alliswell.top/tags/Video/"/>
    
    <category term="MP4" scheme="https://alliswell.top/tags/MP4/"/>
    
  </entry>
  
  <entry>
    <title>MP3 文件格式解析</title>
    <link href="https://alliswell.top/wiki/MP3%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>https://alliswell.top/wiki/MP3%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</id>
    <published>2020-11-30T07:24:32.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MP3-文件格式解析"><a href="#MP3-文件格式解析" class="headerlink" title="MP3 文件格式解析"></a>MP3 文件格式解析</h1><p>MP3 的全称是 MPEG Audio Layer3, 它是一种高效的计算机音频编码方案，它以较大的压缩比将音频文件转换成较小的扩展名为。MP3 的文件，基本保持原文件的音质。MP3 是 ISO/MPEG 标准的一部分，ISO/MPEG 标准描述了使用高性能感知编码方案的音频压缩，此标准一直在不断更新以满足“质高量小”的追求，现已形成 MPEGLayer1、Layer2、Layer3 三个音频编码解码方案。MPEGLayer3 压缩率可达 1:10 至 1:12,1M 的 MP3 文件可播放 1 分钟，而 1 分钟 CD 音质的 WAV 文件 (44100Hz,16bit, 双声道，60 秒）要占用 10M 空间，这样算来，一张 650M 的 MP3 光盘播放时间应在 10 小时以上，而同样容量的一张 CD 盘播放时间在 70 分钟左右。MP3 的优势是 CD 难以比拟的。</p><h2 id="MPEG-Audio-标准"><a href="#MPEG-Audio-标准" class="headerlink" title="MPEG Audio 标准"></a>MPEG Audio 标准</h2><p>MPEG(MovingPictureExpertsGroup) 是 ISO 下的一个动态图 像专家组，它制定的 MPEG 标准广泛应用于各种多媒体中。 MPEG 标准包括视频和音频标准，其中音频标准已制定出 MPEG-1、MPEG-2、MPEG-2AAC 和 MPEG-4。</p><p>MPEG-1 和 MPEG-2 标准使用同一个音频编码解码族—Layer1、2、3。MPEG-2 一个新特点是采用低采样率扩展降低数据流量，另一特点是多通道扩展，将主声道增加为 5 个。MPEG-2AAC(MPEG-2AdvancedAudioCoding) 标准是 FraunhoferIIS 同 AT&amp;T 公司于 1997 年推出的，旨在显著减少数据流量，MPEG22AAC 采用的修正的离散余弦变换 (MDCT,ModifiedDiscreteCo2sineTransform) 算法，采样率可在 8KHz 到 96KHz 之间，声道数可在 1-48 之间。</p><p>MPEG Audio Layer1、2、3 三个层使用相同的滤波器组、位流结构和头信息，采样频率为 32KHz、4411KHz 或 48KHz。Layer1 是为数字压缩磁带 DCC(DigitalCompactCassette) 设计的，数据流量为 384kbps,Layer2 在复杂性和性能间作了权衡，数据流量下降到 256kbps-192kbps。Layer3 一开始就为低数据流量而设计，数据流量在 128kbps-112kbps,Layer3 增加了 MDCT 变换，使其频率分辨能力是 Layer2 的 18 倍，Layer3 还使用了与 MPEGVid2eo 类似的平均信息量编码 (EntropyCoding), 减少了冗余信息。MP3 绝大部分使用的是 MPEG21 标准。</p><h2 id="音频压缩"><a href="#音频压缩" class="headerlink" title="音频压缩"></a>音频压缩</h2><p>MP3 格式始于 80 年代中期，德国 Erlangen 的 Fraunhofer 研究 所致力于高质量、低数据率的声音编码。</p><p>MP3 音频压缩包含编码和解码两个部分。编码是将 WAV 文件中的数据转换成高压缩率的位流形式，解码是接受位流并将其重建到 WAV 文件中。</p><p>MP3 采用了感知音频编码 (PerceptualAudioCoding) 这一失真算法。人耳感受声音的频率范围是 20Hz-220kHz,MP3 截掉了大量的冗余信号和无关的信号，编码器通过混合滤波器组将原始声音变换到频率域，利用心理声学模型，估算刚好能被察觉到的噪声水平，再经过量化，转换成 Huffman 编码，形成 MP3 位流。解码器要简单得多，它的任务是从编码后的谱线成分中，经过反 量化和逆变换，提取出声音信号。</p><p>在压缩音频数据时，先将原始声音数据分成固定的分块，然后作顺向 MDCT 变换，MDCT 本身并不进行数据压缩，只是将一组时域数据转换成频域数据，以得知时域变化情况，顺向 MDCT 将每块的值转换为 512 个 MDCT 系数。量化使数据得到压缩，在对量化后的变换样值进行比特分配时要考虑使整个量化块最小，这就成为有损压缩了。解压时，经反向 MDCT 将 512 个系数还原成原始声音数据，前后的原始声音数据是不一致的，因为在压缩过程中，去掉了冗余和不相关数据。</p><h2 id="MP3-文件结构"><a href="#MP3-文件结构" class="headerlink" title="MP3 文件结构"></a>MP3 文件结构</h2><p>MP3 文件大体分为三部分：TAG_V2(ID3V2), Frame, TAG_V1(ID3V1)</p><table><thead><tr><th>ID3V2</th><th>包含了作者，作曲，专辑等信息，长度不固定，扩展了 ID3V1 的信息量</th></tr></thead><tbody><tr><td>Frame</td><td>一系列的帧，个数有文件大小和帧长决定每个 FRAM 的长度可能不固定，也可能固定，由位率 bitrate 决定每个 FRAME 由分为帧头和数据实体两部分帧头记录了 mp3 的位率，采样率，版本等信息，每个帧之间相互独立</td></tr><tr><td>ID3V1</td><td>包含了作者，作曲，专辑等信息，长度为 128BYTE, 有些音频没有（存疑）</td></tr></tbody></table><h3 id="1-帧头格式"><a href="#1-帧头格式" class="headerlink" title="1. 帧头格式"></a>1. 帧头格式</h3><p>下面是一个头内容图示，使用字符 A 到 M 表示不同的区域。在表格中你可以看到每一区域<br>的详细内容。<br><code>AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM</code></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141012855-1193055958.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141029418-1919208897.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141039777-880575532.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141049012-1279776091.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141105387-1201925425.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012141122168-852393751.png"></p><p>关于读取帧头我使用了下面的方法<br>定义一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">frameHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sync1:<span class="number">8</span>; <span class="comment">//同步信息 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> error_protection:<span class="number">1</span>; <span class="comment">//CRC 校验</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> layer:<span class="number">2</span>; <span class="comment">//层</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version:<span class="number">2</span>; <span class="comment">//版本</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sync2:<span class="number">3</span>; <span class="comment">//同步信息 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extension:<span class="number">1</span>; <span class="comment">//版权</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> padding:<span class="number">1</span>; <span class="comment">//填充空白字</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sample_rate_index:<span class="number">2</span>; <span class="comment">//采样率索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bit_rate_index:<span class="number">4</span>; <span class="comment">//位率索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> emphasis:<span class="number">2</span>; <span class="comment">//强调方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> original:<span class="number">1</span>; <span class="comment">//原始媒体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> copyright:<span class="number">1</span>; <span class="comment">//版权标志</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mode_extension:<span class="number">2</span>; <span class="comment">//扩展模式,仅用于联合立体声</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> channel_mode:<span class="number">2</span>; <span class="comment">//声道模式</span></span><br><span class="line">&#125;FHEADER, *pFHEADER;</span><br></pre></td></tr></table></figure><p>请注意我的同步信息分成了两个部分，而且其他的位的顺序也和上表列出的有所差别，这个<br>主要是因为 c 语言在存取数据时总是从低位开始，而这个帧头是需要从高位来读取的。<br>读取方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FHEADER header;</span><br><span class="line">fread( &amp;header, <span class="keyword">sizeof</span>( FHEADER ), <span class="number">1</span>, streams );<span class="comment">//这里假设文件已打开,读取位置已经指向帧头所在的位置这样一次就可以读入帧头的所有信息了。</span></span><br></pre></td></tr></table></figure><h3 id="2、如何计算帧长度"><a href="#2、如何计算帧长度" class="headerlink" title="2、如何计算帧长度"></a>2、如何计算帧长度</h3><p>我们首先区分两个术语：帧大小和帧长度。帧大小即每帧采样数表示一帧中采样的个数，这是恒定值。其值入下表所示</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012145357902-914224524.png"></p><p>帧长度是压缩时每一帧的长度，包括帧头。它将填充的空位也计算在内。LayerI 的一个空位长 4 字节，LayerII 和 LayerIII 的空位是 1 字节。当读取 MPEG 文件时必须计算该值以便找到相邻的帧。<br>注意：因为有填充和比特率变换，帧长度可能变化。<br>从头中读取比特率，采样频率和填充，<br>LyaerI 使用公式：</p><ul><li>帧长度（字节） = (( 每帧采样数 / 8 * 比特率 ) / 采样频率 ) + 填充 * 4</li></ul><p>LyerII 和 LyaerIII 使用公式：</p><ul><li>帧长度（字节）= (( 每帧采样数 / 8 * 比特率 ) / 采样频率 ) + 填充</li><li>例：<br>LayerIII 比特率 128000, 采样频率 44100, 填充 0<br>=〉帧大小 417 字节</li></ul><h3 id="3、每帧的持续时间"><a href="#3、每帧的持续时间" class="headerlink" title="3、每帧的持续时间"></a>3、每帧的持续时间</h3><p>之前看了一些文章都说 mp3 的一帧的持续时间是 26ms, 结果在实际程序的编写中发现无法正确按时间定位到帧，然后又查了一些文章才知道，所谓 26ms 一帧只是针对 MPEG1 Layer III 而且采样率为 44.1KHz 来说是对的，但 mp3 文件并不都是如此，其实这个时间也是可以通过计算来获得，下面给出计算公式</p><ul><li>每帧持续时间（毫秒） = 每帧采样数 / 采样频率 * 1000</li></ul><p>这样通过计算可知 MPEG1 Layer III 采样率为 44.1KHz 的一帧持续时间为 26.12… 不是整数，不过我们权且认为它就是 26 毫秒吧。<br>如果是 MPEG2 Layer III 采样率为 16KHz 的话那一帧要持续 36 毫秒，这个相差还是蛮大的，所以还是应该通过计算来获的，当然可以按 MPEG 版本，层数和采样率来建一个表，这样直接查表就可以知道时间了。</p><h3 id="5、帧数据"><a href="#5、帧数据" class="headerlink" title="5、帧数据"></a>5、帧数据</h3><p>在帧头后边是 Side Info（姑且称之为通道信息）。对标准的立体声 MP3 文件来说其长度为 32 字节。通道信息后面是 Scale factor（增益因子）信息。当解码器在读到上述信息后，就可以进行解码了。当 MP3 文件被打开后，播放器首先试图对帧进行同步，然后分别读取通道信息及增益因子等数据，再进行霍夫曼解码，至此我们已经获得解压后的数据。但这些数据仍然不能进行播放，它们还处于频域，要想听到歌曲还要将它由频域通过特定的手段转换到时域。接下来的处理分别为立体化处理；抗锯齿处理；IMDCT 变换；IDCT 变换及窗口化滑动处理。</p><p>我们知道，对于 mp3 来说现在有两种编码方式，一种是 CBR, 也就是固定位率，固定位率的帧的大小在整个文件中都是是固定的（公式如上所述）, 只要知道文件总长度，和从第一帧帧头读出的信息，就都可以通过计算得出这个 mp3 文件的信息，比如总的帧数，总的播放时间等等，要定位到某一帧或某个时间点也很方便，这种编码方式不需要文件头，第一帧开始就是音频数据。另一种是 VBR, 就是可变位率，VBR 是 XING 公司推出的算法，所以在 MP3 的 FRAME 里会有“Xing”这个关键字（也有用”Info”来标识的，现在很多流行的小软件也可以进行 VBR 压缩，它们是否遵守这个约定，那就不得而知了）, 它存放在 MP3 文件中的第一个有效帧的数据区里，它标识了这个 MP3 文件是 VBR 的。同时第一个帧里存放了 MP3 文件的帧的总个数，这就很容易获得了播放总时间，同时还有 100 个字节存放了播放总时间的 100 个时间分段的帧索引，假设 4 分钟的 MP3 歌曲，240S, 分成 100 段，每两个相邻 INDEX 的时间差就是 2.4S, 所以通过这个 INDEX, 只要前后处理少数的 FRAME, 就能快速找出我们需要快进的帧头。其实这第一帧就相当于文件头了。不过现在有些编码器在编码 CBR 文件时也像 VBR 那样将信息记入第一帧，比如著名的 lame, 它使用”Info”来做 CBR 的标记。</p><h3 id="6、VBR-头"><a href="#6、VBR-头" class="headerlink" title="6、VBR 头"></a>6、VBR 头</h3><p>这里列出 VBR 的第一帧存储文件信息的头的格式。有两种格式，一种是常见的 XING Header<br>（头部包含字符‘Xing’)<br>, 另一种是 VBRI Header （头部包含字符‘VBRI’) 鉴于 VBRI Header<br>不 常 见 , 下 面 只 说 XING Header , 关 于 VBRI Header 请 看<br><a href="http://www.codeproject.com/audio/MPEGAudioInfo.asp%E3%80%82">http://www.codeproject.com/audio/MPEGAudioInfo.asp。</a><br>XING Header 的起始位置，相对于第一帧帧头的位置，单位是字节<br>36-39 “Xing”<br>21-24 “Xing”<br>21-24 “Xing”<br>13-16 “Xing”<br>文件为 MPEG1 并且不是单声道（大多数 VBR 的 mp3 文件都是如此）<br>文件为 MPEG1 并且是单声道<br>文件为 MPEG2 并且不是单声道<br>文件为 MPEG2 并且是单声道</p><p>XING Header 格式</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012145845855-1416090028.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012145854840-1633635283.png"></p><p>这样算来，XING Header 包括帧头一共最多只需要 156 个字节就够了。当然也可以在 XING<br>Header 后面存储编码器的信息，比如 lame 在其后就是存储其版本，这需要给第一帧留足够<br>的空间才行。<br>至于 mp3 的信息用从 XING Header 读出的信息就可以计算<br>比如<br>总持续时间 = 总帧数 * 每帧采样数 / 采样率 （结果为秒）<br>平均位率 = 文件长度 / 总持续时间 * 8</p><h2 id="MPEG-音频标签"><a href="#MPEG-音频标签" class="headerlink" title="MPEG 音频标签"></a>MPEG 音频标签</h2><p>MPEG 音频标签分为两种，一种是 ID3v1, 存在文件尾部，长度 128 字节，另一种是 ID3v2,<br>是对 ID3v1 的扩展，存在文件头部，长度不定。</p><h3 id="1、ID3v1"><a href="#1、ID3v1" class="headerlink" title="1、ID3v1"></a>1、ID3v1</h3><p>ID3v1 标签用来描述 MPEG 音频文件。包含艺术家，标题，唱片集，发布年代和流派。另<br>外还有额外的注释空间。位于音频文件的最后固定为 128 字节。可以读取该文件的最后这<br>128 字节获得标签。<br>结构如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AAABBBBB <span class="keyword">BBBBBBBB </span><span class="keyword">BBBBBBBB </span><span class="keyword">BBBBBBBB</span></span><br><span class="line"><span class="keyword">BCCCCCCC </span>CCCCCCCC CCCCCCCC CCCCCCCD</span><br><span class="line">DDDDDDDD DDDDDDDD DDDDDDDD DDDDDEEE</span><br><span class="line">EFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFG</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150427824-44825799.png"></p><p>该规格要求所有的空间必须以空字符 (ASCII 0) 填充。但是并不是所有的应用程序遵循该规<br>则，比如 winamp 就用空格 (ASCII 32) 代替之。<br>在 ID3v1.1 结构中有些改变。注释部分的最后一个字节用来定义唱片集中的轨道号。如果不<br>知道该信息时可以用空字符 (ASCII 0) 代替。<br>流派使用原码表示，为下列数字之一：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150447371-840131951.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150455027-279783863.png"></p><p>Winamp 扩充了这个表</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150511965-812032450.png"></p><p>其他任何的数值都认为是“unknown”</p><h3 id="2、ID3V2"><a href="#2、ID3V2" class="headerlink" title="2、ID3V2"></a>2、ID3V2</h3><p>ID3V2 到现在一共有 4 个版本，但流行的播放软件一般只支持第 3 版，既 ID3v2.3。由于<br>ID3V1 记录在 MP3 文件的末尾，ID3V2 就只好记录在 MP3 文件的首部了（如果有一天发<br>布 ID3V3, 真不知道该记录在哪里）。也正是由于这个原因，对 ID3V2 的操作比 ID3V1 要<br>慢。而且 ID3V2 结构比 ID3V1 的结构要复杂得多，但比前者全面且可以伸缩和扩展。<br>下面就介绍一下 ID3V2.3。<br>每个 ID3V2.3 的标签都一个标签头和若干个标签帧或一个扩展标签头组成。关于曲目的信息如标题、作者等都存放在不同的标签帧中，扩展标签头和标签帧并不是必要的，但每个标<br>签至少要有一个标签帧。标签头和标签帧一起顺序存放在 MP3 文件的首部。</p><h4 id="（一）、标签头"><a href="#（一）、标签头" class="headerlink" title="（一）、标签头"></a>（一）、标签头</h4><p>在文件的首部顺序记录 10 个字节的 ID3V2.3 的头部。数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> Header[<span class="number">3</span>]; <span class="comment">/*必须为&quot;ID3&quot;否则认为标签不存在*/</span></span><br><span class="line"><span class="keyword">char</span> Ver; <span class="comment">/*版本号 ID3V2.3 就记录 3*/</span></span><br><span class="line"><span class="keyword">char</span> Revision; <span class="comment">/*副版本号此版本记录为 0*/</span></span><br><span class="line"><span class="keyword">char</span> Flag; <span class="comment">/*存放标志的字节,这个版本只定义了三位,稍后详细解说*/</span></span><br><span class="line"><span class="keyword">char</span> Size[<span class="number">4</span>]; <span class="comment">/*标签大小,包括标签头的 10 个字节和所有的标签帧的大小*/</span></span><br><span class="line">注:对这里我有疑惑,因为在实际寻找首帧的过程中,我发现有的 mp3 文件的标签大小是不</span><br><span class="line">包含标签头的,但有的又是包含的,可能是某些 mp3 编码器写标签的 BUG,所以为了兼容</span><br><span class="line">只好认为其是包含的,如果按大小找不到,再向后搜索,直到找到首帧为止。</span><br></pre></td></tr></table></figure><p><strong>(1). 标志字节</strong></p><p>标志字节一般为 0, 定义如下：<br>abc00000<br>a – 表示是否使用 Unsynchronisation（这个单词不知道是什么意思，字典里也没有找到，一般<br>不设置）<br>b – 表示是否有扩展头部，一般没有（至少 Winamp 没有记录）, 所以一般也不设置<br>c – 表示是否为测试标签 (99.99% 的标签都不是测试用的啦，所以一般也不设置）</p><p><strong>(2). 标签大小</strong></p><p>一共四个字节，但每个字节只用 7 位，最高位不使用恒为 0。所以格式如下<br><code>0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx</code><br>计算大小时要将 0 去掉，得到一个 28 位的二进制数，就是标签大小（不懂为什么要这样做）,<br>计算公式如<br>下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> total_size;</span><br><span class="line">total_size = (<span class="built_in">Size</span>[<span class="number">0</span>]&amp;<span class="number">0</span>x7F)*<span class="number">0</span>x200000</span><br><span class="line">+(<span class="built_in">Size</span>[<span class="number">1</span>]&amp;<span class="number">0</span>x7F)*<span class="number">0</span>x4000</span><br><span class="line">+(<span class="built_in">Size</span>[<span class="number">2</span>]&amp;<span class="number">0</span>x7F)*<span class="number">0</span>x80</span><br><span class="line">+(<span class="built_in">Size</span>[<span class="number">3</span>]&amp;<span class="number">0</span>x7F)</span><br></pre></td></tr></table></figure><h4 id="（二）、标签帧"><a href="#（二）、标签帧" class="headerlink" title="（二）、标签帧"></a>（二）、标签帧</h4><p>每个标签帧都有一个 10 个字节的帧头和至少一个字节的不固定长度的内容组成。它们也是<br>顺序存放在文件<br>中，和标签头和其他的标签帧也没有特殊的字符分隔。得到一个完整的帧的内容只有从帧头<br>中的到内容大<br>小后才能读出，读取时要注意大小，不要将其他帧的内容或帧头读入。<br>帧头的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> FrameID[<span class="number">4</span>]; <span class="comment">/*用四个字符标识一个帧,说明其内容,稍后有常用的标识对照表*/</span><span class="keyword">char</span> Size[<span class="number">4</span>]; <span class="comment">/*帧内容的大小,不包括帧头,不得小于 1*/</span></span><br><span class="line"><span class="keyword">char</span> Flags[<span class="number">2</span>]; <span class="comment">/*存放标志,只定义了 6 位,稍后详细解说*/</span></span><br></pre></td></tr></table></figure><p><strong>(1). 帧标识</strong></p><p>用四个字符标识一个帧，说明一个帧的内容含义，常用的对照如下：<br>TIT2= 标题 表示内容为这首歌的标题，下同<br>TPE1= 作者<br>TALB= 专集<br>TRCK= 音轨 格式：N/M 其中 N 为专集中的第 N 首，M 为专集中共 M 首，N 和 M 为<br>ASCII 码表示的数字<br>TYER= 年代 是用 ASCII 码表示的数字<br>TCON= 类型 直接用字符串表示<br>COMM= 备注 格式：”eng\0 备注内容”, 其中 eng 表示备注所使用的自然语言</p><p><strong>(2). 大小</strong></p><p>这个可没有标签头的算法那么麻烦，每个字节的 8 位全用，格式如下<br><code>xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</code><br>算法如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> FSize;</span><br><span class="line">FSize = <span class="built_in">Size</span>[<span class="number">0</span>]*<span class="number">0</span>x1000000</span><br><span class="line">+<span class="built_in">Size</span>[<span class="number">1</span>]*<span class="number">0</span>x10000</span><br><span class="line">+<span class="built_in">Size</span>[<span class="number">2</span>]*<span class="number">0</span>x100</span><br><span class="line">+<span class="built_in">Size</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>(3). 标志</strong></p><p>只定义了 6 位，另外的 10 位为 0, 但大部分的情况下 16 位都为 0 就可以了。格式如下：<br><code>abc00000 ijk00000</code><br>a – 标签保护标志，设置时认为此帧作废<br>b – 文件保护标志，设置时认为此帧作废<br>c – 只读标志，设置时认为此帧不能修改（但我没有找到一个软件理会这个标志）<br>i – 压缩标志，设置时一个字节存放两个 BCD 码表示数字<br>j – 加密标志（没有见过哪个 MP3 文件的标签用了加密）<br>k – 组标志，设置时说明此帧和其他的某帧是一组<br>值得一提的是 winamp 在保存和读取帧内容的时候会在内容前面加个’\0’, 并把这个字节计<br>算在帧内容的<br>大小中。<br>附：帧标识的含义</p><p><strong>(4). Declared ID3v2 frames</strong></p><p>The following frames are declared in this draft.AENC Audio encryption<br>APIC Attached picture<br>COMM Comments<br>COMR Commercial frame<br>ENCR Encryption method registration<br>EQUA Equalization<br>ETCO Event timing codes<br>GEOB General encapsulated object<br>GRID Group identification registration<br>IPLS Involved people list<br>LINK Linked information<br>MCDI Music CD identifier<br>MLLT MPEG location lookup table<br>OWNE Ownership frame<br>PRIV Private frame<br>PCNT Play counter<br>POPM Popularimeter<br>POSS Position synchronisation frame<br>RBUF Recommended buffer size<br>RVAD Relative volume adjustment<br>RVRB Reverb<br>SYLT Synchronized lyric/text<br>SYTC Synchronized tempo codes<br>TALB Album/Movie/Show title<br>TBPM BPM (beats per minute)<br>TCOM Composer<br>TCON Content type<br>TCOP Copyright message<br>TDAT Date<br>TDLY Playlist delay<br>TENC Encoded by<br>TEXT Lyricist/Text writer<br>TFLT File type<br>TIME Time<br>TIT1 Content group description<br>TIT2 Title/songname/content description<br>TIT3 Subtitle/Description refinement<br>TKEY Initial key<br>TLAN Language(s)<br>TLEN Length<br>TMED Media type<br>TOAL Original album/movie/show title<br>TOFN Original filename<br>TOLY Original lyricist(s)/text writer(s)TOPE Original artist(s)/performer(s)<br>TORY Original release year<br>TOWN File owner/licensee<br>TPE1 Lead performer(s)/Soloist(s)<br>TPE2 Band/orchestra/accompaniment<br>TPE3 Conductor/performer refinement<br>TPE4 Interpreted, remixed, or otherwise modified by<br>TPOS Part of a set<br>TPUB Publisher<br>TRCK Track number/Position in set<br>TRDA Recording dates<br>TRSN Internet radio station name<br>TRSO Internet radio station owner<br>TSIZ Size<br>TSRC ISRC (international standard recording code)<br>TSSE Software/Hardware and settings used for encoding<br>TYER Year<br>TXXX User defined text information frame<br>UFID Unique file identifier<br>USER Terms of use<br>USLT Unsychronized lyric/text transcription<br>WCOM Commercial information<br>WCOP Copyright/Legal information<br>WOAF Official audio file webpage<br>WOAR Official artist/performer webpage<br>WOAS Official audio source webpage<br>WORS Official internet radio station homepage<br>WPAY Payment<br>WPUB Publishers official webpage<br>WXXX User defined URL link frame</p><h2 id="MP3-文件实例剖析"><a href="#MP3-文件实例剖析" class="headerlink" title="MP3 文件实例剖析"></a>MP3 文件实例剖析</h2><p>打开一个名为 test.mp3 文件，其内容如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">000000 FF FB<span class="number"> 52 </span>8C<span class="number"> 00 </span>00<span class="number"> 01 </span>49<span class="number"> 09 </span>C5<span class="number"> 05 </span>24<span class="number"> 60 </span>00 2A C1</span><br><span class="line">000010<span class="number"> 19 </span>40 A6<span class="number"> 00 </span>00<span class="number"> 05 </span>96<span class="number"> 41 </span>34<span class="number"> 18 </span>20<span class="number"> 80 </span>08<span class="number"> 26 </span>48 29</span><br><span class="line">000020<span class="number"> 83 </span>04<span class="number"> 00 </span>01<span class="number"> 61 </span>41<span class="number"> 40 </span>50<span class="number"> 10 </span>04<span class="number"> 00 </span>C1<span class="number"> 21 </span>41<span class="number"> 50 </span>64</span><br><span class="line">......</span><br><span class="line">0000D0 FE FF FB<span class="number"> 52 </span>8C<span class="number"> 11 </span>80<span class="number"> 01 </span>EE<span class="number"> 90 </span>65 6E<span class="number"> 08 </span>20<span class="number"> 02 </span>30</span><br><span class="line">0000E0<span class="number"> 32 </span>0C CD C0<span class="number"> 04 </span>00<span class="number"> 46 </span>16<span class="number"> 41 </span>89 B8<span class="number"> 01 </span>00<span class="number"> 08 </span>36 48</span><br><span class="line">0000F033 B7<span class="number"> 00 </span>00<span class="number"> 01 </span>02 FF FF FF F4 E1 2F FF FF FF FF</span><br><span class="line">......</span><br><span class="line">0001A0 DF FF FF FB<span class="number"> 52 </span>8C<span class="number"> 12 </span>00<span class="number"> 01 </span>FE<span class="number"> 90 </span>58 6E<span class="number"> 09 </span>A0 02</span><br><span class="line">0001B0<span class="number"> 33 </span>B0 CA<span class="number"> 85 </span>E1<span class="number"> 50 </span>01<span class="number"> 45 </span>F6<span class="number"> 19 </span>61 BC<span class="number"> 26 </span>80<span class="number"> 28 </span>7C</span><br><span class="line">0001C0<span class="number"> 05 </span>AC B4<span class="number"> 20 </span>28<span class="number"> 94 </span>FF FF FF FF FF FF FF FF FF FF......</span><br><span class="line">001390 7F FF FF FF FD 4E<span class="number"> 00 </span>54<span class="number"> 41 </span>47<span class="number"> 54 </span>45<span class="number"> 53 </span>54<span class="number"> 00 </span>00</span><br><span class="line">0013A0<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00</span><br><span class="line">......</span><br><span class="line">0013F000<span class="number"> 00 </span>00<span class="number"> 00 </span>04<span class="number"> 19 </span>14<span class="number"> 03 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00 00</span><br><span class="line">001400<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00</span><br><span class="line">001410<span class="number"> 00 </span>00<span class="number"> 00 </span>00<span class="number"> 00 </span>00 4E</span><br></pre></td></tr></table></figure><p>该文件长度 1416H(5.142K), 帧头为：FF FB 52 8C, 转换成二进制为：<br><code>11111111 11111011</code><br><code>01010010 10001100</code><br>对照表 1 可知，test.mp3 帧头信息见表 5。<br>表 5 test.mp3 文件帧头信息</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/1177848-20171012150541215-1878531096.png"><br>第 1397H 开始的三个字节是 54 41 47, 存放的是字符“TAG”, 表示此文件有 ID3 V1.0 信息。<br>139AH 开始的 30 个字节存放歌名，前 4 个非 00 字节是 54 45 53 54, 表示“TEST”;<br>13F4H 开始的 4 个字节是 04 19 14 03, 存放年份“04/25/2003”;<br>最后 1 个字节是 4E, 表示音乐类别，代号为 78, 即“Rock&amp;Roll”;<br>其它字节均为 00, 未存储信息。</p><p>原文链接：<a href="https://www.cnblogs.com/ranson7zop/p/7655474.html">https://www.cnblogs.com/ranson7zop/p/7655474.html</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://wenku.baidu.com/view/d4877350ad02de80d4d840cb.html">MP3文件格式解析</a></li><li><a href="https://wenku.baidu.com/view/a071bf4e852458fb770b56a0.html">MPEG音频文件格式(包括MP3文件格式)详解</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MP3-文件格式解析&quot;&gt;&lt;a href=&quot;#MP3-文件格式解析&quot; class=&quot;headerlink&quot; title=&quot;MP3 文件格式解析&quot;&gt;&lt;/a&gt;MP3 文件格式解析&lt;/h1&gt;&lt;p&gt;MP3 的全称是 MPEG Audio Layer3, 它是一种高效的计算机音频编码方案，它以较大的压缩比将音频文件转换成较小的扩展名为。MP3 的文件，基本保持原文件的音质。MP3 是 ISO/MPEG 标准的一部分，ISO/MPEG 标准描述了使用高性能感知编码方案的音频压缩，此标准一直在不断更新以满足“质高量小”的追求，现已形成 MPEGLayer1、Layer2、Layer3 三个音频编码解码方案。MPEGLayer3 压缩率可达 1:10 至 1:12,1M 的 MP3 文件可播放 1 分钟，而 1 分钟 CD 音质的 WAV 文件 (44100Hz,16bit, 双声道，60 秒）要占用 10M 空间，这样算来，一张 650M 的 MP3 光盘播放时间应在 10 小时以上，而同样容量的一张 CD 盘播放时间在 70 分钟左右。MP3 的优势是 CD 难以比拟的。&lt;/p&gt;
&lt;h2 id=&quot;MPEG-Audio-标准&quot;&gt;&lt;a href=&quot;#MPEG-Audio-标准&quot; class=&quot;headerlink&quot; title=&quot;MPEG Audio 标准&quot;&gt;&lt;/a&gt;MPEG Audio 标准&lt;/h2&gt;&lt;p&gt;MPEG(MovingPictureExpertsGroup) 是 ISO 下的一个动态图 像专家组，它制定的 MPEG 标准广泛应用于各种多媒体中。 MPEG 标准包括视频和音频标准，其中音频标准已制定出 MPEG-1、MPEG-2、MPEG-2AAC 和 MPEG-4。&lt;/p&gt;
&lt;p&gt;MPEG-1 和 MPEG-2 标准使用同一个音频编码解码族—Layer1、2、3。MPEG-2 一个新特点是采用低采样率扩展降低数据流量，另一特点是多通道扩展，将主声道增加为 5 个。MPEG-2AAC(MPEG-2AdvancedAudioCoding) 标准是 FraunhoferIIS 同 AT&amp;amp;T 公司于 1997 年推出的，旨在显著减少数据流量，MPEG22AAC 采用的修正的离散余弦变换 (MDCT,ModifiedDiscreteCo2sineTransform) 算法，采样率可在 8KHz 到 96KHz 之间，声道数可在 1-48 之间。&lt;/p&gt;
&lt;p&gt;MPEG Audio Layer1、2、3 三个层使用相同的滤波器组、位流结构和头信息，采样频率为 32KHz、4411KHz 或 48KHz。Layer1 是为数字压缩磁带 DCC(DigitalCompactCassette) 设计的，数据流量为 384kbps,Layer2 在复杂性和性能间作了权衡，数据流量下降到 256kbps-192kbps。Layer3 一开始就为低数据流量而设计，数据流量在 128kbps-112kbps,Layer3 增加了 MDCT 变换，使其频率分辨能力是 Layer2 的 18 倍，Layer3 还使用了与 MPEGVid2eo 类似的平均信息量编码 (EntropyCoding), 减少了冗余信息。MP3 绝大部分使用的是 MPEG21 标准。&lt;/p&gt;
&lt;h2 id=&quot;音频压缩&quot;&gt;&lt;a href=&quot;#音频压缩&quot; class=&quot;headerlink&quot; title=&quot;音频压缩&quot;&gt;&lt;/a&gt;音频压缩&lt;/h2&gt;&lt;p&gt;MP3 格式始于 80 年代中期，德国 Erlangen 的 Fraunhofer 研究 所致力于高质量、低数据率的声音编码。&lt;/p&gt;
&lt;p&gt;MP3 音频压缩包含编码和解码两个部分。编码是将 WAV 文件中的数据转换成高压缩率的位流形式，解码是接受位流并将其重建到 WAV 文件中。&lt;/p&gt;
&lt;p&gt;MP3 采用了感知音频编码 (PerceptualAudioCoding) 这一失真算法。人耳感受声音的频率范围是 20Hz-220kHz,MP3 截掉了大量的冗余信号和无关的信号，编码器通过混合滤波器组将原始声音变换到频率域，利用心理声学模型，估算刚好能被察觉到的噪声水平，再经过量化，转换成 Huffman 编码，形成 MP3 位流。解码器要简单得多，它的任务是从编码后的谱线成分中，经过反 量化和逆变换，提取出声音信号。&lt;/p&gt;</summary>
    
    
    
    <category term="Audio" scheme="https://alliswell.top/categories/Audio/"/>
    
    
    <category term="Audio" scheme="https://alliswell.top/tags/Audio/"/>
    
    <category term="MP3" scheme="https://alliswell.top/tags/MP3/"/>
    
  </entry>
  
  <entry>
    <title>G.711 编解码原理</title>
    <link href="https://alliswell.top/wiki/G-711%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/"/>
    <id>https://alliswell.top/wiki/G-711%E7%BC%96%E8%A7%A3%E7%A0%81%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-30T06:27:00.000Z</published>
    <updated>2021-01-26T02:48:56.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="G-711-编解码原理"><a href="#G-711-编解码原理" class="headerlink" title="G.711 编解码原理"></a>G.711 编解码原理</h1><p>G.711 是 ITU-T 定制出来的一套语音压缩标准，它代表了对数 PCM（logarithmic pulse-code modulation）抽样标准，是主流的波形声音编解码标准，主要用于电话。</p><p>G.711 编码采用 8kHz 采样率，有 A-law 和μ-law 两种编码方式，分别是将 13bit 和 14bit 编码为 8bit，因此 G711 固定码率是 8kHz×8bit=64kbps。两者都是对数变换，A-law 更加方便计算机处理。μ-law 提供了略微高一些的动态范围，但代价是对于弱信号的量化误差相对 A-law 高一些。</p><h2 id="转换公式"><a href="#转换公式" class="headerlink" title="转换公式"></a>转换公式</h2><p>下面分别介绍两种算法的转换公式。</p><p>A-law:</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144349406.png"></p><p>一般采用 A=87.6, 画出图来则是如下图，用 x 表示输入的采样值，F(x) 表示通过 A-law 变换后的采样值，y 是对 F(x) 进行量化后的采样值。</p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144420043.png" alt="image-20201130144420043" style="zoom:80%;" /><p>由此可见在输入的 x 为高值的时候，F(x) 的变化是缓慢的，有较大范围的 x 对应的 F(x) 最终被量化为同一个 y，精度较低。相反在低声强区域，也就是 x 为低值的时候，F(x) 的变化很剧烈，有较少的不同 x 对应的 F(x) 被量化为同一个 y。意思就是说在声音比较小的区域，精度较高，便于区分，而声音比较大的区域，精度不是那么高。</p><p> μ-law 的公式如下，μ取值一般为 255</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144523378.png"></p><p>和 A-law 画在同一个坐标轴中就能发现 A-law 在低强度信号下，精度要稍微高一些。</p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144536867.png" alt="image-20201130144536867" style="zoom:80%;" /><p>实际应用中，采用浮点数计算的方式计算，然后进行量化，计算量会比较大，实际上对于 A-law（A=87.6 时），是采用 13 折线近似的方式来计算的，而μ-law（μ=255 时）则是 15 段折线近似的方式。</p><p>A-law 如下表计算，第一列是采样点，共 13bit，最高位为符号位。对于前两行，折线斜率均为 1/2，跟负半段的相应区域位于同一段折线上，对于 3 到 8 行，斜率分别是 1/4 到 1/128，共 6 段折线，加上负半段对应的 6 段折线，总共 13 段折线，这就是所谓的 A-law 十三段折线法</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/74797-20180415174356930-1878134610.png"></p><p>解码公式：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201130144809068.png"></p><p>相应的μ-law 的计算方法如下表。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/74797-20180415181431844-1395002987.png"></p><p>本质上跟 A-law 的区别不大</p><h2 id="16bitPCM-转-alaw-代码"><a href="#16bitPCM-转-alaw-代码" class="headerlink" title="16bitPCM 转 alaw 代码"></a>16bitPCM 转 alaw 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pcm2alaw.c</span></span><br><span class="line"><span class="comment">// https://blog.csdn.net/wzying25/article/details/79398055</span></span><br><span class="line"><span class="comment">// @sun 2020.06.23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGN_BIT (0x80)  <span class="comment">/* Sign bit for a A-law byte. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUANT_MASK (0xf) <span class="comment">/* Quantization field mask.   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSEGS (8)        <span class="comment">/* Number of A-law segments.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_SHIFT (4)    <span class="comment">/* Left shift for segment number. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_MASK (0x70)  <span class="comment">/* Segment field mask. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">short</span> seg_end[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">0xFF</span>,   <span class="number">0x1FF</span>,  <span class="number">0x3FF</span>, <span class="number">0x7FF</span>, <span class="number">0xFFF</span>,</span><br><span class="line">    <span class="number">0x1FFF</span>, <span class="number">0x3FFF</span>, <span class="number">0x7FFF</span>&#125;;  <span class="comment">//分成不均匀的8个分段，算上负数，总共是16个分段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">short</span> *table, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= *table++) <span class="keyword">return</span> (i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment"> * 输入参数范围 ：-32768~32767</span></span><br><span class="line"><span class="comment"> * 返回8位无符号整数</span></span><br><span class="line"><span class="comment"> * linear2alaw() - Convert a 16-bit linear PCM value to 8-bit A-law</span></span><br><span class="line"><span class="comment"> * For further information see John C. Bellamy&#x27;s Digital Telephony, 1982,</span></span><br><span class="line"><span class="comment"> * John Wiley &amp; Sons, pps 98-111 and 472-476.</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">linear2alaw</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> pcm_val)</span> <span class="comment">/* 2&#x27;s complement (16-bit range) */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="keyword">int</span> seg;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> aval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里右移3位，因为采样值是16bit，而A-law是13bit，存储在高13位上，低3位被舍弃</span></span><br><span class="line">    pcm_val = pcm_val &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pcm_val &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mask = <span class="number">0xD5</span>; <span class="comment">/* sign (7th) bit = 1 二进制的11010101*/</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mask = <span class="number">0x55</span>;             <span class="comment">/* sign bit = 0  二进制的01010101*/</span></span><br><span class="line">        pcm_val = -pcm_val - <span class="number">1</span>;  <span class="comment">//负数转换为正数计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Convert the scaled magnitude to segment number. */</span></span><br><span class="line">    seg = search(pcm_val, seg_end, <span class="number">8</span>);  <span class="comment">//返回pcm_val属于哪个分段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Combine the sign, segment, and quantization bits. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg &gt;= <span class="number">8</span>) <span class="comment">/* out of range, return maximum value. */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0x7F</span> ^ mask);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        aval = seg &lt;&lt; SEG_SHIFT;</span><br><span class="line">        <span class="comment">// aval为每一段的偏移，分段量化后的数据需要加上该偏移（aval）</span></span><br><span class="line">        <span class="comment">//分段量化</span></span><br><span class="line">        <span class="comment">//量化方法： (pcm_val-分段值)，然后取有效的高4位   （0分段例外）</span></span><br><span class="line">        <span class="comment">//比如 pcm_val = 0x7000 ，那么seg=7 ，第7段的范围是0x4000~0x7FFF</span></span><br><span class="line">        <span class="comment">//，段偏移aval=7&lt;&lt;4=0x7F 0x7000-0x4000=0x3000</span></span><br><span class="line">        <span class="comment">// ，然后取有效的高4位，即右移10(seg+3)，0x3000&gt;&gt;10=0xC</span></span><br><span class="line">        <span class="comment">//上一步等效为：(0x7000&gt;&gt;10)&amp;0xF=0xC 。也就是： (pcm_val &gt;&gt; (seg + 3)) &amp;</span></span><br><span class="line">        <span class="comment">// QUANT_MASK 然后加上段偏移 0x7F(aval) ，加法等效于或运算，即 |aval</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seg &lt; <span class="number">2</span>)</span><br><span class="line">            aval |= (pcm_val &gt;&gt; <span class="number">4</span>) &amp; QUANT_MASK;  <span class="comment">// 0、1段折线的斜率一样</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            aval |= (pcm_val &gt;&gt; (seg + <span class="number">3</span>)) &amp; QUANT_MASK;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            aval ^</span><br><span class="line">            mask);  <span class="comment">//异或0x55，目的是尽量避免出现连续的0，或连续的1，提高传输过程的可靠性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pcm2alaw.h</span></span><br><span class="line"><span class="comment">// @sun 2020.06.23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">linear2alaw</span><span class="params">(<span class="keyword">int</span> pcm_val)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment"> * @Copyright (C)  2020  all right reserved</span></span><br><span class="line"><span class="comment"> * @file main.c</span></span><br><span class="line"><span class="comment"> * @ingroup wav</span></span><br><span class="line"><span class="comment"> * @author SunZhenliang</span></span><br><span class="line"><span class="comment"> * @date 2020-06</span></span><br><span class="line"><span class="comment"> * @brief pcm2alaw</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pcm2alaw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WAV_HEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ChunkID[<span class="number">4</span>];         <span class="comment">// &quot;RIFF&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkSize;  <span class="comment">// 文件长度(WAVE文件的大小, 不含前8个字节)</span></span><br><span class="line">    <span class="keyword">char</span> Format[<span class="number">4</span>];          <span class="comment">// &quot;WAVE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk1ID[<span class="number">4</span>];             <span class="comment">// &quot;fmt &quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk1Size;      <span class="comment">// 过渡字节(不定)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> AudioFormat;  <span class="comment">// 格式类别(10H为PCM格式的声音数据)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> NumChannels;  <span class="comment">// 通道数(单声道为1, 双声道为2)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SampleRate;         <span class="comment">// 采样率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ByteRate;           <span class="comment">// 波形音频数据传输速率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BlockAlign;   <span class="comment">// data数据块长度、字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BitsPerSample;  <span class="comment">// PCM 位宽</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk2ID[<span class="number">4</span>];         <span class="comment">// &quot;data&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk2Size;  <span class="comment">// data数据的长度</span></span><br><span class="line">&#125; WAV_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALAW_HEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ChunkID[<span class="number">4</span>];         <span class="comment">// &quot;RIFF&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkSize;  <span class="comment">// 文件长度(WAVE文件的大小, 不含前8个字节)</span></span><br><span class="line">    <span class="keyword">char</span> Format[<span class="number">4</span>];          <span class="comment">// &quot;WAVE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk1ID[<span class="number">4</span>];             <span class="comment">// &quot;fmt &quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk1Size;      <span class="comment">// 过渡字节(不定)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> AudioFormat;  <span class="comment">// 格式类别(10H为PCM格式的声音数据)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> NumChannels;  <span class="comment">// 通道数(单声道为1, 双声道为2)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SampleRate;         <span class="comment">// 采样率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ByteRate;           <span class="comment">// 波形音频数据传输速率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BlockAlign;   <span class="comment">// data数据块长度、字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BitsPerSample;  <span class="comment">// PCM 位宽</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk3ID[<span class="number">4</span>];         <span class="comment">// &quot;fact&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk3Size;  <span class="comment">// fact数据的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SampleLength;   <span class="comment">// data数据的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk2ID[<span class="number">4</span>];         <span class="comment">// &quot;data&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk2Size;  <span class="comment">// data数据的长度</span></span><br><span class="line">&#125; ALAW_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE *fpin = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *fout = <span class="literal">NULL</span>;</span><br><span class="line">    WAV_HEADER wav;</span><br><span class="line">    ALAW_HEADER alaw;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> pcm_val;</span><br><span class="line"></span><br><span class="line">    fpin = fopen(<span class="string">&quot;./M1F1-int16-AFsp.wav&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fread(&amp;wav, <span class="keyword">sizeof</span>(struct WAV_HEADER), <span class="number">1</span>, fpin);</span><br><span class="line">    fout = fopen(<span class="string">&quot;./8bitalaw.wav&quot;</span>, <span class="string">&quot;w+b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WAV_HEADER</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ChunkID=%c%c%c%c\n&quot;</span>, wav.ChunkID[<span class="number">0</span>], wav.ChunkID[<span class="number">1</span>], wav.ChunkID[<span class="number">2</span>],</span><br><span class="line">           wav.ChunkID[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ChunkSize=%d\n&quot;</span>, wav.ChunkSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Format=%c%c%c%c\n&quot;</span>, wav.Format[<span class="number">0</span>], wav.Format[<span class="number">1</span>], wav.Format[<span class="number">2</span>],</span><br><span class="line">           wav.Format[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SubChunk1ID=%c%c%c%c\n&quot;</span>, wav.SubChunk1ID[<span class="number">0</span>], wav.SubChunk1ID[<span class="number">1</span>],</span><br><span class="line">           wav.SubChunk1ID[<span class="number">2</span>], wav.SubChunk1ID[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SubChunk1Size=%d\n&quot;</span>, wav.SubChunk1Size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AudioFormat=%d\n&quot;</span>, wav.AudioFormat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NumChannels=%d\n&quot;</span>, wav.NumChannels);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SampleRate=%d\n&quot;</span>, wav.SampleRate);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ByteRate=%d\n&quot;</span>, wav.ByteRate);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BlockAlign=%d\n&quot;</span>, wav.BlockAlign);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BitsPerSample=%d\n&quot;</span>, wav.BitsPerSample);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SubChunk2ID=%c%c%c%c\n&quot;</span>, wav.SubChunk2ID[<span class="number">0</span>], wav.SubChunk2ID[<span class="number">1</span>],</span><br><span class="line">           wav.SubChunk2ID[<span class="number">2</span>], wav.SubChunk2ID[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SubChunk2Size=%d\n&quot;</span>, wav.SubChunk2Size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get alaw header</span></span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.ChunkID, wav.ChunkID);</span><br><span class="line">    alaw.ChunkSize = (wav.ChunkSize - <span class="number">36</span>) / <span class="number">2</span> + <span class="number">48</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.Format, wav.Format);</span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.SubChunk1ID, wav.SubChunk1ID);</span><br><span class="line">    alaw.SubChunk1Size = wav.SubChunk1Size;</span><br><span class="line">    alaw.AudioFormat = wav.AudioFormat;</span><br><span class="line">    alaw.NumChannels = wav.NumChannels;</span><br><span class="line">    alaw.SampleRate = wav.SampleRate;</span><br><span class="line">    alaw.ByteRate = wav.ByteRate;</span><br><span class="line">    alaw.BlockAlign = wav.BlockAlign;</span><br><span class="line">    alaw.BitsPerSample = wav.BitsPerSample;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.SubChunk3ID, <span class="string">&quot;fact&quot;</span>);</span><br><span class="line">    alaw.SubChunk3Size = <span class="number">4</span>;</span><br><span class="line">    alaw.SampleLength = (wav.ChunkSize - <span class="number">36</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(alaw.SubChunk2ID, wav.SubChunk2ID);</span><br><span class="line">    alaw.SubChunk2Size = (wav.ChunkSize - <span class="number">36</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write into 8bitalaw.wav</span></span><br><span class="line">    fwrite(&amp;alaw, <span class="keyword">sizeof</span>(ALAW_HEADER), <span class="number">1</span>, fout);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> == fread(&amp;pcm_val, <span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>), <span class="number">1</span>, fpin)) &#123;</span><br><span class="line">        tmp = linear2alaw(pcm_val);  <span class="comment">// 16bit in, 8bit out</span></span><br><span class="line">        fputc(tmp, fout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fpin);</span><br><span class="line">    fclose(fout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>G.71 的原理和计算也比较简单，但是其中用到的一些基本原理同样在其他编码算法中得到了应用，对其进行深入的了解有助于更好的理解其他的算法。</p><p>源代码中关于移位运算，掩码运算，还不是完全的理解，只能根据自己的经验进行一些猜测，之后会继续学习，希望对这方面能有更深入的认识。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://en.wikipedia.org/wiki/A-law_algorithm">Alaw-Wikipedia</a></li><li><a href="https://github.com/quatanium/foscam-ios-sdk/blob/master/g726lib/g711.c">g711.c source code</a></li><li><a href="https://www.jianshu.com/p/512ce6566f8a">G.711编码原理</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;G-711-编解码原理&quot;&gt;&lt;a href=&quot;#G-711-编解码原理&quot; class=&quot;headerlink&quot; title=&quot;G.711 编解码原理&quot;&gt;&lt;/a&gt;G.711 编解码原理&lt;/h1&gt;&lt;p&gt;G.711 是 ITU-T 定制出来的一套语音压缩标准，它代表了对数 PCM（logarithmic pulse-code modulation）抽样标准，是主流的波形声音编解码标准，主要用于电话。&lt;/p&gt;
&lt;p&gt;G.711 编码采用 8kHz 采样率，有 A-law 和μ-law 两种编码方式，分别是将 13bit 和 14bit 编码为 8bit，因此 G711 固定码率是 8kHz×8bit=64kbps。两者都是对数变换，A-law 更加方便计算机处理。μ-law 提供了略微高一些的动态范围，但代价是对于弱信号的量化误差相对 A-law 高一些。&lt;/p&gt;
&lt;h2 id=&quot;转换公式&quot;&gt;&lt;a href=&quot;#转换公式&quot; class=&quot;headerlink&quot; title=&quot;转换公式&quot;&gt;&lt;/a&gt;转换公式&lt;/h2&gt;&lt;p&gt;下面分别介绍两种算法的转换公式。&lt;/p&gt;
&lt;p&gt;A-law:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/SunGitee/src/raw/master/img/image-20201130144349406.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般采用 A=87.6, 画出图来则是如下图，用 x 表示输入的采样值，F(x) 表示通过 A-law 变换后的采样值，y 是对 F(x) 进行量化后的采样值。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/SunGitee/src/raw/master/img/image-20201130144420043.png&quot; alt=&quot;image-20201130144420043&quot; style=&quot;zoom:80%;&quot;&gt;

&lt;p&gt;由此可见在输入的 x 为高值的时候，F(x) 的变化是缓慢的，有较大范围的 x 对应的 F(x) 最终被量化为同一个 y，精度较低。相反在低声强区域，也就是 x 为低值的时候，F(x) 的变化很剧烈，有较少的不同 x 对应的 F(x) 被量化为同一个 y。意思就是说在声音比较小的区域，精度较高，便于区分，而声音比较大的区域，精度不是那么高。&lt;/p&gt;</summary>
    
    
    
    <category term="Audio" scheme="https://alliswell.top/categories/Audio/"/>
    
    
    <category term="Audio" scheme="https://alliswell.top/tags/Audio/"/>
    
    <category term="G.711" scheme="https://alliswell.top/tags/G-711/"/>
    
    <category term="alaw" scheme="https://alliswell.top/tags/alaw/"/>
    
    <category term="ulaw" scheme="https://alliswell.top/tags/ulaw/"/>
    
  </entry>
  
  <entry>
    <title>wav 文件格式详解</title>
    <link href="https://alliswell.top/wiki/wav%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://alliswell.top/wiki/wav%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-11-29T11:43:31.000Z</published>
    <updated>2021-01-26T02:48:56.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wav-文件格式详解"><a href="#wav-文件格式详解" class="headerlink" title="wav 文件格式详解"></a>wav 文件格式详解</h1><p>WAVE 文件规范来自微软。文件格式使用 RIFF 块，每个块由块标识符、块长度和块数据组成。</p><h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>编码包括了两方面内容，一是按一定格式存储数据，二是采用一定的算法压缩数据。WAV 格式对音频流的编码没有硬性规定，支持非压缩的 PCM(Puls Code Modulation) 脉冲编码调制格式，还支持压缩型的微软自适应分脉冲编码调制 Microsoft ADPCM(Adaptive Differential Puls Code Modulation)、国际电报联盟 (International Telegraph Union) 制定的语音压缩标准 ITUG.711 a-law、ITU G.711-law、IMA ADPCM、ITU G.723 ADPCM (Yamaha)、GSM 6.10、ITU G.721 ADPCM 编码和其它压缩算法。MP3 编码同样也可以运用在 WAV 中，只要安装相应的 Decode, 就可以播放 WAV 中的 MP3 音乐。</p><h3 id="PCM-格式"><a href="#PCM-格式" class="headerlink" title="PCM 格式"></a>PCM 格式</h3><p>PCM 编码是直接存储声波采样被量化后所产生的非压缩数据，故被视为单纯的无损耗编码格式，其优点是可获得高质量的音频信号。<br>基于 PCM 编码的 WAV 格式是最基本的 WAV 格式，被声卡直接支持，能直接存储采样的声音数据，所存储的数据能直接通过声卡播放，还原的波形曲线与原始声音波形十分接近，播放的声音质量是一流的，在 Windows 平台下被支持得最好，常常被用作在其它编码的文件之间转换的中间文件。PCM 的缺点是文件体积过大，不适合长时间记录。正因为如此，又出现了多种在 PCM 编码的基础上经改进发展起来的编码格式，如：DPCM,ADPCM 编码等。</p><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>WAV 文件采用的是 RIFF 格式结构，WAV 文件有一个主 RIFF 块，它包括一个 Wave 标识符，后跟一个子块。数据以低位字节顺序存储。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129203223281.png"></p><p>fmt 块指定数据的格式。采样数据的格式块有 3 种，这些不同于基本 fmt 块。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129203423952.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129203658167.png"></p><p>非 PCM 格式必须 fact 块。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129203929926.png"></p><p>data 块包含采样数据。</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204019646.png"></p><p>example：</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204057463.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204127190.png"></p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204556302.png"></p><p>如果采样数据是 PCM 格式，则通常可以省略 fact 块。</p><p>整体来说如下图概括</p><p><img src="https://gitee.com/SunGitee/src/raw/master/img/image-20201129204302173.png"></p><p>代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WAV_HEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ChunkID[<span class="number">4</span>];                 <span class="comment">// &quot;RIFF&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ChunkSize;          <span class="comment">// 文件长度(WAVE文件的大小, 不含前8个字节)</span></span><br><span class="line">    <span class="keyword">char</span> Format[<span class="number">4</span>];                  <span class="comment">// &quot;WAVE&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk1ID[<span class="number">4</span>];             <span class="comment">// &quot;fmt &quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk1Size;      <span class="comment">// 过渡字节(不定)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> AudioFormat;  <span class="comment">// 格式类别(10H为PCM格式的声音数据)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> NumChannels;  <span class="comment">// 通道数(单声道为1, 双声道为2)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SampleRate;         <span class="comment">// 采样率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ByteRate;           <span class="comment">// 波形音频数据传输速率</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BlockAlign;   <span class="comment">// data数据块长度、字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> BitsPerSample;<span class="comment">// PCM 位宽</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> SubChunk2ID[<span class="number">4</span>];             <span class="comment">// &quot;data&quot;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> SubChunk2Size;      <span class="comment">// data数据的长度</span></span><br><span class="line">    &#125; WAV_HEADER;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">Audio File Format Specifications</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;wav-文件格式详解&quot;&gt;&lt;a href=&quot;#wav-文件格式详解&quot; class=&quot;headerlink&quot; title=&quot;wav 文件格式详解&quot;&gt;&lt;/a&gt;wav 文件格式详解&lt;/h1&gt;&lt;p&gt;WAVE 文件规范来自微软。文件格式使用 RIFF 块，每个块由块标识符、块长度和块数据组成。&lt;/p&gt;
&lt;h2 id=&quot;文件编码&quot;&gt;&lt;a href=&quot;#文件编码&quot; class=&quot;headerlink&quot; title=&quot;文件编码&quot;&gt;&lt;/a&gt;文件编码&lt;/h2&gt;&lt;p&gt;编码包括了两方面内容，一是按一定格式存储数据，二是采用一定的算法压缩数据。WAV 格式对音频流的编码没有硬性规定，支持非压缩的 PCM(Puls Code Modulation) 脉冲编码调制格式，还支持压缩型的微软自适应分脉冲编码调制 Microsoft ADPCM(Adaptive Differential Puls Code Modulation)、国际电报联盟 (International Telegraph Union) 制定的语音压缩标准 ITUG.711 a-law、ITU G.711-law、IMA ADPCM、ITU G.723 ADPCM (Yamaha)、GSM 6.10、ITU G.721 ADPCM 编码和其它压缩算法。MP3 编码同样也可以运用在 WAV 中，只要安装相应的 Decode, 就可以播放 WAV 中的 MP3 音乐。&lt;/p&gt;
&lt;h3 id=&quot;PCM-格式&quot;&gt;&lt;a href=&quot;#PCM-格式&quot; class=&quot;headerlink&quot; title=&quot;PCM 格式&quot;&gt;&lt;/a&gt;PCM 格式&lt;/h3&gt;&lt;p&gt;PCM 编码是直接存储声波采样被量化后所产生的非压缩数据，故被视为单纯的无损耗编码格式，其优点是可获得高质量的音频信号。&lt;br&gt;基于 PCM 编码的 WAV 格式是最基本的 WAV 格式，被声卡直接支持，能直接存储采样的声音数据，所存储的数据能直接通过声卡播放，还原的波形曲线与原始声音波形十分接近，播放的声音质量是一流的，在 Windows 平台下被支持得最好，常常被用作在其它编码的文件之间转换的中间文件。PCM 的缺点是文件体积过大，不适合长时间记录。正因为如此，又出现了多种在 PCM 编码的基础上经改进发展起来的编码格式，如：DPCM,ADPCM 编码等。&lt;/p&gt;
&lt;h2 id=&quot;文件格式&quot;&gt;&lt;a href=&quot;#文件格式&quot; class=&quot;headerlink&quot; title=&quot;文件格式&quot;&gt;&lt;/a&gt;文件格式&lt;/h2&gt;&lt;p&gt;WAV 文件采用的是 RIFF 格式结构，WAV 文件有一个主 RIFF 块，它包括一个 Wave 标识符，后跟一个子块。数据以低位字节顺序存储。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/SunGitee/src/raw/master/img/image-20201129203223281.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;fmt 块指定数据的格式。采样数据的格式块有 3 种，这些不同于基本 fmt 块。&lt;/p&gt;</summary>
    
    
    
    <category term="Audio" scheme="https://alliswell.top/categories/Audio/"/>
    
    
    <category term="Audio" scheme="https://alliswell.top/tags/Audio/"/>
    
    <category term="wav" scheme="https://alliswell.top/tags/wav/"/>
    
  </entry>
  
  <entry>
    <title>库调用的那点事</title>
    <link href="https://alliswell.top/wiki/%E5%BA%93%E8%B0%83%E7%94%A8%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>https://alliswell.top/wiki/%E5%BA%93%E8%B0%83%E7%94%A8%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</id>
    <published>2020-11-17T14:32:34.000Z</published>
    <updated>2021-01-26T02:48:56.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态库调用的那些事"><a href="#动态库调用的那些事" class="headerlink" title="动态库调用的那些事"></a>动态库调用的那些事</h1><h2 id="调用动态库的两种方式"><a href="#调用动态库的两种方式" class="headerlink" title="调用动态库的两种方式"></a>调用动态库的两种方式</h2><h3 id="1-类似静态库—-头文件"><a href="#1-类似静态库—-头文件" class="headerlink" title="1. 类似静态库—-头文件"></a>1. 类似静态库—-头文件</h3><p>这种方式生成的程序会在启动时候就加载so动态库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = add(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;7+8 = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成<code>libadd.so</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libadd.so add.c</span><br></pre></td></tr></table></figure><ul><li><p><code>-shared</code>表明生成共享库</p></li><li><p>如果不加<code>-fPIC</code>,则加载<code>.so</code>文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容, 这就造成每个使用这个<code>.so</code>文件代码段的进程在内核里都会生成这个<code>.so</code>文件代码段的copy.每个copy都不一样, 取决于<br>这个<code>.so</code>文件代码段和数据段内存映射的位置.</p></li><li><p>另外比较重要的第一点是最好显式添加<code>-fPIC</code>表明使用地址无关代码        PIC：Position Independent Code</p><blockquote><p>-shared</p><pre><code>       Produce a shared object which can then be linked with other objects to form an executable.  Not all systems support this option.  For predictable results, you must also specify the same set of       options used for compilation (-fpic, -fPIC, or model suboptions) when you specify this linker option.[1] </code></pre></blockquote></li></ul><p>编译main，使用<code>-L./</code>指定add库在当前目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -L./ -ladd</span><br></pre></td></tr></table></figure><p>此时如果不使用<code>-L</code>来指定动态库路径的话, 可以使用<code>LIBRARY_PATH</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LIBRARY_PATH=LIBDIR1:LIBDIR2:$LIBRARY_PATH</span><br></pre></td></tr></table></figure><ul><li><p><code>LIBRARY_PATH</code>为<em>程序编译期间</em>查找共享库的路径. </p><p>开发时，设置<code>LIBRARY_PATH</code>，以便gcc能够找到编译时需要的动态链接库</p></li></ul><h2 id="2-使用dlopen-dlsum动态加载动态库—-不使用头文件"><a href="#2-使用dlopen-dlsum动态加载动态库—-不使用头文件" class="headerlink" title="2. 使用dlopen/dlsum动态加载动态库—-不使用头文件"></a>2. 使用dlopen/dlsum动态加载动态库—-不使用头文件</h2><p>这种方式生成的程序会在代码执行到<strong>指定行位置</strong>加载so动态库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*手动加载指定位置的so动态库*/</span></span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">&quot;./libadd.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">int</span> (*add)(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根据动态链接库操作句柄与符号，返回符号对应的地址*/</span></span><br><span class="line">    add = dlsym(handle, <span class="string">&quot;add&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = add(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;7+8 = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<code>so</code>，生成<code>libadd.so</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libadd.so add.c</span><br></pre></td></tr></table></figure><p>编译main，不需要指定<code>libadd.so</code>相关信息进行编译，执行时候会在指定目录加载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -ldl</span><br></pre></td></tr></table></figure><p>一般需要添加<code>LD_LIBRARY_PATH</code></p><p><code>LD_LIBRARY_PATH</code>环境变量用于在<em>程序加载运行期间</em>查找动态链接库时指定除了系统默认路径之外的其他路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=LIBDIR1:LIBDIR2:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><ul><li>发布和使用时，设置<code>LD_LIBRARY_PATH</code>，以便程序加载运行时能够自动找到需要的动态链接库。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态库调用的那些事&quot;&gt;&lt;a href=&quot;#动态库调用的那些事&quot; class=&quot;headerlink&quot; title=&quot;动态库调用的那些事&quot;&gt;&lt;/a&gt;动态库调用的那些事&lt;/h1&gt;&lt;h2 id=&quot;调用动态库的两种方式&quot;&gt;&lt;a href=&quot;#调用动态库的两种方式&quot; class=&quot;headerlink&quot; title=&quot;调用动态库的两种方式&quot;&gt;&lt;/a&gt;调用动态库的两种方式&lt;/h2&gt;&lt;h3 id=&quot;1-类似静态库—-头文件&quot;&gt;&lt;a href=&quot;#1-类似静态库—-头文件&quot; class=&quot;headerlink&quot; title=&quot;1. 类似静态库—-头文件&quot;&gt;&lt;/a&gt;1. 类似静态库—-头文件&lt;/h3&gt;&lt;p&gt;这种方式生成的程序会在启动时候就加载so动态库。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//add.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//add.c&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x + y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//main.c&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;quot;add.h&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sum = add(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;7+8 = %d\n&amp;quot;&lt;/span&gt;, sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编译生成&lt;code&gt;libadd.so&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gcc -shared -fPIC -o libadd.so add.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-shared&lt;/code&gt;表明生成共享库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果不加&lt;code&gt;-fPIC&lt;/code&gt;,则加载&lt;code&gt;.so&lt;/code&gt;文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容, 这就造成每个使用这个&lt;code&gt;.so&lt;/code&gt;文件代码段的进程在内核里都会生成这个&lt;code&gt;.so&lt;/code&gt;文件代码段的copy.每个copy都不一样, 取决于&lt;br&gt;这个&lt;code&gt;.so&lt;/code&gt;文件代码段和数据段内存映射的位置.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外比较重要的第一点是最好显式添加&lt;code&gt;-fPIC&lt;/code&gt;表明使用地址无关代码        PIC：Position Independent Code&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-shared&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       Produce a shared object which can then be linked with other objects to form an executable.  Not all systems support this option.  For predictable results, you must also specify the same set of
       options used for compilation (-fpic, -fPIC, or model suboptions) when you specify this linker option.[1] &lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://alliswell.top/categories/Linux/"/>
    
    
    <category term="tools" scheme="https://alliswell.top/tags/tools/"/>
    
    <category term="总结" scheme="https://alliswell.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="动态库" scheme="https://alliswell.top/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>pkg-config的一点用法</title>
    <link href="https://alliswell.top/wiki/pkg-config%E7%9A%84%E4%B8%80%E7%82%B9%E7%94%A8%E6%B3%95/"/>
    <id>https://alliswell.top/wiki/pkg-config%E7%9A%84%E4%B8%80%E7%82%B9%E7%94%A8%E6%B3%95/</id>
    <published>2020-11-17T08:32:34.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h1><p>用于获取已安装库的基本信息</p><p><code>pkg-config</code>查看全部参数和意义</p><h2 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">program: program.c</span></span><br><span class="line">        cc program.c ‘pkg-config --cflags --libs gnomeui‘</span><br></pre></td></tr></table></figure><p>就是[–cflags] [–libs]，用来指出程序依赖的头文件和库文件路径</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>pkg-config</code>读取库名对应的<code>.pc</code>文件</p><p>默认情况下，会去<code>prefix/lib/pkgconfig/</code>路径下查找，具体到Linux系统，就是<code>/usr/lib/pkgconfig/</code>目录，若找不到，则会去<code>PKG_CONFIG_PATH</code>环境变量指定的路径下查找。因此，如果我们安装的库文件不在系统环境变量中，需要将其添加到<code>PKG_CONFIG_PATH</code>中，具体来说，执行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/home/mylibs/lib/pkgconfig:$PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure><p><code>sox.pc</code>内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prefix=/usr/local</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line"></span><br><span class="line">Name: SoX</span><br><span class="line">Description: Audio file format and effects library</span><br><span class="line">Version: 14.4.3git</span><br><span class="line">URL: http://sox.sourceforge.net</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lsox</span><br><span class="line">Libs.private: -lm </span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br></pre></td></tr></table></figure><p>最后两个参数可以简化Makefile的书写</p><h2 id="编写-pc"><a href="#编写-pc" class="headerlink" title="编写.pc"></a>编写<code>.pc</code></h2><h3 id="例子1-动态库的pc文件"><a href="#例子1-动态库的pc文件" class="headerlink" title="例子1 动态库的pc文件"></a>例子1 动态库的pc文件</h3><p>假设我写了libfoo.so，我的库将会被安装到/usr/local/lib/，头文件会放到/usr/local/include/foo。那么，pc文件可以这么写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">prefix=/usr/local</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line"></span><br><span class="line">Name: foo</span><br><span class="line">Description: The foo library</span><br><span class="line">Version: 1.0.0</span><br><span class="line">Cflags: -I$&#123;includedir&#125;/foo</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lfoo</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pkg-config&quot;&gt;&lt;a href=&quot;#pkg-config&quot; class=&quot;headerlink&quot; title=&quot;pkg-config&quot;&gt;&lt;/a&gt;pkg-config&lt;/h1&gt;&lt;p&gt;用于获取已安装库的基本信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pkg-config&lt;/code&gt;查看全部参数和意义&lt;/p&gt;
&lt;h2 id=&quot;典型用法&quot;&gt;&lt;a href=&quot;#典型用法&quot; class=&quot;headerlink&quot; title=&quot;典型用法&quot;&gt;&lt;/a&gt;典型用法&lt;/h2&gt;&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;program: program.c&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cc program.c ‘pkg-config --cflags --libs gnomeui‘&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;就是[–cflags] [–libs]，用来指出程序依赖的头文件和库文件路径&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pkg-config&lt;/code&gt;读取库名对应的&lt;code&gt;.pc&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;默认情况下，会去&lt;code&gt;prefix/lib/pkgconfig/&lt;/code&gt;路径下查找，具体到Linux系统，就是&lt;code&gt;/usr/lib/pkgconfig/&lt;/code&gt;目录，若找不到，则会去&lt;code&gt;PKG_CONFIG_PATH&lt;/code&gt;环境变量指定的路径下查找。因此，如果我们安装的库文件不在系统环境变量中，需要将其添加到&lt;code&gt;PKG_CONFIG_PATH&lt;/code&gt;中，具体来说，执行如下操作：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export PKG_CONFIG_PATH=/home/mylibs/lib/pkgconfig:$PKG_CONFIG_PATH&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://alliswell.top/categories/Linux/"/>
    
    
    <category term="pkg-config" scheme="https://alliswell.top/tags/pkg-config/"/>
    
    <category term="tools" scheme="https://alliswell.top/tags/tools/"/>
    
    <category term="总结" scheme="https://alliswell.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>shell 命令</title>
    <link href="https://alliswell.top/wiki/shell%E5%91%BD%E4%BB%A4/"/>
    <id>https://alliswell.top/wiki/shell%E5%91%BD%E4%BB%A4/</id>
    <published>2020-10-13T08:32:34.000Z</published>
    <updated>2021-01-26T02:48:56.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell-常用命令"><a href="#shell-常用命令" class="headerlink" title="shell 常用命令"></a>shell 常用命令</h1><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -ba *.spec  #编译打包rpm</span><br><span class="line">rpm -ivh *.rpm   #安装rpm包</span><br><span class="line">rpm -qpR *.rpm   #列出包依赖的库</span><br><span class="line">rpm -ql  *.rpm   #列出安装的内容</span><br><span class="line">rpm -qpl *.rpm   #列出未安装的包里内容</span><br><span class="line">rpm -qa | grep   #查找安装的相关包</span><br></pre></td></tr></table></figure><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp [-P port] file usr@x.x.x.x:~/dir  #local to remote</span><br><span class="line">scp [-P port] usr@x.x.x.x:~/dir/file  ./dir  #remote to local</span><br></pre></td></tr></table></figure><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -d or -P symbolic-link dir/   #复制软连接而不是文件本身</span><br></pre></td></tr></table></figure><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-p port] usr@x.x.x.x  #ssh登录远端</span><br></pre></td></tr></table></figure><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser &lt;username&gt;  #添加新用户</span><br><span class="line">usermod -aG sudo/wheel &lt;username&gt;  #用户添加到sudo组</span><br></pre></td></tr></table></figure><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a #查看系统版本信息的命令</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">uname -a</span><br><span class="line">hostnamectl</span><br><span class="line">uptime</span><br><span class="line">cat /proc/version #查看系统版本信息的命令</span><br><span class="line">cat /proc/sys/fs/inotify/max_user_watches #最大文件监控数</span><br><span class="line"><span class="meta">#</span><span class="bash"> The <span class="built_in">limit</span> can be increased to its maximum by editing /etc/sysctl.conf (except on Arch Linux, <span class="built_in">read</span> below) and adding this line to the end of the file:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fs.inotify.max_user_watches=524288</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The new value can <span class="keyword">then</span> be loaded <span class="keyword">in</span> by running sudo sysctl -p.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> While 524,288 is the maximum number of files that can be watched, <span class="keyword">if</span> you<span class="string">&#x27;re in an environment that is particularly memory constrained, you may wish to lower the number. Each file watch takes up 1080 bytes, so assuming that all 524,288 watches are consumed, that results in an upper bound of around 540 MiB.</span></span></span><br><span class="line"></span><br><span class="line">ls /proc[pid]  #查看进程信息</span><br><span class="line">watch -n 1 &quot;nstat | grep Tcp&quot; #查看机器网络变化信息, 排错可用</span><br><span class="line">df -lhT  #查看文件系统类型</span><br><span class="line">who  </span><br><span class="line">who -Hu #查看谁可以访问</span><br><span class="line">grep sh$ /etc/passwd  #查看谁有shell访问权限</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否物理机</span></span><br><span class="line">dmidecode -s system-manufacturer        </span><br><span class="line">dmidecode -s system-product-name        </span><br><span class="line">lshw -c system | grep product | head -1        </span><br><span class="line">cat /sys/class/dmi/id/product_name        </span><br><span class="line">cat /sys/class/dmi/id/sys_vendor        </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看硬件信息</span></span><br><span class="line">lscpu or cat /proc/cpuinfo</span><br><span class="line">lsmem or cat /proc/meminfo</span><br><span class="line">ifconfig -a</span><br><span class="line">ethtool &lt;devname&gt;</span><br><span class="line">lshw</span><br><span class="line">lspci</span><br><span class="line">dmidecode</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看进程和服务</span></span><br><span class="line">pstree -pa 1</span><br><span class="line">ps -ef</span><br><span class="line">ps auxf</span><br><span class="line">systemctl</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 网路</span></span><br><span class="line">netstat -tulpn</span><br><span class="line">netstat -anp</span><br><span class="line">lsof -i</span><br><span class="line">ss</span><br><span class="line">iptables -L -n</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内核</span></span><br><span class="line">[https://www.oreilly.com/library/view/red-hat-enterprise/9781785283550/ch10s05.html](https://www.oreilly.com/library/view/red-hat-enterprise/9781785283550/ch10s05.html)</span><br><span class="line">uname -r</span><br><span class="line">cat /proc/cmdline</span><br><span class="line">lsmod</span><br><span class="line">modinfo &lt;module&gt;</span><br><span class="line">sysctl -a</span><br><span class="line">cat /boot/grub2/grub.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志</span></span><br><span class="line">dmesg</span><br><span class="line">tail -f /var/log/messages</span><br><span class="line">journalctl</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 追踪</span></span><br><span class="line">strace</span><br></pre></td></tr></table></figure><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git archive --prefix=output/ -o &quot;../output.tar.gz&quot; develop  #git库打包</span><br></pre></td></tr></table></figure><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum reinstall packagename  #可以在/var/cache/yum目录下找到包</span><br><span class="line">yum provides *.so.version  #查询哪个包提供这个库</span><br></pre></td></tr></table></figure><h2 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --variable pc_path pkg-config #查看pc路径</span><br></pre></td></tr></table></figure><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make V=1 #展示出具体编译命令</span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> get all filename <span class="keyword">in</span> specified path</span></span><br><span class="line"></span><br><span class="line">path=$1</span><br><span class="line">files=$(ls $path)</span><br><span class="line">for file in $files</span><br><span class="line">do</span><br><span class="line">  mv $file &#x27;bad-&#x27;$file</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;shell-常用命令&quot;&gt;&lt;a href=&quot;#shell-常用命令&quot; class=&quot;headerlink&quot; title=&quot;shell 常用命令&quot;&gt;&lt;/a&gt;shell 常用命令&lt;/h1&gt;&lt;h2 id=&quot;rpm&quot;&gt;&lt;a href=&quot;#rpm&quot; class=&quot;headerlink&quot; title=&quot;rpm&quot;&gt;&lt;/a&gt;rpm&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rpmbuild -ba *.spec  #编译打包rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -ivh *.rpm   #安装rpm包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -qpR *.rpm   #列出包依赖的库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -ql  *.rpm   #列出安装的内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -qpl *.rpm   #列出未安装的包里内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -qa | grep   #查找安装的相关包&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;scp&quot;&gt;&lt;a href=&quot;#scp&quot; class=&quot;headerlink&quot; title=&quot;scp&quot;&gt;&lt;/a&gt;scp&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp [-P port] file usr@x.x.x.x:~/dir  #local to remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scp [-P port] usr@x.x.x.x:~/dir/file  ./dir  #remote to local&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;cp&quot;&gt;&lt;a href=&quot;#cp&quot; class=&quot;headerlink&quot; title=&quot;cp&quot;&gt;&lt;/a&gt;cp&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cp -d or -P symbolic-link dir/   #复制软连接而不是文件本身&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;ssh&quot;&gt;&lt;a href=&quot;#ssh&quot; class=&quot;headerlink&quot; title=&quot;ssh&quot;&gt;&lt;/a&gt;ssh&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh [-p port] usr@x.x.x.x  #ssh登录远端&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;user&quot;&gt;&lt;a href=&quot;#user&quot; class=&quot;headerlink&quot; title=&quot;user&quot;&gt;&lt;/a&gt;user&lt;/h2&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://alliswell.top/categories/Linux/"/>
    
    
    <category term="总结" scheme="https://alliswell.top/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="shell" scheme="https://alliswell.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-136. 只出现一次的数字</title>
    <link href="https://alliswell.top/wiki/LeetCode-136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://alliswell.top/wiki/LeetCode-136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-05-14T01:40:09.000Z</published>
    <updated>2021-01-26T02:48:56.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><a id="more"></a><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line"><span class="section">输入: [2,2,1]</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line"><span class="section">输入: [4,1,2,1,2]</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 异或 ⊕ 的特性</span></span><br><span class="line">        <span class="comment">// 0 异或 x  = x</span></span><br><span class="line">        <span class="comment">// x 异或 b = b</span></span><br><span class="line">        <span class="comment">// b 异或 b = 0</span></span><br><span class="line">        <span class="comment">//满足交换律结合律</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> it:nums)&#123;</span><br><span class="line">            ans^=it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;136-只出现一次的数字&quot;&gt;&lt;a href=&quot;#136-只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;136. 只出现一次的数字&quot;&gt;&lt;/a&gt;136. 只出现一次的数字&lt;/h1&gt;&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://alliswell.top/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="https://alliswell.top/categories/Algorithm/LeetCode/"/>
    
    
    <category term="C++" scheme="https://alliswell.top/tags/C/"/>
    
    <category term="hash" scheme="https://alliswell.top/tags/hash/"/>
    
    <category term="异或运算" scheme="https://alliswell.top/tags/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
</feed>
